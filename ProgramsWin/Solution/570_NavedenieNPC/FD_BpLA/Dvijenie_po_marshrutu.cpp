#include "CFlightDynamicsBpLA.h"
#include "../Settings.h"


//////////////////////////////////////////////////////////// Модель движения НПЦ по маршруту /////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int CFlightDynamicsBpLA::Dvijenie_po_marshrutu()
{
	size_t deltaF = 1 / dt;                                                   // Количество отсчетов за интервал моделирования траектории НПЦ (1 с)

	double krenmax = 30.0;                                                    // Максимально допустимый угол крена НПЦ - необходим для построения поворотов на маршруте
	
	if (init_StopObj == true)
	{
		size_t N_i = 1.0 / dt;

		double xns = plane.curPos.x;
		double yns = plane.curPos.y;
		double zns = plane.curPos.z;
						
		for (T_i; T_i < N_i; T_i++)                                     
		{						
			F_LastTime = F_LastTime + dt;

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xns;
			plane.curPos.y = yns;
			plane.curPos.z = zns;
			plane.curPos.fi = plane.curPos.fi;
			plane.curPos.teta = plane.curPos.teta;
			plane.curPos.gamma = 0.0;

			plane.Trajectory.push_back(plane.curPos);                                                                                                               // Запись в вектор n-й точки

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xns, yns, zns, 0.001 * plane.curPos.vx, 0.001 * plane.curPos.vy, 0.001 * plane.curPos.vz, 0.0);   // Запись в фильм начальной точки 
           
			if (deltaF < 1)
			{
				T_i = 0;
				break;
			}
		}
		
		return 0;
	}

	// Построение траектории движения НПЦ по маршруту //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	for (P_i; P_i < plane.object.getPointCount(); P_i++)                 // Перебор точек маршрута
	{
			CPointGlobal p1 = plane.object.getPoint(P_i - 1);            // Расчет координат НПЦ в геоцентрической СК в 1 точке
			CPointGlobal p2 = plane.object.getPoint(P_i);                // Расчет координат НПЦ в геоцентрической СК во 2 точке

			CPointGeo p1g = plane.object.getPointGeo(P_i - 1);           // Расчет координат НПЦ в геодезической СК в 1 точке
			CPointGeo p2g = plane.object.getPointGeo(P_i);               // Расчет координат НПЦ в геодезической СК во 2 точке

			double H1 = p1g.getAltitude();                               // Считываем высоту в точке 1 в геодезической СК
			double H2 = p2g.getAltitude();                               // Считываем высоту в точке 2 в геодезической СК

			double B1 = p1g.getLatitude();                               // Считываем широту в точке 1 в геодезической СК
			double B2 = p2g.getLatitude();                               // Считываем широту в точке 2 в геодезической СК

			double L1 = p1g.getLongitude();                              // Считываем долготу в точке 1 в геодезической СК
			double L2 = p2g.getLongitude();                              // Считываем долготу в точке 2 в геодезической СК

			// Корректировка назначаемой высоты
			
			if (H1 != 0.0)
			{
				H1 = 0.0;
			}

			if (H2 != 0.0)
			{
				H2 = 0.0;
			}
			
			//

			// Задание начального отсчета времени

			if (init_0m == true)
			{
				EndTime = p1.getTime();
				init_0m = false;
			}
			
			//
			
			double delT = EndTime - p1.getTime();                       // Разность между реальным временем выхода в точку и заданным по сценарию временем

			if ((abs(delT) >= dt) && (EndTime != 0.0))                  // Если модуль разности больше или равен дискрету моделирования и текущее время выхода в точку не равно нулю 
			{
				p1.setTime(EndTime);                                    // Время выхода в точку по сценарию принимается равным реальному времени выхода в точку
			}

			p1g = CPointGeo(p1.getTime(), B1, L1, H1);                  // Расчет координат НПЦ  со скорректированной высотой и временем в геодезической СК в 1 точке
			p1g.setVelocity(p1.getVelocity());
			p1 = p1g.toPointGlobal();                                   // Расчет координат НПЦ  со скорректированной высотой и временем в геоцентрической СК в 1 точке

			p2g = CPointGeo(p2.getTime(), B2, L2, H2);                  // Расчет координат НПЦ  со скорректированной высотой и временем в геодезической СК во 2 точке
			p2g.setVelocity(p2.getVelocity());
			p2 = p2g.toPointGlobal();                                   // Расчет координат НПЦ  со скорректированной высотой и временем в геоцентрической СК во 2 точке

			double x1 = p1.getPosition().getX();                        // Определение координаты x НПЦ в геоцентрической СК в 1 точке
			double x2 = p2.getPosition().getX();                        // Определение координаты x НПЦ в геоцентрической СК во 2 точке

			double y1 = p1.getPosition().getY();                        // Определение координаты y НПЦ в геоцентрической СК в 1 точке
			double y2 = p2.getPosition().getY();                        // Определение координаты y НПЦ в геоцентрической СК во 2 точке

			double z1 = p1.getPosition().getZ();                        // Определение координаты z НПЦ в геоцентрической СК в 1 точке
			double z2 = p2.getPosition().getZ();                        // Определение координаты z НПЦ в геоцентрической СК во 2 точке

			CPoint3D zentr1(x1, y1, z1);                                // Создание центра местной СК в 1 точке
			CPointLocal result1 = p1.toPointLocal(zentr1);              // Перевод точки p1 из геоцентрической СК в местную СК
			CPointLocal result2 = p2.toPointLocal(zentr1);              // Перевод точки p2 из геоцентрической СК в местную СК

			double xg1 = result1.getPosition().getX();                  // Определение координаты xg НПЦ в местной СК в 1 точке
			double xg2 = result2.getPosition().getX();                  // Определение координаты xg НПЦ в местной СК во 2 точке

			double yg1 = result1.getPosition().getY();                  // Определение координаты yg НПЦ в местной СК в 1 точке
			double yg2 = result2.getPosition().getY();                  // Определение координаты yg НПЦ в местной СК во 2 точке

			double zg1 = result1.getPosition().getZ();                  // Определение координаты zg НПЦ в местной СК в 1 точке
			double zg2 = result2.getPosition().getZ();                  // Определение координаты zg НПЦ в местной СК во 2 точке

			double T = abs(p2.getTime() + delT - p1.getTime());         // Время движения от точки 1 до точки 2

			double D = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1)); // Расчет дальности между 1 точкой и 2 точкой

			double V1 = p1.getVelocity().getLength();                                           // Скорость НПЦ в 1 точке
			
			double V2 = 2 * D / T - V1;                                 // Расчет скорости НПЦ во 2 точке
	
		if (init_1m == true)                                            // Если инициализация исходных значений параметров разрешена
		{
			double kurs = atan((xg2 - xg1) / (yg2 - yg1));              // Расчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки с учетом его знака относительно оси OgYg в местной СК //

			if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) >= 0.0))
			{
				kurs = kurs;
			}
			else
				if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) < 0.0))
				{
					kurs = kurs + Pi;
				}
				else
					if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) >= 0.0))
					{
						kurs = kurs + 2 * Pi;
					}
					else
						if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) < 0.0))
						{
							kurs = kurs + Pi;
						}

		//

			double xnm1 = x1;                                         // Задание начального значения координаты x в геоцентрической СК в (n-1)-й момент времени
			double xn = xnm1;                                         // Задание начального значения координаты x в геоцентрической СК в n-й момент времени

			double ynm1 = y1;                                         // Задание начального значения координаты y в геоцентрической СК в (n-1)-й момент времени
			double yn = ynm1;                                         // Задание начального значения координаты y в геоцентрической СК в n-й момент времени

			double znm1 = z1;                                         // Задание начального значения координаты z в геоцентрической СК в (n-1)-й момент времени
			double zn = znm1;                                         // Задание начального значения координаты z в геоцентрической СК в n-й момент времени

			double xgnm1 = xg1;                                       // Задание начального значения координаты x в местной СК в (n-1)-й момент времени
			double xgn = xgnm1;                                       // Задание начального значения координаты x в местной СК в n-й момент времени

			double ygnm1 = yg1;                                       // Задание начального значения координаты y в местной СК в (n-1)-й момент времени
			double ygn = ygnm1;                                       // Задание начального значения координаты y в местной СК в n-й момент времени

			double zgnm1 = zg1;                                       // Задание начального значения координаты z в местной СК в (n-1)-й момент времени
			double zgn = zgnm1;                                       // Задание начального значения координаты z в местной СК в n-й момент времени

			double Vnm1 = V1;                                         // Задание начального значения скорости НПЦ в (n-1)-й момент времени
			double Vn = Vnm1;                                         // Задание начального значения скорости НПЦ в n-й момент времени

			F_LastTime = p1.getTime();
			double time = p1.getTime();                               // Задание отсчетов времени (используется при выставлении курса НПЦ)

		// Появление НПЦ на поле боя //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			Film.writeLog(plane.object.getObjNum(), plane.curPos.time, "Находится в 1 точке");      // Запись в фильм комментария
						
			for (size_t m = 1; m < 2; m++)                                                          // Для двух шагов моделирования выставления курса НПЦ
			{
				Vn = Vnm1;                                                                          // Расчет скорости НПЦ в n-й момент времени

				double Vxgn = Vn * sin(kurs);                                                       // Расчет проекции вектора скорости НПЦ на ось OgXg местной СК в n-й момент времени
				double Vygn = Vn * cos(kurs);                                                       // Расчет проекции вектора скорости НПЦ на ось OgYg местной СК в n-й момент времени
				double Vzgn = 0.0;                                                                  // Расчет проекции вектора скорости НПЦ на ось OgZg местной СК в n-й момент времени

				xgn = xgnm1 + Vxgn * dt;                                                            // Расчет координаты xg НПЦ в местной СК в n-й момент времени
				ygn = ygnm1 + Vygn * dt;                                                            // Расчет координаты yg НПЦ в местной СК в n-й момент времени
				zgn = zgnm1;                                                                        // Расчет координаты zg НПЦ в местной СК в n-й момент времени

				time = p1.getTime() + m * dt;                                                       // Задание отсчетов времени

				CPointLocal res1 = CPointLocal(time, CPoint3D(xgn, ygn, zgn));                      // Создание точки в n-й момент времени в местной СК с центром в начальной точке
				CPointGlobal resgeo1 = res1.toPointGlobal(zentr1);                                  // Преобразование созданной точки из местной СК в геоцентрическую СК

				xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
				yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
				zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

				// Определение углов пространственной ориентации НПЦ в геоцентрической СК //

				double rn = atan((xn - xnm1) / (yn - ynm1));

				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn;
				}
				else
					if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
						{
							rn = rn + 2 * Pi;
						}
						else
							if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
							{
								rn = rn + Pi;
							}

				double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

				//

				double Vx1 = V1 * cos(cn) * sin(rn);                                                // Расчет проекции вектора скорости НПЦ на ось OX геоцентрической  СК в начальной точке
				double Vy1 = V1 * cos(cn) * cos(rn);                                                // Расчет проекции вектора скорости НПЦ на ось OY геоцентрической  СК в начальной точке
				double Vz1 = V1 * sin(cn);                                                          // Расчет проекции вектора скорости НПЦ на ось OZ геоцентрической  СК в начальной точке

				double gam1 = 0.0;                                                                  // Начальное значение угла крена для вывода на интерфейс в градусах 

				Film.writePoint(plane.object.getObjNum(), p1.getTime(), x1, y1, z1, Vx1, Vy1, Vz1, gam1);   // Запись в фильм начальной точки 
                
			// Запись параметров движения НПЦ в начальный (нулевой) момент времени

				plane.curPos.time = p1.getTime();
				plane.curPos.x = x1;
				plane.curPos.y = y1;
				plane.curPos.z = z1;
				plane.curPos.vx = Vx1;
				plane.curPos.vy = Vy1;
				plane.curPos.vz = Vz1;
				plane.curPos.fi = kurs;
				plane.curPos.teta = 0.0;
				plane.curPos.gamma = gam1 * Pi / 180.0;

				plane.Trajectory.push_back(plane.curPos);                // Запись начальной точки в вектор
			}
			
			//

			init_1m = false;                                             // Признак запрета инициализации исходных значений параметров
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                        // Определение координаты x НПЦ в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                        // Определение координаты y НПЦ в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                        // Определение координаты z НПЦ в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                      // Определение проекции вектора скорости НПЦ на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                      // Определение проекции вектора скорости НПЦ на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                      // Определение проекции вектора скорости НПЦ на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                    // Определение угла поворота траектории НПЦ при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                  // Определение угла наклона траектории НПЦ при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                  // Определение угла скоростного крена НПЦ при наборе высоты в (n-1)-й момент времени в радианах

	// Приведение kursnm1 к интервалу от 0 до 2 пи

	if (kursnm1 >= 2 * Pi)
	{
		kursnm1 = kursnm1 - 2 * Pi;
	}

	if (kursnm1 < 0)
	{
		kursnm1 = kursnm1 + 2 * Pi;
	}

	//

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1)); // Создание точки в (n-1)-й момент времени в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                      // Создание центра местной СК в начальной точке
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                      // Перевод точки p1 из геоцентрической СК в местную СК

	double xn = xnm1;                                                         // Задание начального значения координаты x НПЦ в геоцентрической СК в в n-й момент времени
	double yn = ynm1;                                                         // Задание начального значения координаты y НПЦ в геоцентрической СК в в n-й момент времени
	double zn = znm1;                                                         // Задание начального значения координаты z НПЦ в геоцентрической СК в в n-й момент времени

	double xgnm1 = resultnm1.getPosition().getX();                            // Определение координаты xg НПЦ в местной СК в начальной точке
	double ygnm1 = resultnm1.getPosition().getY();                            // Определение координаты yg НПЦ в местной СК в начальной точке
	double zgnm1 = resultnm1.getPosition().getZ();                            // Определение координаты zg НПЦ в местной СК в начальной точке

	double xgn = xgnm1;                                                       // Задание начального значения координаты xg НПЦ в местной СК в n-й момент времени
	double ygn = ygnm1;                                                       // Задание начального значения координаты yg НПЦ в местной СК в n-й момент времени
	double zgn = zgnm1;                                                       // Задание начального значения координаты zg НПЦ в местной СК в n - й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                      // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                    // Определение широты НПЦ в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                   // Определение долготы НПЦ в (n-1)-й момент времени в геодезической СК
	double hnm1 = 0.0;                                                    // Определение высоты НПЦ в (n-1)-й момент времени в геодезической СК

	double Bn = Bnm1;                                                     // Задание начального значения широты НПЦ в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                     // Задание начального значения долготы НПЦ в n-й момент времени в геодезической СК
	double hn = hnm1;                                                     // Задание начального значения высоты НПЦ в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                   // Задание начального значения проекции вектора скорости НПЦ на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                   // Задание начального значения проекции вектора скорости НПЦ на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                   // Задание начального значения проекции вектора скорости НПЦ на ось OZ в геоцентрической СК в n-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);    // Расчет скорости НПЦ в (n-1)-й момент времени
	double Vn = Vnm1;                                                     // Задание начального значения скорости НПЦ в n-й момент времени

	double kursn = kursnm1;                                               // Задание начального значения угла поворота траектории НПЦ при развороте в n-й момент времени
	double tetan = tetanm1;                                               // Задание начального значения угла наклона траектории НПЦ при развороте в n-й момент времени
	double gamn = gamnm1;                                                 // Задание начального значения угла скоростного крена НПЦ при развороте в n-й момент времени
		
	//
	
	//

	if (init_2m == true)                                                 // Если инициализация исходных значений параметров разрешена при развороте на точку визирования
	{
		double x1 = xn;                                                  // Задание значения координаты x НПЦ в геоцентрической СК в 1 точке
		double y1 = yn;                                                  // Задание значения координаты y НПЦ в геоцентрической СК в 1 точке
		double z1 = zn;                                                  // Задание значения координаты z НПЦ в геоцентрической СК в 1 точке

		CPointGlobal p1 = CPointGlobal(F_LastTime, CPoint3D(x1, y1, z1));     // Создание начальной точки вывода НПЦ (1-й точки) в геоцентрической СК

		CPointLocal result1 = p1.toPointLocal(zentrnm1);                      // Перевод точки p1 из геоцентрической СК в местную СК с центром в 1-й точке
		CPointLocal result2 = p2.toPointLocal(zentrnm1);                      // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg1 = result1.getPosition().getX();                            // Определение координаты xg НПЦ в местной СК в 1 точке
		double xg2 = result2.getPosition().getX();                            // Определение координаты xg НПЦ в местной СК во 2 точке

		double yg1 = result1.getPosition().getY();                            // Определение координаты yg НПЦ в местной СК в 1 точке
		double yg2 = result2.getPosition().getY();                            // Определение координаты yg НПЦ в местной СК во 2 точке

		double zg1 = result1.getPosition().getZ();                            // Определение координаты zg НПЦ в местной СК в 1 точке
		double zg2 = result2.getPosition().getZ();                            // Определение координаты zg НПЦ в местной СК во 2 точке

		f2_m = atan((xg2 - xg1) / (yg2 - yg1));                          // Расчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

		if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) >= 0.0))
		{
			f2_m = f2_m;
		}
		else
			if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) < 0.0))
			{
				f2_m = f2_m + Pi;
			}
			else
				if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) >= 0.0))
				{
					f2_m = f2_m + 2 * Pi;
				}
				else
					if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) < 0.0))
					{
						f2_m = f2_m + Pi;
					}

		//
		
		// Задание значения шага изменения угла поворота траектории НПЦ //
		
		if (P_i == 1)
		{
			B1 = p1g.getLatitude();                               // Считываем широту в точке 1 в геодезической СК
		}
		else
		{
			B1 = Bn;
		}

		if (P_i == 1)
		{
			L1 = p1g.getLongitude();                              // Считываем широту в точке 1 в геодезической СК
		}
		else
		{
			L1 = Ln;
		}
				

		double L1r = L1;
		double L2r = L2;
		double B1r = B1 + 90.0;
		double B2r = B2 + 90.0;

		if (L1 >= 0.0)
		{
			L1r = L1;
		}
		else
			if (L1 < 0.0)
			{
				L1r = L1 + 360.0;
			}

		if (L2 >= 0.0)
		{
			L2r = L2;
		}
		else
			if (L2 < 0.0)
			{
				L2r = L2 + 360.0;
			}

		if (abs(L1r - L2r) >= 180.0 && L1r < L2r)
		{
			L2r = L2r - 360.0;
		}

		if (abs(L1r - L2r) >= 180.0 && L1r > L2r)
		{
			L1r = L1r - 360.0;
		}

		if (abs(L1r - L2r) < 180.0 && L1r < L2r)
		{
			L2r = L2r;
		}

		if (abs(L1r - L2r) < 180.0 && L1r > L2r)
		{
			L1r = L1r;
		}

		if (((B1r <= B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
			((B1r <= B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))) ||
			((B1r > B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
			((B1r > B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))))
		{
			dfi_m = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                                         // Задание значения шага изменения угла поворота траектории НПЦ при правом развороте
		}
		else
			if (((B1r <= B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
				((B1r <= B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))) ||
				((B1r > B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
				((B1r > B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))))
			{
				dfi_m = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                                   // Задание значения шага изменения угла поворота траектории НПЦ при левом развороте
			}

		//
				
		
		double R = Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0));                                      // Вычисление требуемого радиуса разворота при максимально допустимом крене
		double D = sqrt((xg2 - xg1) * (xg2 - xg1) + (yg2 - yg1) * (yg2 - yg1) + (zg2 - zg1) * (zg2 - zg1));                     // Вычисление расстояния между 1 и 2 точками
		
		if ((2 * R >= D) && (abs(f2_m - kursnm1) > Vnm1 * dt / R))                                                              // Если диаметр разворота больше расстояния между 1 и 2 точками, и разность курса и угла визирования 2 точки из 1 точки в горизонтальной плоскости больше  изменения угла поворота траектории НПЦ при значении 30 градусов ее скоростного крена
		{
			if (((B1r <= B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
				((B1r <= B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))) ||
				((B1r > B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
				((B1r > B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))))
			{
				dfi_m = 2 * Vnm1 * dt / D;                                                  // Задание значения шага изменения угла поворота траектории НПЦ при правом развороте
			}
			else
				if (((B1r <= B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
					((B1r <= B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))) ||
					((B1r > B2r) && (L1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
					((B1r > B2r) && (L1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))))
				{
					dfi_m = -2 * Vnm1 * dt / D;                                             // Задание значения шага изменения угла поворота траектории НПЦ при левом развороте
				}

		}
		
		//

		fn_m = f2_m;                                                                        // Начальное значение угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		init_2m = false;                                                                    // Запрет инициализации исходных значений параметров при развороте на точку визирования
	}
		
	//

	size_t cur_F_n = F_n + deltaF;                                                          // Номер отсчета времени выхода НПЦ в точку в конце интервала моделирования траектории НПЦ (1 с)

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Разворот на точку визирования //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	while (abs(fn_m - kursn) > abs(dfi_m))                                            // До тех пор, пока разность угла поворота траектории и угла визирования в горизонтальной плоскости больше dfi_m
	{
		if (init_3m == false || init_4m == false)                                     // Если уже рассчитывается горизонтирование с набором скорости или полет с доворотом на точку визирования
		{
			break;                                                                    // Стоп
		}
		
		kursn = kursnm1 + dfi_m;                                                      // Расчет угла поворота траектории НПЦ в n-й момент времени

		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		double Vxgn = Vn * sin(kursn);                                                // Расчет проекции вектора скорости НПЦ на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(kursn);                                                // Расчет проекции вектора скорости НПЦ на ось OgYg местной СК в n-й момент времени
		double Vzgn = 0.0;                                                            // Расчет проекции вектора скорости НПЦ на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                      // Расчет координаты xg НПЦ в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                      // Расчет координаты yg НПЦ в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                      // Расчет координаты zg НПЦ в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                 // Задание отсчетов времени
				
		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));          // Расчет координат НПЦ в n-й момент времени в местной СК с центром в 1 точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                          // Расчет координат НПЦ в n-й момент времени в геоцентрической СК

		xn = resgeo1.getPosition().getX();                                            // Определение координаты x НПЦ в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                            // Определение координаты y НПЦ в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                            // Определение координаты z НПЦ в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));             // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                              // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                                       // Определение высоты НПЦ в n-й момент времени в геодезической СК

		CPointLocal result2 = p2.toPointLocal(zentrnm1);                              // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg2 = result2.getPosition().getX();                                    // Определение координаты xg НПЦ в местной СК во 2 точке
		double yg2 = result2.getPosition().getY();                                    // Определение координаты yg НПЦ в местной СК во 2 точке
		double zg2 = result2.getPosition().getZ();                                    // Определение координаты zg НПЦ в местной СК во 2 точке

		fn_m = atan((xg2 - xgn) / (yg2 - ygn));                                       // Расчет угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени //

		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
		{
			fn_m = fn_m;
		}
		else
			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
			{
				fn_m = fn_m + Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
				{
					fn_m = fn_m + 2 * Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
					{
						fn_m = fn_m + Pi;
					}

		//

		// Определение углов пространственной ориентации НПЦ в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                  // Расчет проекции вектора скорости НПЦ на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                  // Расчет проекции вектора скорости НПЦ на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                            // Расчет проекции вектора скорости НПЦ на ось OZ геоцентрической СК в n-й момент времени

		// Расчет значения скоростного крена НПЦ в n-й момент времени в градусах для вывода на интерфейс

		double gamman = 0.0;
				
			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);         // Запись в фильм n-й точки в фильм	
           
			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки		
		

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		kursnm1 = kursn;
		tetanm1 = tetan;

		//
		
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения НПЦ равен номеру отсчета времени разворота НПЦ в конце интервала моделирования траектории НПЦ (1 с)
		{
			return 0;                                                                           // Продолжение движения НПЦ
		}

	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Набор заданной скорости (по ситуации) //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_3m == true)                                                                   // Если инициализация исходных значений параметров разрешена при наборе заданной скорости (по ситуации)
	{
		Vish_3m = Vn;                                                                      // Задание исходной скорости НПЦ в начале набора заданной скорости (по ситуации)
		Hish_3m = 0.0;                                                                     // Задание исходного угла наклона траектории НПЦ в начале набора заданной скорости (по ситуации)
		init_3m = false;                                                                   // Запрет инициализации исходных значений параметров в начале набора заданной скорости (по ситуации)
	}

	if (Vish_3m != V2)                                                                     // Если исходная скорость НПЦ не равна заданной скорости
	{
		double dV = 0.0;                                                                   // Задание начального значения шага изменения скорости

		if (abs(V2 - Vish_3m) <= 1.0)                                                      // Если модуль разности заданной и исходной скорости меньше или равен 1 м/с
		{
			dV = (V2 - Vish_3m) / (0.1 / dt);                                              // Расчет шага изменения скорости полета НПЦ на заданной высоте исходя из 1 такта (0.1 с)
		}
		else
			if (abs(V2 - Vish_3m) > 1.0)                                                   // Если модуль разности заданной и исходной скорости больше 1 м/с
			{
				dV = (V2 - Vish_3m) / (10.0 / dt);                                         // Расчет шага изменения скорости полета НПЦ на заданной высоте исходя из 100 тактов (10 с)
			}
		

		while (Vn != V2)                                                                   // До тех пор, пока текущая скорость НПЦ не равна заданной скорости НПЦ
		{
			if (init_4m == false)                                  // Если уже рассчитывается движение с дворотом на точку визирования
			{
				break;                                             // Стоп
			}

			if (abs(Vn - V2) > abs(dV))                            // Если модуль разности текущей скорости НПЦ и заданной скорости после разворота скорости меньше модуля шага изменения скорости
			{
				Vn = Vnm1 + dV;                                    // Расчет скорости НПЦ в n-й момент времени
			}

			if (abs(Vn - V2) <= abs(dV))                           // Если модуль разности текущей скорости НПЦ и заданной скорости после разворота скорости меньше или равен модулю шага изменения скорости
			{
				Vn = V2;                                           // Скорость НПЦ n-й момент времени приравнивается к заданной скорости
			}
			
			double Vxgn = Vn * sin(kursn);                         // Расчет проекции вектора скорости НПЦ на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(kursn);                         // Расчет проекции вектора скорости НПЦ на ось OgYg местной СК в n-й момент времени
			double Vzgn = 0.0;                                     // Расчет проекции вектора скорости НПЦ на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg НПЦ в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg НПЦ в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg НПЦ в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));    // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                    // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                      // Определение координаты x НПЦ в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                      // Определение координаты y НПЦ в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                      // Определение координаты z НПЦ в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));       // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                        // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                // Определение широты НПЦ в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                               // Определение долготы НПЦ в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                // Определение высоты НПЦ в n-й момент времени в геодезической СК

			// Стабилизация заданной высоты полета НПЦ //

			if (hn != Hish_3m)                                                      // Если текущая высота не равна исходной высоте
			{
				hn = Hish_3m;                                                       // Текущая высота приравнивается к исходной высоте

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                 // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                            // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xn = pkn.getPosition().getX();                                      // Определение координаты x НПЦ в n-й момент времени в геоцентрической СК
				yn = pkn.getPosition().getY();                                      // Определение координаты y НПЦ в n-й момент времени в геоцентрической СК
				zn = pkn.getPosition().getZ();                                      // Определение координаты z НПЦ в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));  // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1);                   // Перевод точки pno из геоцентрической СК в местную СК

				xgn = result1.getPosition().getX();                                 // Определение координаты xg НПЦ в местной СК в n-й момент времени
				ygn = result1.getPosition().getY();                                 // Определение координаты yg НПЦ в местной СК в n-й момент времени
				zgn = result1.getPosition().getZ();                                 // Определение координаты zg НПЦ в местной СК в n-й момент времен
			}

			// Определение углов пространственной ориентации НПЦ в геоцентрической СК 

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости НПЦ на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости НПЦ на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости НПЦ на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                  // Значение скоростного крена НПЦ в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись n-й точки в фильм
            
			// Обновление параметров с интервалом 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;

			// Запись параметров движения НПЦ

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения НПЦ равен номеру отсчета времени горизонтирования после разворота НПЦ в конце интервала моделирования траектории НПЦ (1 с)
			{
				return 0;                                                                           // Продолжение движения НПЦ
			}
		}

	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Движение с доворотом на точку визирования //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_4m == true)                                                        // Если инициализация исходных значений параметров разрешена при полете с доворотом на точку визирования
	{
		Hish_4m = 0.0;                                                          // Задание исходной высоты в начале полета с доворотом на точку визирования

		double x1 = xn;                                                         // Задание начального значения координаты x НПЦ в геоцентрической СК
		double y1 = yn;                                                         // Задание начального значения координаты y НПЦ в геоцентрической СК
		double z1 = zn;                                                         // Задание начального значения координаты z НПЦ в геоцентрической СК

		CPointGlobal p1 = CPointGlobal(F_LastTime, CPoint3D(x1, y1, z1));       // Создание начальной точки вывода НПЦ (1-й точки) в геоцентрической СК

		CPointLocal result1 = p1.toPointLocal(zentrnm1);                        // Перевод точки p1 из геоцентрической СК в местную СК с центром в 1-й точке
		CPointLocal result2 = p2.toPointLocal(zentrnm1);                        // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg1 = result1.getPosition().getX();                              // Определение координаты xg НПЦ в местной СК (в 1 точке)
		double xg2 = result2.getPosition().getX();                              // Определение координаты xg 2-й точки в местной СК (во 2 точке)

		double yg1 = result1.getPosition().getY();                              // Определение координаты yg НПЦ в местной СК (в 1 точке)
		double yg2 = result2.getPosition().getY();                              // Определение координаты yg 2-й точки в местной СК (во 2 точке)

		double zg1 = result1.getPosition().getZ();                              // Определение координаты zg НПЦ в местной СК (в 1 точке)
		double zg2 = result2.getPosition().getZ();                              // Определение координаты zg 2-й точки в местной СК (во 2 точке)

		f2_m = atan((xg2 - xg1) / (yg2 - yg1));                                 // Расчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

		if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) >= 0.0))
		{
			f2_m = f2_m;
		}
		else
			if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) < 0.0))
			{
				f2_m = f2_m + Pi;
			}
			else
				if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) >= 0.0))
				{
					f2_m = f2_m + 2 * Pi;
				}
				else
					if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) < 0.0))
					{
						f2_m = f2_m + Pi;
					}

		// Задание значения шага изменения угла поворота траектории НПЦ //

		CPointGeo pg1 = p1.toPointGeo();                         // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bnm1 = pg1.getLatitude();                                // Определение широты НПЦ в n-й момент времени в геодезической СК
		Lnm1 = pg1.getLongitude();                               // Определение долготы НПЦ в n-й момент времени в геодезической СК
		hnm1 = pg1.getAltitude();                                // Определение высоты НПЦ в n-й момент времени в геодезической СК
		
		double Lnm1r = Lnm1;
		double L2r = L2;
		double Bnm1r = Bnm1 + 90.0;
		double B2r = B2 + 90.0;

		if (Lnm1 >= 0.0)
		{
			Lnm1r = Lnm1;
		}
		else
			if (Lnm1 < 0.0)
			{
				Lnm1r = Lnm1 + 360.0;
			}

		if (L2 >= 0.0)
		{
			L2r = L2;
		}
		else
			if (L2 < 0.0)
			{
				L2r = L2 + 360.0;
			}

		if (abs(Lnm1r - L2r) >= 180.0 && Lnm1r < L2r)
		{
			L2r = L2r - 360.0;
		}

		if (abs(Lnm1r - L2r) >= 180.0 && Lnm1r > L2r)
		{
			Lnm1r = Lnm1r - 360.0;
		}

		if (abs(Lnm1r - L2r) < 180.0 && Lnm1r < L2r)
		{
			L2r = L2r;
		}

		if (abs(Lnm1r - L2r) < 180.0 && Lnm1r > L2r)
		{
			Lnm1r = Lnm1r;
		}

		if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
			((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))) ||
			((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
			((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))))
		{
			dfi_m = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                              // Задание значения шага изменения угла поворота траектории НПЦ при правом развороте
		}
		else
			if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
				((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))))
			{
				dfi_m = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                         // Задание значения шага изменения угла поворота траектории НПЦ при левом развороте
			}

		double R = Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0));                             // Вычисление требуемого радиуса разворота при максимально допустимом крене
		double Dn = sqrt((xg2 - xgn) * (xg2 - xgn) + (yg2 - ygn) * (yg2 - ygn) + (zg2 - zgn) * (zg2 - zgn));           // Вычисление расстояния между 1 и 2 точками

		if ((2 * R >= Dn) && (abs(f2_m - kursnm1) > Vnm1 * dt / R))                                                    // Если диаметр разворота больше расстояния между 1 и 2 точками, и разность курса и угла визирования 2 точки из 1 точки в горизонтальной плоскости больше 30 градусов
		{
			if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
				((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 >= 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) < 0.0))))
			{
				dfi_m = 2 * Vnm1 * dt / Dn;                                                           // Задание значения шага изменения угла поворота траектории НПЦ при правом развороте
			}
			else
				if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
					((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))) ||
					((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_m - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_m - kursnm1 < 0.0))) ||
					((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_m - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_m - (kursnm1 - Pi) >= 0.0))))
				{
					dfi_m = -2 * Vnm1 * dt / Dn;                                                      // Задание значения шага изменения угла поворота траектории НПЦ при левом развороте
				}
		}
				
		//

		fn_m = f2_m;                                                                                  // Угол визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		init_4m = false;                                                                              // Запрет инициализации исходных значений параметров разрешена при полете с доворотом на точку визирования
	}

	//

	double Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));          // Расчет расстояния до точки в начальный момент времени

	// Движение на точку визирования //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	while (Dn > Vn * 2.0 * dt)                                 // До тех пор, пока дальность до точки больше Vn * 2 * dt
	{
		if (abs(fn_m - kursn) >= abs(dfi_m))
		{
			kursn = kursnm1 + dfi_m;                           // Расчет угла поворота траектории НПЦ в n-й момент времени
		}
		else
		{
			kursn = fn_m;                                      // Угол поворота траектории приравнивается к углу визирования
		}

		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		double Vxgn = Vn * sin(kursn);                         // Расчет проекции вектора скорости НПЦ на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(kursn);                         // Расчет проекции вектора скорости НПЦ на ось OgYg местной СК в n-й момент времени
		double Vzgn = 0.0;                                     // Расчет проекции вектора скорости НПЦ на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg НПЦ в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg НПЦ в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg НПЦ в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени
		
		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));     // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                     // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                       // Определение координаты x НПЦ в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                       // Определение координаты y НПЦ в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                       // Определение координаты z НПЦ в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));        // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                         // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                  // Определение широты НПЦ в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                 // Определение долготы НПЦ в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                  // Определение высоты НПЦ в n-й момент времени в геодезической СК

		if (hn != Hish_4m)                                                      // Если текущая высота не равна исходной высоте
		{
			hn = Hish_4m;                                                       // Текущая высота приравнивается к исходной высоте

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                 // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                            // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = pkn.getPosition().getX();                                      // Определение координаты x НПЦ в n-й момент времени в геоцентрической СК
			yn = pkn.getPosition().getY();                                      // Определение координаты y НПЦ в n-й момент времени в геоцентрической СК
			zn = pkn.getPosition().getZ();                                      // Определение координаты z НПЦ в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));  // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                   // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                 // Определение координаты xg НПЦ в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                 // Определение координаты yg НПЦ в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                 // Определение координаты zg НПЦ в местной СК в n-й момент времен
		}

		CPointLocal result2 = p2.toPointLocal(zentrnm1);                        // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg2 = result2.getPosition().getX();                              // Определение координаты xg 2-й точки в местной СК (во 2 точке)
		double yg2 = result2.getPosition().getY();                              // Определение координаты yg 2-й точки в местной СК (во 2 точке)
		double zg2 = result2.getPosition().getZ();                              // Определение координаты zg 2-й точки в местной СК (во 2 точке)

		Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));        // Расчет расстояния до точки в начальный момент времени

		fn_m = atan((xg2 - xgn) / (yg2 - ygn));                                 // Расчет угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени //

		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
		{
			fn_m = fn_m;
		}
		else
			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
			{
				fn_m = fn_m + Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
				{
					fn_m = fn_m + 2 * Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
					{
						fn_m = fn_m + Pi;
					}

		//

		// Определение углов пространственной ориентации НПЦ в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                  // Расчет проекции вектора скорости НПЦ на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                  // Расчет проекции вектора скорости НПЦ на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                            // Расчет проекции вектора скорости НПЦ на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);         // Запись в фильм n-й точки	
       
		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn;

		plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки	


		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		kursnm1 = kursn;
		tetanm1 = tetan;

		//
		
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения НПЦ равен номеру отсчета времени движения НПЦ в конце интервала моделирования траектории НПЦ (1 с)
		{
			return 0;                                                                           // Продолжение движения НПЦ
		}

	}
		
	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Вышел в точку №" + to_string(P_i + 1));                  // Запись в фильм комментария
			
	init_2m = true;                                                                      // Разрешение инициализации исходных значений параметров при развороте НПЦ в ходе полета от точки к точке
	init_3m = true;                                                                      // Разрешение инициализации исходных значений параметров при наборе заданной скорости (по ситуации)
	init_4m = true;                                                                      // Разрешение инициализации исходных значений параметров при движении НПЦ с доворотом на точку
		
	F_n = 0;                                                                             // Установление текущего отсчета положения НПЦ в 0	
	EndTime = F_LastTime;                                                                // Определение реального времени выхода в точку

	}
	
	init_0m = true;
	init_1m = true;                                                                      // Разрешение инициализации исходных значений параметров в начале движения по маршруту
	P_i = 1;                                                                             // Установление номера точки в 1
	return 1;
}
	



