#include "CFlightDynamicsBpLA.h"

CFlightDynamicsBpLA::CFlightDynamicsBpLA(MyBpLAStruct& p)
	: plane(p), F_LastTime(0)
{
}

CFlightDynamicsBpLA::~CFlightDynamicsBpLA()
{
}

//////////////////////////////////////////////////////////// Модель взлета БпЛА /////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Vzlet(double kursvzleta)
{
	
	int deltaF = (int)round((maxT - F_LastTime) / dt);                                            // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                                               // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	//

	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	kursvzleta = kursvzleta * Pi / 180.0;                                                       // Курс взлета БпЛА
	
	if (abs(kursvzleta) >= 2 * Pi)
	{
		kursvzleta = kursvzleta - 2 * Pi * floor(kursvzleta / (2 * Pi));
	}
	
	if (kursvzleta < 0)
	{
		kursvzleta = kursvzleta + 2 * Pi;
	}

	double Vstart = 0.0;                                                                          // Начальная скорость БпЛА
	double tetastart = 0.0;                                                                       // Начальный угол наклона траектории БпЛА
	double Vsv = plane.ttx_bpla.V_sv;                                                                  // Скорость сваливания БпЛА
	double tetavzleta = plane.ttx_bpla.teta_vz * Pi / 180.0;                                           // Угол взлета БпЛА
	double Hvzleta = plane.ttx_bpla.H_vz;                                                              // Безопасная высота взлета БпЛА
	double Votr = 1.1 * Vsv;                                                                      // Скорость отрыва БпЛА
	double Vvzleta = 1.1 * Votr;                                                                  // Скорость взлета БпЛА
	double Lrazb = plane.ttx_bpla.L_razb;                                                              // Дистанция разбега БпЛА
	double Trazb = 2 * Lrazb / Votr;                                                              // Интервал времени разбега БпЛА
	size_t Nrazb = (size_t)floor(Trazb / dt);                                                     // Количество отсчетов времени разбега БпЛА
	double Hrazb = 0.0;                                                                           // Высота разбега БпЛА
	double dVrazb = Votr / Nrazb;                                                                 // Шаг изменения скорости разбега БпЛА
	double Tvzleta = Hvzleta / (0.5 * (Vvzleta + Votr) * sin(0.5 * (tetastart + tetavzleta)));    // Интервал времени взлета БпЛА
	size_t Nvz = (size_t)ceil(Tvzleta / dt);                                                      // Количество отсчетов времени взлета БпЛА
	double dVvzleta = (Vvzleta - Votr) / Nvz;                                                     // Шаг изменения скорости взлета БпЛА
	double dtetavzleta = (tetavzleta - tetastart) / Nvz;                                          // Шаг изменения угла взлета БпЛА

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Построение траектории взлета БпЛА //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init == true)                                                                              // Если инициализация исходных значений параметров разрешена
	{
		const CPointGlobal& p1_o = plane.object.getPoint(0);                                       // Расчет координат БпЛА в геоцентрической СК в начальной точке
		const CPointGeo& p1g_o = plane.object.getPointGeo(0);                                      // Расчет координат БпЛА в геодезической СК в начальной точке

		double B1 = p1g_o.getLatitude();                                                           // Считываем широту в начальной точке в геодезической СК
		double L1 = p1g_o.getLongitude();                                                          // Считываем долготу в начальной точке в геодезической СК
		double h1 = p1g_o.getAltitude();                                                           // Считываем высоту в начальной точке в геодезической СК

		// Корректировка высоты назначаемой начальной точки 

		if (h1 != 0.0)                                                                              // Если высота расположения начальной точки (БпЛА, стоящего на аэродроме) задана некорректно (отлична от нуля)
		{
			h1 = 0.0;                                                                               // Высота начальной точки приравнивается нулю
		}

		//

		CPointGeo p1g = CPointGeo(p1_o.getTime(), B1, L1, h1);                                      // Создание точки p1g в геодезической СК со скорректированной высотой
		CPointGlobal p1 = p1g.toPointGlobal();                                                      // Перевод точки p1g в геоцентрическую СК

		double x1 = p1.getPosition().getX();                                                        // Определение координаты x БпЛА в геоцентрической СК в начальной точке
		double y1 = p1.getPosition().getY();                                                        // Определение координаты y БпЛА в геоцентрической СК в начальной точке
		double z1 = p1.getPosition().getZ();                                                        // Определение координаты z БпЛА в геоцентрической СК в начальной точке

		double Vx1 = Vstart;                                                                        // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в начальной точке
		double Vy1 = Vstart;                                                                        // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в начальной точке
		double Vz1 = Vstart;                                                                        // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в начальной точке

		double gam1 = 0.0;                                                                          // Угол скоростного крена БпЛА в начальной точке в градусах

		CPoint3D zentr1(x1, y1, z1);                                                                // Создание центра местной СК в начальной точке
		CPointLocal result1 = p1.toPointLocal(zentr1);                                              // Перевод точки p1 из геоцентрической СК в местную СК

		double xg1 = result1.getPosition().getX();                                                  // Определение координаты xg БпЛА в местной СК в начальной точке
		double yg1 = result1.getPosition().getY();                                                  // Определение координаты yg БпЛА в местной СК в начальной точке
		double zg1 = result1.getPosition().getZ();                                                  // Определение координаты zg БпЛА в местной СК в начальной точке

		double Vxg1 = Vstart;                                                                       // Определение проекции вектора скорости БпЛА на ось OgXg местной СК в начальной точке
		double Vyg1 = Vstart;                                                                       // Определение проекции вектора скорости БпЛА на ось OgYg местной СК в начальной точке
		double Vzg1 = Vstart;                                                                       // Определение проекции вектора скорости БпЛА на ось OgZg местной СК в начальной точке

		double Vxgn = Vxg1;                                                                         // Определение проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vyg1;                                                                         // Определение проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vzg1;                                                                         // Определение проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		double Vxnm1 = Vx1;                                                                         // Определение начального значения проекции вектора скорости БпЛА на ось OX геоцентрической СК в (n-1)-й момент времени
		double Vynm1 = Vy1;                                                                         // Определение начального значения проекции вектора скорости БпЛА на ось OY геоцентрической СК в (n-1)-й момент времени
		double Vznm1 = Vz1;                                                                         // Определение начального значения проекции вектора скорости БпЛА на ось OZ геоцентрической СК в (n-1)-й момент времени

		double Vxn = Vx1;                                                                           // Задание начального значения проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		double Vyn = Vy1;                                                                           // Задание начального значения проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		double Vzn = Vz1;                                                                           // Задание начального значения проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double xgnm1 = xg1;                                                                         // Задание начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
		double ygnm1 = yg1;                                                                         // Задание начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
		double zgnm1 = zg1;                                                                         // Задание начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

		double xgn = xgnm1;                                                                         // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
		double ygn = ygnm1;                                                                         // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
		double zgn = zgnm1;                                                                         // Задание начального значения координаты zg БпЛА в местной СК в n-й момент времени

		double xnm1 = x1;                                                                           // Задание начального значения координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
		double ynm1 = y1;                                                                           // Задание начального значения координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
		double znm1 = z1;                                                                           // Задание начального значения координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени

		double xn = xnm1;                                                                           // Задание начального значения координаты x БпЛА в геоцентрической СК в n-й момент времени
		double yn = ynm1;                                                                           // Задание начального значения координаты y БпЛА в геоцентрической СК в n-й момент времени
		double zn = znm1;                                                                           // Задание начального значения координаты z БпЛА в геоцентрической СК в n-й момент времени

		double hn = h1;                                                                             // Задание начального значения высоты БпЛА в n-й момент времени

		double Vnm1 = sqrt(Vx1 * Vx1 + Vy1 * Vy1 + Vz1 * Vz1);                                      // Определение скорости БпЛА в (n-1)-й момент времени
		double Vn = Vnm1;                                                                           // Задание начального значения скорости БпЛА в n-й момент времени

		double kursnm1 = kursvzleta;                                                                // Определение начального значения угла поворота траектории БпЛА при взлете в (n-1)-й момент времени
		double kursn = kursnm1;                                                                     // Задание начального значения угла поворота траектории БпЛА при взлете в n-й момент времени

		double tetanm1 = tetastart;                                                                 // Определение начального значения угла наклона траектории БпЛА при взлете в (n-1)-й момент времени
		double tetan = tetanm1;                                                                     // Задание начального значения угла наклона траектории БпЛА при взлете в n-й момент времени

		double gamn = 0.0;                                                                          // Задание уго аскоростного крена БпЛА в n-й момент времени

		double time = F_LastTime;                                                                   // Задание отсчетов времени (используется при выставлении курса БпЛА)

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Появление БпЛА на поле боя, выставление курса взлета БпЛА //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		Film.writeLog(plane.object.getObjNum(), plane.curPos.time, "Появился на поле боя");     // Запись в фильм комментария

		for (size_t m = 1; m < 2; m++)                                                          // Для двух шагов моделирования выставления курса БпЛА
		{
			Vn = Vnm1 + dVrazb;                                                                 // Расчет скорости БпЛА в n-й момент времени

			Vxgn = Vn * sin(kursvzleta);                                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			Vygn = Vn * cos(kursvzleta);                                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			Vzgn = Vzg1;                                                                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                            // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                            // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1;                                                                        // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			time = p1.getTime() + m * dt;                                                       // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(time, CPoint3D(xgn, ygn, zgn));                      // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentr1);                                  // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vx1 = 0.00001 * cos(cn) * sin(rn);                                                      // Расчет проекции вектора скорости БпЛА на ось OX в начальной точке
			Vy1 = 0.00001 * cos(cn) * cos(rn);                                                      // Расчет проекции вектора скорости БпЛА на ось OY в начальной точке
			Vz1 = 0.00001 * sin(cn);                                                                // Расчет проекции вектора скорости БпЛА на ось OZ в начальной точке
		}

		Film.writePoint(plane.object.getObjNum(), p1.getTime(), x1, y1, z1, Vx1, Vy1, Vz1, gam1);   // Запись в фильм начальной точки 

		Film.writeLog(plane.object.getObjNum(), p1.getTime() + dt, "Начал разбег");                 // Запись в фильм комментария

		// Запись параметров движения БпЛА в начальный (нулевой) момент времени

		plane.curPos.time = p1.getTime();
		plane.curPos.x = x1;
		plane.curPos.y = y1;
		plane.curPos.z = z1;
		plane.curPos.vx = Vx1;
		plane.curPos.vy = Vy1;
		plane.curPos.vz = Vz1;
		plane.curPos.fi = kursvzleta;
		plane.curPos.teta = tetastart;
		plane.curPos.gamma = gam1 * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                                  // Запись начальной точки в вектор

		//

		init = false;                                                                              // ПризнБпЛА запрета инициализации исходных значений параметров
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                                                  // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                                                  // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                                                  // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                                                // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                                                // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                                                // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                                              // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                                            // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                                            // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                                           // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                                           // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                                                 // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                                                 // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                                                 // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);                             // Определение скорости БпЛА в (n-1)-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                                             // Определение начального значения широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                                            // Определение начального значения  долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                                             // Определение начального значения  высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double xn = xnm1;                                                                              // Задание начального значения координаты x БпЛА в геоцентрической СК в n-й момент времени
	double yn = ynm1;                                                                              // Задание начального значения координаты y БпЛА в геоцентрической СК в n-й момент времени
	double zn = znm1;                                                                              // Задание начального значения координаты z БпЛА в геоцентрической СК в n-й момент времени

	double xgn = xgnm1;                                                                            // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
	double ygn = ygnm1;                                                                            // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
	double zgn = zgnm1;                                                                            // Задание начального значения координаты zg БпЛА в местной СК в n-й момент времени

	double Bn = Bnm1;                                                                              // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                                              // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                                              // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vn = Vnm1;                                                                              // Задание начального значения скорости БпЛА в n-й момент времени	

	double kursn = kursnm1;                                                                        // Задание начального значения угла поворота траектории БпЛА при наборе высоты в n-й момент времени
	double tetan = tetanm1;                                                                        // Задание начального значения угла наклона траектории БпЛА при наборе высоты в n-й момент времени

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Разбег БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((cur_F_n > Nrazb) && (F_n < Nrazb))                                                   // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разбега БпЛА, а текущий отсчет времени положения БпЛА меньше количества отсчетов времени разбега БпЛА
	{
		cur_F_n = Nrazb;                                                                      // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени разбега БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)                                                           // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)
	{
		if (cur_F_n > Nrazb)                                                                  // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разбега БпЛА
		{
			break;                                                                            // Стоп
		}

		Vn = Vnm1 + dVrazb;                                                                   // Расчет скорости БпЛА в n-й момент времени

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                           // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                           // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                              // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                              // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                              // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                         // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                   // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                   // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                   // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                    // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                     // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                              // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                             // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                              // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Стабилизация заданной высоты разбега БпЛА и пересчет параметров движения БпЛА //

		if (hn != 0.0)                                                                      // Если текущая высота не равна исходной высоте
		{
			hn = 0.0;                                                                       // Текущая высота приравнивается к исходной высоте

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}
				
		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                             // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                             // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                       // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                      // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman); // Запись в фильм n-й точки  
        
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                             // Запись в вектор n-й точки 
				
		//

	}

	if (cur_F_n == Nrazb)                                                                     // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен количеству отсчетов времени разбега БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Отрыв");                         // Запись в фильм комментария
	}

	if (F_n < Nrazb)                                                                          // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разбега БпЛА
	{
		return 0;                                                                             // Продолжение взлета
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Взлет БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	cur_F_n = F_n + deltaF;                                                                // Номер отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (cur_F_n > (Nrazb + Nvz))                                                           // Если номер отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени разбега БпЛА и отсчетов времени взлета БпЛА
	{
		cur_F_n = Nrazb + Nvz;                                                             // Номер отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным суммарному количеству отсчетов времени разбега БпЛА и отсчетов времени взлета БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)                                                        // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с)
	{

		Vn = Vnm1 + dVvzleta;                                                              // Расчет скорости БпЛА в n-й момент времени
		tetan = tetanm1 + dtetavzleta;                                                     // Расчет угла наклона траектории БпЛА в n-й момент времени

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                     // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                           // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                           // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                           // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                      // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));               // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                               // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                 // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                 // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                 // Определение координаты z точки в n-й момент времени в геоцентрической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                             // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                             // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                       // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                      // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman); // Запись в фильм n-й точки 

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		//

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки 
				
		//

	}

	if (cur_F_n == (Nrazb + Nvz))                                                               // Если номер отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен суммарному количеству отсчетов времени разбега БпЛА и отсчетов времени взлета БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Взлет");                           // Запись в фильм комментария
		init = true;                                                                            // ПризнБпЛА разрешения инициализации исходных значений параметров
		F_n = 0;                                                                                // Установление текущего отсчета положения БпЛА в 0

		return 1;                                                                               // Окончание взлета БпЛА 
	}

	return 0;                                                                                   // Продолжение взлета БпЛА

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////// Модель набора высоты БпЛА ////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Nabor_vysoty(double Hpolnab, double tetanab, double Vpolnab)                  
{
	
	// Задание начальных значений параметров //
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                                             // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                                                 // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	tetanab = tetanab * Pi / 180.0;                                                                // Преобразование угла наклона траектории в радианы

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                                                  // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                                                  // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                                                  // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                                                // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                                                // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                                                // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                                              // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                                            // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                                            // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                                           // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                                           // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                                                 // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                                                 // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                                                 // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);                             // Определение скорости БпЛА в (n-1)-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                                             // Определение начального значения широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                                            // Определение начального значения  долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                                             // Определение начального значения  высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double xn = xnm1;                                                                              // Задание начального значения координаты x БпЛА в геоцентрической СК в n-й момент времени
	double yn = ynm1;                                                                              // Задание начального значения координаты y БпЛА в геоцентрической СК в n-й момент времени
	double zn = znm1;                                                                              // Задание начального значения координаты z БпЛА в геоцентрической СК в n-й момент времени

	double xgn = xgnm1;                                                                            // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
	double ygn = ygnm1;                                                                            // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
	double zgn = zgnm1;                                                                            // Задание начального значения координаты zg БпЛА в местной СК в n-й момент времени

	double Bn = Bnm1;                                                                              // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                                              // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                                              // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vn = Vnm1;                                                                              // Задание начального значения скорости БпЛА в n-й момент времени	

	double kursn = kursnm1;                                                                        // Задание начального значения угла поворота траектории БпЛА при наборе высоты в n-й момент времени
	double tetan = tetanm1;                                                                        // Задание начального значения угла наклона траектории БпЛА при наборе высоты в n-й момент времени

	//

	double Vkr = plane.ttx_bpla.V_sv;                                                                   // Критическая скорость БпЛА
	double Vmax = plane.ttx_bpla.V_max;                                                                 // Максимально допустимая скорость БпЛА
	double tetakr = 80.0 * Pi / 180.0;                                                             // Максимально допустимый угол набора высоты БпЛА
		
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Набор среднего значения текущей и заданной высот БпЛА //
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_1 == true)                                                                          // Если инициализация исходных значений параметров разрешена при наборе среднего значения текущей и заданной высот
	{
		Vish_1 = Vn;                                                                             // Задание исходной скорости БпЛА в начале набора половины суммы текущей и заданной высоты
		tetaish_1 = tetan;                                                                       // Задание исходного угла наклона траектории БпЛА в начале набора половины суммы текущей и заданной высоты
		Hish_1 = hnm1;                                                                           // Задание исходного значения высоты БпЛА в начале набора половины суммы текущей и заданной высоты
				
		init_1 = false;                                                                          // Запрет инициализации исходных значений параметров при наборе среднего значения текущей и заданной высот
	}
			
	double Tnab = (0.5 * (Hish_1 + Hpolnab) - Hish_1) / (0.5 * (Vish_1 + Vish_1 * 0.95) * sin(0.5 * (tetanab + tetaish_1)));       // Расчет интервала времени набора БпЛА среднего значения текущей и заданной высот
	double Nnab = ceil(Tnab / dt);                                                              // Расчет количества отсчетов времени набора БпЛА среднего значения текущей и заданной высот               
	double dV = (Vish_1 * 0.95 - Vish_1) / Nnab;                                                // Расчет шага изменения скорости полета БпЛА до набора среднего значения текущей и заданной высот
	double dteta = (tetanab - tetaish_1) / Nnab;                                                // Расчет шага изменения угла наклона траектории БпЛА при наборе высоты до среднего значения текущей и заданной высот

	while (hn < (Hish_1 + Hpolnab) / 2)                                                         // До тех пор, пока рассчитываемая высота меньше среднего значения текущей и заданной высот БпЛА
	{
		if (init_2 == false || init_3 == false)                                                 // Если уже рассчитываются последующие этапы полета 
		{
			break;                                                                              // Стоп
		}

		if (Vn > Vish_1 * 0.95)                                                                 // Если скорость набора высоты в n-й момент времени больше 0,95 скорости в начале набора высоты БпЛА
		{
			Vn = Vnm1 + dV;                                                                     // Расчет скорости БпЛА в n-й момент времени
		}

		if (Vn <= Vish_1 * 0.95)                                                                // Если скорость набора высоты в n-й момент времени меньше или равна 0,95 скорости в начале набора высоты БпЛА
		{
			Vn = Vish_1 * 0.95;                                                                 // Скорость БпЛА в n-й момент времени приравнивается к 0,95 скорости в начале набора высоты БпЛА
		}

		if (tetan < tetanab)                                                                    // Если угол наклона траектории БпЛА в n-й момент времени меньше угла наклона траектории БпЛА в n-й момент времени
		{
			tetan = tetanm1 + dteta;                                                            // Расчет угла наклона траектории при наборе высоты БпЛА в n-й момент времени
		}

		if (tetan >= tetanab)                                                                   // Если угол наклона траектории БпЛА в n-й момент времени больше или равен углу наклона траектории БпЛА в n-й момент времени
		{
			tetan = tetanab;                                                                    // Угол наклона траектории при наборе высоты БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при наборе высоты
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                          // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                                // Расчет координаты xg БпЛА в МСК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                                // Расчет координаты yg БпЛА в МСК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                                // Расчет координаты zg БпЛА в МСК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                           // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК
				
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                                        // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                                        // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                                  // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                                 // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);            // Запись в фильм n-й точки  

		// Обновление параметров //

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение набора высоты
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Набор заданной высоты БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_2 == true)                                                                                    // Если инициализация исходных значений параметров разрешена при наборе заданной высоты
	{
		Vish_2 = Vn;                                                                                       // Задание исходной скорости БпЛА в начале набора заданной высоты
		tetaish_2 = tetan;                                                                                 // Задание исходного угла наклона траектории БпЛА в начале набора заданной высоты
		Hish_2 = hn;                                                                                       // Задание исходного значения высоты БпЛА в начале набора заданной высоты
		init_2 = false;                                                                                    // Запрет инициализации исходных значений параметров при наборе заданной высоты
	}

	Tnab = (Hpolnab - Hish_2) / (0.5 * (Vish_2 + 0.9 * Vish_1) * sin(0.5 * (tetaish_2)));                  // Расчет интервала времени набора БпЛА заданной высоты
	Nnab = ceil(Tnab / dt);                                                                                // Расчет количества отсчетов времени набора БпЛА заданной высоты
	dV = (0.9 * Vish_1 - Vish_2) / Nnab;                                                                   // Расчет шага изменения скорости полета БпЛА до набора заданной высоты
	dteta = tetaish_2 / Nnab;                                                                              // Расчет шага изменения угла наклона траектории при наборе заданной высоты БпЛА

	while (hn < Hpolnab)                                                                                   // До тех пор, пока рассчитываемая высота меньше заданной высоты 
	{
		if (init_3 == false)                                                                               // Если уже рассчитывается последующий этап полета 
		{
			break;                                                                                         // Стоп
		}

		if (Vn > 0.9 * Vish_1)                                                                             // Если скорость набора высоты в n-й момент времени больше 0,9 скорости в начале набора высоты БпЛА
		{
			Vn = Vnm1 + dV;                                                                                // Расчет скорости БпЛА в n-й момент времени
		}

		if (Vn <= 0.9 * Vish_1)                                                                            // Если скорость набора высоты в n-й момент времени меньше или равна 0,9 скорости в начале набора высоты БпЛА
		{
			Vn = 0.9 * Vish_1;                                                                             // Скорость БпЛА в n-й момент времени приравнивается к 0,9 заданной скорости после набора высоты
		}

		if (tetan > (0.5 / dt) * dteta)                                                                             // Если угол наклона траектории БпЛА в n-й момент времени больше 5 шагов изменения угла наклона траектории при наборе заданной высоты БпЛА
		{
			tetan = tetanm1 - dteta;                                                                       // Расчет угла набора высоты БпЛА в n-й момент времени
		}

		if (tetan <= (0.5 / dt) * dteta)                                                                            // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен 5 шагам изменения угла наклона траектории при наборе заданной высоты БпЛА
		{
			tetan = (0.5 / dt) * dteta;                                                                             // Угол набора высоты БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла наклона траектории при наборе заданной высоты БпЛА
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                                     // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                                           // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                                           // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                                           // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                                      // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК
				
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                                      // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                                      // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                                // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                               // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);          // Запись в фильм n-й точки 

		// Обновление параметров //

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение набора высоты
		}
	}

	if (PrWL == true)                                                                          // Если запись в фильм сообщения разрешена
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Набрал заданную высоту");         // Запись в фильм комментария
		PrWL = false;                                                                          // Запрет записи в фильм сообщения
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Горизонтирование БпЛА и набор заданной скорости //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_3 == true)                                                                       // Если инициализация исходных значений параметров разрешена при наборе заданной скорости
	{
		Vish_3 = Vn;                                                                          // Задание исходной скорости БпЛА в начале набора заданной скорости
		tetaish_3 = tetan;                                                                    // Задание исходного угла наклона траектории БпЛА в начале набора заданной скорости
		init_3 = false;                                                                       // Запрет инициализации исходных значений параметров в начале набора заданной скорости
	}
	   
	if (abs(Vpolnab - Vish_3) <= 1.0)                                                         // Если модуль разности заданной и исходной скорости меньше или равен 1 м/с
	{
		dV = (Vpolnab - Vish_3) / (0.1 / dt);                                                        // Расчет шага изменения скорости полета БпЛА на заданной высоте
	}
	else                                                                                      // В противном случае
		if (abs(Vpolnab - Vish_3) > 1.0 && abs(Vpolnab - Vish_3) <= 25.0)                     // Если модуль разности заданной и исходной скорости меньше или равен 25 м/с
		{
			dV = (Vpolnab - Vish_3) / (2.0 / dt);                                                   // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 20 тактов (2 с)
		}
	else                                                                                      // В противном случае
		if ((abs(Vpolnab - Vish_3) > 25.0) && (abs(Vpolnab - Vish_3) <= 100.0))               // Если модуль разности заданной и исходной при горизонтировании скорости больше 25 м/с и меньше или равен 100 м/с
		{
			dV = (Vpolnab - Vish_3) / (5.0 / dt);                                                   // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 50 тактов (5 с)
		}
		else                                                                                  // В противном случае
			if ((abs(Vpolnab - Vish_3) > 100.0) && (abs(Vpolnab - Vish_3) <= 200.0))          // Если модуль разности заданной и исходной при горизонтировании скорости больше 100 м/с и меньше или равен 200 м/с
			{
				dV = (Vpolnab - Vish_3) / (10.0 / dt);                                              // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 100 тактов (10 с)
			}
			else                                                                              // В противном случае
				if (abs(Vpolnab - Vish_3) > 200.0)                                            // Если модуль разности заданной и исходной при горизонтировании скорости больше 200 м/с
				{
					dV = (Vpolnab - Vish_3) / (20.0 / dt);                                          // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 200 тактов (20 с)
				}

	dteta = tetaish_3 / (0.3 / dt);                                                                  // Шаг изменения угла наклона траектории БпЛА при наборе заданной скорости

	while ((Vn != Vpolnab) || (tetan != 0.0))                                                 // До тех пор, пока текущая скорость БпЛА не равна заданой или текущий угол наклона траектории не равен нулю
	{
		if (abs(Vn - Vpolnab) > abs(dV))                                                      // Если модуль разности текущей скорости и заданной скорости после набора высоты больше модуля шага изменения скорости
		{
			Vn = Vnm1 + dV;                                                                   // Расчет скорости БпЛА в n-й момент времени
		}

		if (abs(Vn - Vpolnab) <= abs(dV))                                                     // Если модуль разности текущей скорости и заданной скорости после набора высоты меньше или равен модулю шага изменения скорости
		{
			Vn = Vpolnab;                                                                     // Текущая скорость БпЛА приравнивается к заданной скорости
		}

		if (tetan > 0.0)                                                                      // Если угол наклона траектории БпЛА в n-й момент времени больше нуля
		{
			tetan = tetanm1 - dteta;                                                          // Расчет угла наклона траектории БпЛА в n-й момент времени
		}

		if (tetan <= 0)                                                                       // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен нулю
		{
			tetan = 0.0;                                                                      // Угол наклона траектории БпЛА в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                           // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                           // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                              // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                              // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                              // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                         // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                   // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                   // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                   // Определение координаты z точки в n-й момент времени в геоцентрической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
        
		// Обновление параметров //

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись  в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования и набора заданной скорости в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение горизонтирования и набора заданной скорости
		}
	}

	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Набрал заданную скорость");           // Запись в фильм комментария

	PrWL = true;                                                                               // Разрешение записи в фильм сообщения 
	init_1 = true;                                                                             // Разрешение инициализации исходных значений параметров при наборе БпЛА половины суммы текущей и заданной высоты
	init_2 = true;                                                                             // Разрешение инициализации исходных значений параметров при наборе БпЛА заданной высоты
	init_3 = true;                                                                             // Разрешение инициализации исходных значений параметров при наборе БпЛА заданной скорости
	
	F_n = 0;                                                                                   // Установление текущего отсчета положения БпЛА в 0

	return 1;                                                                                  // Окончание набора высоты БпЛА

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////// Модель прямолинейного полета БпЛА //////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Pryam_polet(double Vpol, double Tpol)                                              
{
	
	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                                   // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                                        // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	size_t  Nprpol = (size_t) (Tpol/dt);                                                  // Количество отсчетов времени при прямолинейном полете БпЛА на заданной высоте

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                                         // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                                         // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                                         // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                                       // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                                       // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                                       // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                                     // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                                   // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                                   // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));             // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                                  // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                                  // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                                        // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                                        // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                                        // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double xgn = xgnm1;                                                                   // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
	double ygn = ygnm1;                                                                   // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
	double zgn = zgnm1;                                                                   // Задание начального значения координаты zg БпЛА в местной СК в n-й момент времени

	double xn = xnm1;                                                                     // Задание начального значения координаты x БпЛА в геоцентрической СК в n-й момент времени
	double yn = ynm1;                                                                     // Задание начального значения координаты y БпЛА в геоцентрической СК в n-й момент времени
	double zn = znm1;                                                                     // Задание начального значения координаты z БпЛА в геоцентрической СК в n-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                                  // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                                    // Определение начального значения широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                                   // Определение начального значения долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                                    // Определение начального значения высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double Bn = Bnm1;                                                                     // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                                     // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                                     // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);                    // Определение начального значения скорости БпЛА в (n-1)-й момент времени
	double Vn = Vnm1;                                                                     // Задание начального значения скорости БпЛА в n-й момент времени

	double kursn = kursnm1;                                                               // Задание начального значения угла поворота траектории БпЛА в n-й момент времени
	double tetan = tetanm1;                                                               // Задание начального значения угла наклона траектории БпЛА в n-й момент времени

	//

	double Vkr = 67.0;                                                                    // Критическая скорость
	double Vmax = plane.ttx_bpla.V_max;                                                        // Максимально допустимая скорость

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Прямолинейный полет БпЛА на заданной высоте //
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_4 == true)                                                                   // Если инициализация исходных значений параметров разрешена при прямолинейном полете
	{ 
		Vish_4 = Vn;                                                                      // Задание исходной скорости БпЛА в начале прямолинейного полета
		tetaish_4 = 0.0;                                                                  // Задание исходного угла наклона траектории БпЛА в начале прямолинейного полета
		Hish_4 = hn;                                                                      // Задание исходного значения высоты БпЛА в начале прямолинейного полета
		init_4 = false;                                                                   // Запрет инициализации исходных значений параметров при прямолинейном полете

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал прямолинейный полет на заданной высоте с постоянной скоростью");    // Запись в фильм комментария
	}
		
	double dV = (Vpol - Vish_4) / Nprpol;                                            // Расчет шага изменения скорости БпЛА при прямолинейном полете
	
	if (cur_F_n > Nprpol)                                                            // Если номер отсчета времени прямолинейного полета БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени прямолинейного полета БпЛА
	{
		cur_F_n = Nprpol;                                                            // Номер отсчета времени прямолинейного полета БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени прямолинейного полета БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)                                                  // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени прямолинейного полета БпЛА в конце интервала моделирования траектории БпЛА(1 с)
	{
		Vn = Vnm1 + dV;		                     	                                 // Расчет скорости БпЛА в n-й момент времени

		if (tetan != tetaish_4)                                                      // Если текущий угол наклона траектории БпЛА не равен исходному углу наклона траектории БпЛА в начале прямолинейного полета
		{
			tetan = tetaish_4;                                                       // Текущий угол наклона траектории БпЛА приравнивается к исходному углу наклона траектории БпЛА в начале прямолинейного полета
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                   // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                   // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                      // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                      // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                      // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                 // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));          // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                          // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                            // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                            // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                            // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));             // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                              // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                       // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                      // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Стабилизация заданной высоты полета БпЛА //

		if (hn != Hish_4)                                                             // Если текущая высота не равна исходной высоте
		{
			hn = Hish_4;                                                              // Текущая высота приравнивается к исходной высоте

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                       // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                  // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = pkn.getPosition().getX();                                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = pkn.getPosition().getY();                                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = pkn.getPosition().getZ();                                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));        // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                         // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                       // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                       // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                       // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		// Определение углов пространственной ориентации БпЛА в ГСК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                          // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                         // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);      // Запись n-й точки в фильм

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                             // Запись n-й точки в вектор
						
	}

	if (cur_F_n == Nprpol)                                                                    // Если номер отсчета времени прямолинейного полета БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен количеству отсчтетов времени прямолинейного полета БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Завершил прямолинейный полет");       // Запись в фильм комментария
	}

	if (F_n < Nprpol)                                                                         // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени прямолинейного полета БпЛА
	{
		return 0;                                                                             // Продолжение прямолинейного полета
	}

	init_4 = true;                                                                            // Разрешение инициализации исходных значений параметров при прямолинейном полете БпЛА
	
	F_n = 0;                                                                                  // Установление текущего отсчета положения БпЛА в 0

	return 1;                                                                                 // Окончание прямолинейного полета БпЛА
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////// Модель разворота БпЛА //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Razvorot(double ugolraz, double Hpolraz, double Vpolraz)               
{
	
	// Задание начальных значений параметров //
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                  // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                       // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                        // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                        // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                        // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                      // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                      // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                      // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                    // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                  // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                  // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах

	//

	ugolraz = ugolraz * Pi / 180.0;                                    // Перевод значения угла разворота в радианы

	//

	// Приведение ugolraz к интервалу от 0 до 2 пи

	if (abs(ugolraz) >= 2 * Pi)
	{
		ugolraz = ugolraz - 2 * Pi * floor(ugolraz / (2 * Pi));
	}
		
	//
	   
	// Приведение kursnm1 к интервалу от 0 до 2 пи

	if (kursnm1 >= 2 * Pi)
	{
		kursnm1 = kursnm1 - 2 * Pi;
	}

	if (kursnm1 < 0)
	{
		kursnm1 = kursnm1 + 2 * Pi;
	}

	//

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                  // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                  // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                        // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                        // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                        // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double xgn = xgnm1;                                                   // Задание начального значения координаты xg БпЛА в местной СК в в n-й момент времени
	double ygn = ygnm1;                                                   // Задание начального значения координаты yg БпЛА в местной СК в в n-й момент времени
	double zgn = zgnm1;                                                   // Задание начального значения координаты zg БпЛА в местной СК в в n - й момент времени

	double xn = xnm1;                                                     // Задание начального значения координаты x БпЛА в геоцентрической СК в в n-й момент времени
	double yn = ynm1;                                                     // Задание начального значения координаты y БпЛА в геоцентрической СК в в n-й момент времени
	double zn = znm1;                                                     // Задание начального значения координаты z БпЛА в геоцентрической СК в в n-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                  // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                    // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                   // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                    // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double Bn = Bnm1;                                                     // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                     // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                     // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);    // Расчет скорости БпЛА в (n-1)-й момент времени
	double Vn = Vnm1;                                                     // Задание начального значения скорости БпЛА в n-й момент времени

	double kursn = kursnm1;                                               // Задание начального значения угла поворота траектории БпЛА при развороте в n-й момент времени
	double tetan = tetanm1;                                               // Задание начального значения угла наклона траектории БпЛА при развороте в n-й момент времени
	double gamn = gamnm1;                                                 // Задание начального значения угла скоростного крена БпЛА при развороте в n-й момент времени

	//

	double krenmax = plane.ttx_bpla.kren_max;                                  // Максимально допустимый угол крена БпЛА
	double Vmax = plane.ttx_bpla.V_max;                                        // Максимально допустимая скорость
	double Hbez = plane.ttx_bpla.H_bez;                                        // Безопасная высота
	double Vkr = 67.0;                                                    // Критическая скорость

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Разворот БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_5 == true)                                                   // Если инициализация исходных значений параметров разрешена при развороте
	{
		tetaish_5 = tetan;
		Vish_5 = Vn;
		Hish_5 = hn;
		
		// Задание значения шага изменения угла поворота траектории БпЛА //
		
		if (ugolraz > 0.0)
		{
			dkurs_5 = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                           // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
		}
		else
		{
			dkurs_5 = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                          // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
		}

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал выполнение разворота");                   // Запись в фильм комментария
		
		init_5 = false;
	}

	
	size_t Nraz = (size_t)floor(ugolraz / dkurs_5);                                                                  // Расчет количества отсчетов времени разворота БпЛА
	double Traz = Nraz * dt;                                                                                         // Расчет интервала времени разворота БпЛА
	double tetaraz = 2 * asin(2 * (Hpolraz - Hish_5) / (Traz * (Vish_5 + Vish_5))) - tetaish_5;                      // Расчет угла наклона траектории БпЛА после разворота
	double dteta = (tetaraz - tetaish_5) / Nraz;                                                                     // Расчет шага изменения угла наклона траектории БпЛА после разворота

	double nraz = ugolraz / dkurs_5 - (double)Nraz;                                                                  // Расчет остатка времени от округления при расчете количества отсчетов времени разворота
	double dobk = nraz * dkurs_5;                                                                                    // Расчет изменения угла поворота траектории за остаток времени
	
	if ((cur_F_n > Nraz) && (F_n < Nraz))                                                   // Если номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разворота БпЛА, а текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		cur_F_n = Nraz;                                                                     // Номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени разворота БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)                                                         // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
	{
		if (cur_F_n > Nraz)                                                                 // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разбега БпЛА
		{
			break;                                                                          // Стоп
		}
		
		if (F_n == (Nraz - 1))                                                              // Если текущий отсчет времени равен (Nraz - 1)
		{
			dkurs_5 = dkurs_5 + dobk;                                                       // Расчет шага изменения угла поворота траектории БпЛА при развороте в (Nraz - 1)-й момент времени (с учетом добавки)
		}

		kursn = kursnm1 + dkurs_5;                                                          // Расчет значения угла поворота траектории БпЛА при развороте в n-й момент времени
		
		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		tetan = tetanm1 + dteta;                                                            // Расчет значения угла наклона траектории БпЛА при развороте в n-й момент времени

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                         // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                         // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                      // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                            // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                            // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                            // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		gamn = atan(dkurs_5 * Vn * cos(tetan) / (dteta * Vn + dt * Settings.getEarthGravity() * cos(tetan))); // Расчет угла скоростного крена БпЛА при развороте в n-й момент времени в радианах

		F_LastTime = F_LastTime + dt;                                                       // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn < Hbez)                                                                      // Если высота БпЛА в n-й момент времени меньше миимально допустимой высоты
		{
			hn = Hbez;                                                                      // Текущая высота БпЛА приравнивается к безопасной высоте

			CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                               // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                               // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                         // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Обновление параметров с интервалом 0,1 с

		kursnm1 = kursn;
		tetanm1 = tetan;

		//

		// Определение значения скоростного крена БпЛА в n-й момент времени

		double gamn0 = 0.0;

		if ((F_n >= 0) && (F_n < 2 / dt))
		{
			double gamnmax = gamn * 180.0 / Pi;
			double dgam = gamnmax / (2 / dt);
			double gamman = gamn0 + F_n * dgam;

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);           // Запись в фильм n-й точки

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки
		}
		else
			if ((F_n >= 2 / dt) && (F_n <= Nraz - (2 / dt)))
			{
				double gamman = gamn * 180.0 / Pi;

				Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);    // Запись в фильм n-й точки
                
				// Запись параметров движения БпЛА

				plane.curPos.time = F_LastTime;
				plane.curPos.x = xn;
				plane.curPos.y = yn;
				plane.curPos.z = zn;
				plane.curPos.vx = Vxn;
				plane.curPos.vy = Vyn;
				plane.curPos.vz = Vzn;
				plane.curPos.fi = kursn;
				plane.curPos.teta = tetan;
				plane.curPos.gamma = gamman * Pi / 180.0;

				plane.Trajectory.push_back(plane.curPos);                                                    // Запись в вектор n-й точки
			}
			else
				if ((F_n > Nraz - (2 / dt)) && (F_n <= Nraz))
				{
					double gamnmax = gamn * 180.0 / Pi;
					double dgam = gamnmax / (2 / dt);
					double gamman = gamnmax - (F_n - (Nraz - (2 / dt))) * dgam;

					Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки
                   
					// Запись параметров движения БпЛА

					plane.curPos.time = F_LastTime;
					plane.curPos.x = xn;
					plane.curPos.y = yn;
					plane.curPos.z = zn;
					plane.curPos.vx = Vxn;
					plane.curPos.vy = Vyn;
					plane.curPos.vz = Vzn;
					plane.curPos.fi = kursn;
					plane.curPos.teta = tetan;
					plane.curPos.gamma = gamman * Pi / 180.0;

					plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки
				}

		//

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		//
				
	}

	if (F_n < Nraz)                                                                                       // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		return 0;                                                                                         // Продолжение разворота
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Горизонтирование БпЛА после разворота //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	cur_F_n = F_n + deltaF;                                    // Номер отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (init_6 == true)                                        // Если инициализация исходных значений параметров разрешена при горизонтировании после разворота
	{
		Vish_6 = Vn;                                           // Задание исходной скорости БпЛА в начале горизонтирования после разворота
		tetaish_6 = tetan;                                     // Задание исходного угла наклона траектории БпЛА в начале горизонтирования после разворота
		init_6 = false;                                        // Запрет инициализации исходных значений параметров в начале горизонтирования после разворота
	}

	dteta = tetaish_6 / (2.0 / dt);                                  // Расчет шага изменения угла наклона траектори БпЛА при горизонтировании

	while (tetan != 0.0)                                       // До тех пор, пока угол наклона траектории БпЛА в n-й момент времени не равен нулю
	{
		if (init_7 == false || init_9 == false || init_11 == false)                // Если уже рассчитываются последующие этапы полета
		{
			break;                                             // Стоп
		}

		if (abs(tetan) > abs(dteta))                           // Если модуль угла наклона траектории БпЛА больше модуля шага изменения угла наклона траектории БпЛА при горизонтировании
		{
			tetan = tetanm1 - dteta;                           // Расчет значения угла наклона траектории БпЛА при горизонтировании после разворота в n-й момент времени
		}

		if (abs(tetan) <= abs(dteta))                          // Если модуль угла наклона траектории БпЛА меньше или равен модулю шага изменения угла наклона траектории БпЛА при горизонтировании
		{
			tetan = 0.0;                                       // Угол наклона траектории БпЛА при горизонтировании после разворота в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX ГСК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY ГСК в n-й момент времени
		Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ ГСК в n-й момент времени

		double gamman = 0.0;                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись n-й точки в фильм
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение горизонтирования и набора заданной скорости после разворота
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Достижение заданной высоты БпЛА после разворота//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Снижение //

	if ((hn > Hpolraz) && (abs(hn - Hpolraz) > 3.0) && (init_9 == true))                               // Если высота БпЛА в n-й момент времени больше заданной высоты БпЛА после разворота, и разница между высотами больше 1 м
	{
		if (init_7 == true)                                                                            // Если инициализация исходных значений параметров разрешена при снижении до среднего значения текущей и заданной высот после разворота
		{
			Vish_7 = Vn;                                                                               // Задание исходной скорости БпЛА в начале снижения до среднего значения текущей и заданной высот после разворота
			Hish_7 = hn;                                                                               // Задание исходной высоты БпЛА в начале снижения до среднего значения текущей и заданной высот после разворота
			tetaish_7 = tetan;                                                                         // Задание исходного угла наклона траектории БпЛА в начале снижения до среднего значения текущей и заданной высот после разворота
			init_7 = false;                                                                            // Запрет инициализации исходных значений параметров в начале снижения до среднего значения текущей и заданной высот после разворота
		}

		double tetasn = -4.0 * Pi / 180.0;                                                             // Задание угла наклона траектории БпЛА при снижении до среднего значения текущей и заданной высот после разворота
		double Tsn = (0.5 * (Hpolraz + Hish_7) - Hish_7) / (Vish_7 * sin(0.5 * (tetasn + tetaish_7))); // Расчет интервала времени снижения БпЛА до среднего значения текущей и заданной высот после разворота
		double Nsn = ceil(Tsn / dt);                                                                   // Расчет количества отсчетов времени снижения БпЛА до среднего значения текущей и заданной высот после разворота               
		double dteta = (tetasn - tetaish_7) / Nsn;                                                     // Расчет шага изменения угла наклона траектории БпЛА при снижении до среднего значения текущей и заданной высот после разворота

		while (hn > (Hpolraz + Hish_7) / 2)                                                            // До тех пор, пока рассчитываемая высота больше среднего значения текущей и заданной высот БпЛА
		{
			if (tetan > tetasn)                                                                        // Если угол наклона траектории БпЛА в n-й момент времени больше заданного угла наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetanm1 + dteta;                                                               // Расчет угла наклона траектории БпЛА в n-й момент времени
			}

			if (tetan <= tetasn)                                                                       // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен заданному углу наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetasn;                                                                        // Угол наклона траектории БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при снижении БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                                // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                                // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                             // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                              // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                       // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                       // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                         // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                         // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                         // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                          // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                    // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                            // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                            // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                      // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                     // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись n-й точки в фильм
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
			
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение снижения высоты
			}
		}

		//

		if (init_8 == true)                                                                         // Если инициализация исходных значений параметров разрешена при снижении до заданной высоты после разворота
		{
			Vish_8 = Vn;                                                                            // Задание исходной скорости БпЛА в начале снижения до заданной высоты после разворота
			Hish_8 = hn;                                                                            // Задание исходной высоты БпЛА в начале снижения до заданной высоты после разворота
			tetaish_8 = tetan;                                                                      // Задание исходного угла наклона траектории БпЛА в начале снижения до заданной высоты после разворота
			init_8 = false;                                                                         // Запрет инициализации исходных значений параметров в начале снижения до заданной высоты после разворота
		}

		Tsn = (Hpolraz - Hish_8) / (Vish_8 * sin(0.5 * (tetaish_8)));                               // Расчет интервала времени снижения БпЛА до заданной высоты после разворота
		Nsn = ceil(Tsn / dt);                                                                       // Расчет количества отсчетов времени снижения БпЛА до заданной высоты после разворота
		dteta = tetaish_8 / Nsn;	                                                                // Расчет шага изменения угла наклона траектории БпЛА при снижении после разворота

		while ((hn > Hpolraz))                                                                      // До тех пор, пока рассчитываемая высота БпЛА будет больше или равна заданной высоте
		{
			if (tetan < (0.5 / dt) * dteta)                                                                  // Если угол наклона траектории БпЛА в n-й момент времени меньше 5 шагов изменения угла наклона траектории при снижении БпЛА после разворота
			{
				tetan = tetanm1 - dteta;                                                            // Угол снижения высоты БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории БпЛА при снижении высоты после разворота
			}

			if (tetan >= (0.5 / dt) * dteta)                                                                 // Если угол наклона траектории БпЛА в n-й момент времени больше или равен 5 шаам изменения угла наклона траектории при снижении БпЛА после разворота
			{
				tetan = (0.5 / dt) * dteta;                                                                  // Угол наклона траектории БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла наклона траектории при снижении БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                          // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                           // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                    // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                    // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                      // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                      // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                      // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                       // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                        // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                 // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                         // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                        // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);   // Запись в фильм n-й точки
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                              // Запись n-й точки в вектор

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                  // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                        // Продолжение снижения высоты
			}
		}
	}

	// Набор высоты //

	if ((hn < Hpolraz) && (abs(hn - Hpolraz) > 3.0) && (init_7 == true))                        // Если высота БпЛА в n-й момент времени меньше заданной высоты БпЛА после разворота и разница между высотами больше 1 м
	{
		if (init_9 == true)                                                                     // Если инициализация исходных значений параметров разрешена при наборе высоты до среднего значения текущей и заданной высоты после разворота
		{
			Vish_9 = Vn;                                                                        // Задание исходной скорости БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
			Hish_9 = hn;                                                                        // Задание исходной высоты БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
			tetaish_9 = tetan;                                                                  // Задание исходного угла наклона траектории БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
			init_9 = false;                                                                     // Запрет инициализации исходных значений параметров в начале набора высоты до среднего значения текущей и заданной высоты после разворота
		}

		double tetanab = 4.0 * Pi / 180.0;                                                                   // Задание угла наклона траектории БпЛА при наборе высоты после разворота
		double Tnab = (0.5 * (Hpolraz + Hish_9) - Hish_9) / (Vish_9 * sin(0.5 * (tetanab + tetaish_9)));     // Расчет интервала времени набора БпЛА среднего значения текущей и заданной высот
		double Nnab = ceil(Tnab / dt);                                                                       // Расчет количества отсчетов времени набора БпЛА среднего значения текущей и заданной высот               
		double dteta = (tetanab - tetaish_9) / Nnab;                                                         // Расчет шага изменения угла наклона траектории БпЛА при наборе высоты до среднего значения текущей и заданной высот

		while (hn < (Hish_9 + Hpolraz) / 2)                                                                  // До тех пор, пока рассчитываемая высота меньше среднего значения текущей и заданной высот БпЛА                                          
		{
			if (tetan < tetanab)                                                                             // Если угол наклона траектории БпЛА после разворота в n-й момент времени меньше заданного угла наклона траектории БпЛА при наборе высоты после разворота
			{
				tetan = tetanm1 + dteta;                                                                     // Расчет угла набора высоты БпЛА в n-й момент времени
			}

			if (tetan >= tetanab)                                                                            // Если угол наклона траектории БпЛА после разворота в n-й момент времени больше или равен заданному углу наклона траектории БпЛА при наборе высоты после разворота
			{
				tetan = tetanab;                                                                             // Угол наклона траектории при наборе высоты БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при наборе высоты после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                                   // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                         // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                         // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                         // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                                    // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                             // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                             // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                               // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                               // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                               // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                                // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                                 // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                          // Определение высоты точки в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                                  // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                                  // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                            // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                           // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);      // Запись в фильм n-й точки 
          
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
			
			F_n++;

			if (F_n == cur_F_n)                                                                    // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                          // Продолжение набора высоты
			}
		}

		//

		if (init_10 == true)                                                                       // Если инициализация исходных значений параметров разрешена при наборе заданной высоты после разворота
		{
			Vish_10 = Vn;                                                                          // Задание исходной скорости БпЛА в начале набора заданной высоты после разворота
			Hish_10 = hn;                                                                          // Задание исходной высоты БпЛА в начале набора заданной высоты после разворота
			tetaish_10 = tetan;                                                                    // Задание исходного угла наклона траектории БпЛА в начале набора заданной высоты после разворота
			init_10 = false;                                                                       // Запрет инициализации исходных значений параметров в начале набора заданной высоты после разворота
		}

		Tnab = (Hpolraz - Hish_10) / (Vish_10 * sin(0.5 * (tetaish_10)));                          // Расчет интервала времени набора БпЛА заданной высоты после разворота
		Nnab = ceil(Tnab / dt);                                                                    // Расчет количества отсчетов времени набора БпЛА заданной высоты после разворота
		dteta = tetaish_10 / Nnab;                                                                 // Расчет шага изменения угла набора заданной высоты БпЛА после разворота

		while (hn < Hpolraz)                                                                       // До тех пор, пока рассчитываемая высота БпЛА меньше заданной высоты
		{
			if (tetan > (0.5 / dt) * dteta)                                                                 // Если угол наклона траектории БпЛА после разворота в n-й момент времени больше 5 шагов изменения угла набора заданной высоты БпЛА после разворота
			{
				tetan = tetanm1 - dteta;                                                           // Расчет угла набора высоты БпЛА в n-й момент времени
			}

			if (tetan <= (0.5 / dt) * dteta)                                                                // Если угол наклона траектории БпЛА после разворота в n-й момент времени меньше или равен 5 шагам изменения угла набора заданной высоты БпЛА после разворота
			{
				tetan = (0.5 / dt) * dteta;                                                                 // Угол набора высоты БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла набора заданной высоты БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                          // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                   // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                   // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                     // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                     // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                     // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                      // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                       // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                // Определение высоты точки в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                                 // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                                 // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                           // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                          // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись в фильм n-й точки
            
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                              // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                   // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                         // Продолжение набора высоты
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Горизонтирование и набор скорости БпЛА после достижения заданной высоты //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_11 == true)                                       // Если инициализация исходных значений параметров разрешена при горизонтировании и наборе заданной скорости после достижения заданной высоты 
	{
		Vish_11 = Vn;                                          // Задание исходной скорости БпЛА в начале горизонтирования и набора заданной скорости после достижения заданной высоты
		tetaish_11 = tetan;                                    // Задание исходного угла наклона траектории БпЛА в начале горизонтирования и набора заданной скорости после достижения заданной высоты
		init_11 = false;                                       // Запрет инициализации исходных значений параметров в начале горизонтирования и набора заданной скорости после достижения заданной высоты
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Завершил разворот");                                    // Запись в фильм комментария
		
		if (round(Vish_11) != round(Vpolraz))
		{
			Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал разгон до максимальной скорости");      // Запись в фильм комментария
		}
	}
		
	double dV = plane.ttx_bpla.nx_max * dt;                    // Расчет шага изменения скорости полета БпЛА на заданной высоте
	
	dteta = tetaish_11 / (0.3 / dt);                           // Расчет шага изменения угла наклона траектори БпЛА при горизонтировании и наборе заданной скорости после достижения заданной высоты

	while ((Vn != Vpolraz) || (tetan != 0.0))                  // До тех пор, пока текущая скорость БпЛА не равна скорости БпЛА после разворота или текущий угол наклона траектории не равен нулю
	{
		if (abs(Vn - Vpolraz) > abs(dV))                       // Если модуль разности текущей скорости БпЛА и заданной скорости после разворота скорости меньше модуля шага изменения скорости
		{
			Vn = Vnm1 + dV;                                    // Расчет скорости БпЛА в n-й момент времени
		}

		if (abs(Vn - Vpolraz) <= abs(dV))                      // Если модуль разности текущей скорости БпЛА и заданной скорости после разворота скорости меньше или равен модулю шага изменения скорости
		{
			Vn = Vpolraz;                                      // Скорость БпЛА n-й момент времени приравнивается к заданной скорости
		}

		if (abs(tetan) > abs(dteta))                           // Если модуль угла наклона траектори БпЛА при горизонтировании после достижения заданной высоты больше модуля шага изменения угла наклона траектори БпЛА при горизонтировании после достижения заданной высоты
		{
			tetan = tetanm1 - dteta;                           // Расчет угла наклона траектории БпЛА при горизонтировании после разворота в n-й момент времени
		}
		else                                                   // В противном случае
		{
			tetan = 0.0;                                       // Угол наклона траектории БпЛА при горизонтировании после достижения заданной высоты в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись n-й точки в фильм
        
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после достижения заданной высоты в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение горизонтирования после достижения заданной высоты
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (round (Vish_11) != round(Vn))
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Набрал максимальную скорость");         // Запись в фильм комментария
	}

	init_5 = true;                                                                                   // Разрешение инициализации исходных значений параметров при развороте БпЛА
	init_6 = true;                                                                                   // Разрешение инициализации исходных значений параметров при горизонтировании БпЛА после разворота
	init_7 = true;                                                                                   // Разрешение инициализации исходных значений параметров при снижении БпЛА до среднего значения текущей и заданной высот после разворота
	init_8 = true;                                                                                   // Разрешение инициализации исходных значений параметров при снижении БпЛА до заданной высоты после разворота
	init_9 = true;                                                                                   // Разрешение инициализации исходных значений параметров при наборе БпЛА высоты до среднего значения текущей и заданной высот после разворота
	init_10 = true;                                                                                  // Разрешение инициализации исходных значений параметров при наборе БпЛА заданной высоты
	init_11 = true;                                                                                  // Разрешение инициализации исходных значений параметров при горизонтировании после достижения БпЛА заданной высоты
	F_n = 0;                                                                                         // Установление текущего отсчета положения БпЛА в 0

	return 1;                                                                                        // Окончание разворота БпЛА

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////// Модель вывода БпЛА в район аэродрома ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Vyvod_v_rayon_aerodroma(double Hzad, double Vzad)

{
	
	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                  // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                       // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                        // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                        // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                        // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                      // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                      // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                      // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                    // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                  // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                  // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах

	// Приведение kursnm1 к интервалу от 0 до 2 пи

	if (kursnm1 >= 2 * Pi)
	{
		kursnm1 = kursnm1 - 2 * Pi;
	}

	if (kursnm1 < 0)
	{
		kursnm1 = kursnm1 + 2 * Pi;
	}

	//

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                  // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                  // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                        // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                        // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                        // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double xgn = xgnm1;                                                   // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
	double ygn = ygnm1;                                                   // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
	double zgn = zgnm1;                                                   // Задание начального значения координаты zg БпЛА в местной СК в n - й момент времени

	double xn = xnm1;                                                     // Задание начального значения координаты x БпЛА в геоцентрической СК в в n-й момент времени
	double yn = ynm1;                                                     // Задание начального значения координаты y БпЛА в геоцентрической СК в в n-й момент времени
	double zn = znm1;                                                     // Задание начального значения координаты z БпЛА в геоцентрической СК в в n-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                  // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                    // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                   // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                    // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double Bn = Bnm1;                                                     // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                     // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                     // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);    // Расчет скорости БпЛА в (n-1)-й момент времени
	double Vn = Vnm1;                                                     // Задание начального значения скорости БпЛА в n-й момент времени

	double kursn = kursnm1;                                               // Задание начального значения угла поворота траектории БпЛА при развороте в n-й момент времени
	double tetan = tetanm1;                                               // Задание начального значения угла наклона траектории БпЛА при развороте в n-й момент времени
	double gamn = gamnm1;                                                 // Задание начального значения угла скоростного крена БпЛА при развороте в n-й момент времени

	//
	
	CPointGlobal p2 = plane.object.getPoint(0);                // Расчет координат аэродрома (2-й точки) в геоцентрической СК

	double x2 = p2.getPosition().getX();                       // Определение координаты x 2-й точки в геоцентрической СК
	double y2 = p2.getPosition().getY();                       // Определение координаты y 2-й точки в геоцентрической СК
	double z2 = p2.getPosition().getZ();                       // Определение координаты z 2-й точки в геоцентрической СК

	CPointGeo pg2 = p2.toPointGeo();                           // Преобразование точки pg2 из геоцентрической СК в геодезическую СК

	double B2 = pg2.getLatitude();                             // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double L2 = pg2.getLongitude();                            // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double h2 = pg2.getAltitude();                             // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	if (h2 != Hsn_1)                                           // Если высота расположения начальной точки (АК, стоящего на аэродроме) задана некорректно (отлична от нуля)
	{
		h2 = Hsn_1;                                            // Высота начальной точки приравнивается нулю
	}

	// Определение условной заданной точки в районе аэродрома

	if (init_40 == true)                                      // Если инициализация исходных значений параметров разрешена при определении условной заданной точки в районе аэродрома
	{
		Bish_40 = Bn;                                         // Исходное значение широты БпЛА при определении условной заданной точки в районе аэродрома
		init_40 = false;                                      // Запрет инициализации исходных значений параметров при определении условной заданной точки в районе аэродрома
	}

	double kursvz = plane.kursvz * Pi / 180.0;                // Курс взлета БпЛА
		
	if (abs(kursvz) >= 2 * Pi)
	{
		kursvz = kursvz - 2 * Pi * (kursvz / (2 * Pi));
	}

	if (kursvz < 0)
	{
		kursvz = kursvz + 2 * Pi;
	}

	if ((kursvz >= 0) && (kursvz < Pi))                       // Если курс взлета БпЛА находится в интервале от 0 до пи
	{
		if (Bish_40 >= B2)                                    // Если исходное значение широты БпЛА больше или равно значению широты аэродрома
		{
			B2 = B2 + 0.000025 * plane.ttx_bpla.H_kres;
			L2 = L2 - 0.000025 * plane.ttx_bpla.H_kres;
		}
		else                                                  // В противном случае                 
		{
			B2 = B2 - 0.000025 * plane.ttx_bpla.H_kres;
			L2 = L2 - 0.000025 * plane.ttx_bpla.H_kres;
		}
	}
	else                                                      // В противном случае
	{
		if (Bish_40 >= B2)                                    // Если исходное значение широты БпЛА больше или равно значению широты аэродрома
		{
			B2 = B2 + 0.000025 * plane.ttx_bpla.H_kres;
			L2 = L2 + 0.000025 * plane.ttx_bpla.H_kres;
		}
		else                                                  // В противном случае
		{
			B2 = B2 - 0.000025 * plane.ttx_bpla.H_kres;
			L2 = L2 + 0.000025 * plane.ttx_bpla.H_kres;
		}
	}
	
	pg2 = CPointGeo(p2.getTime(), B2, L2, h2);                                      // Создание точки pg2 в геодезической СК со скоректированной высотой
	p2 = pg2.toPointGlobal();                                                       // Перевод точки pg2 в геоцентрическую СК

	x2 = p2.getPosition().getX();                                                   // Определение координаты x БпЛА в геоцентрической СК в начальной точке
	y2 = p2.getPosition().getY();                                                   // Определение координаты y БпЛА в геоцентрической СК в начальной точке
	z2 = p2.getPosition().getZ();                                                   // Определение координаты z БпЛА в геоцентрической СК в начальной точке

	CPointGlobal p2o = CPointGlobal(F_LastTime, CPoint3D(x2, y2, z2));              // Создание точки pno в n-й момент времени в геоцентрической СК

	CPointLocal result2 = p2o.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

	double xg2 = result2.getPosition().getX();                                      // Определение координаты xg БпЛА в местной СК в n-й момент времени
	double yg2 = result2.getPosition().getY();                                      // Определение координаты yg БпЛА в местной СК в n-й момент времени
	double zg2 = result2.getPosition().getZ();                                      // Определение координаты zg БпЛА в местной СК в n-й момент времени

	CPointGeo pgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
	CPointGlobal pn = pgn.toPointGlobal();                                          // Преобразование созданной точки из геодезической СК в геоцентрическую СК

	xn = pn.getPosition().getX();                                                   // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
	yn = pn.getPosition().getY();                                                   // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
	zn = pn.getPosition().getZ();                                                   // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

	CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК

	CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

	xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
	ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
	zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
	
	double fkt = atan((xg2 - xgn) / (yg2 - ygn));                                   // Расчет угла визирования в горизонтальной плоскости точки стояния аэродрома из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

	if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
	{
		fkt = fkt;
	}
	else
		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
		{
			fkt = fkt + Pi;
		}
		else
			if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
			{
				fkt = fkt + 2 * Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
				{
					fkt = fkt + Pi;
				}
	   	  
	//
	
	double krenmax = plane.ttx_bpla.kren_max;                                 // Максимально допустимый угол крена БпЛА
	double Vmax = plane.ttx_bpla.V_max;                                       // Максимально допустимая скорость БпЛА
	double Vkr = plane.ttx_bpla.V_sv;                                         // Критическая скорость БпЛА
	double Vkres = plane.ttx_bpla.V_kres;                                     // Крейсерская скорость БпЛА

	//

	if (init_24 == true)                                                 // Если инициализация исходных значений параметров разрешена при развороте на точку
	{
		double x1 = xn;                                                  // Задание значения координаты x БпЛА в геоцентрической СК в 1 точке
		double y1 = yn;                                                  // Задание значения координаты y БпЛА в геоцентрической СК в 1 точке
		double z1 = zn;                                                  // Задание значения координаты z БпЛА в геоцентрической СК в 1 точке

		CPointGlobal p1 = CPointGlobal(F_LastTime, CPoint3D(x1, y1, z1));              // Создание начальной точки вывода БпЛА (1-й точки) в геоцентрической СК

		CPointLocal result1 = p1.toPointLocal(zentrnm1);                 // Перевод точки p1 из геоцентрической СК в местную СК с центром в 1-й точке
		CPointLocal result2 = p2.toPointLocal(zentrnm1);                 // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg1 = result1.getPosition().getX();                       // Определение координаты xg БпЛА в местной СК в 1 точке
		double xg2 = result2.getPosition().getX();                       // Определение координаты xg БпЛА в местной СК во 2 точке

		double yg1 = result1.getPosition().getY();                       // Определение координаты yg БпЛА в местной СК в 1 точке
		double yg2 = result2.getPosition().getY();                       // Определение координаты yg БпЛА в местной СК во 2 точке

		double zg1 = result1.getPosition().getZ();                       // Определение координаты zg БпЛА в местной СК в 1 точке
		double zg2 = result2.getPosition().getZ();                       // Определение координаты zg БпЛА в местной СК во 2 точке

		f2_a = atan((xg2 - xg1) / (yg2 - yg1));                          // Расчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

		if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) >= 0.0))
		{
			f2_a = f2_a;
		}
		else
			if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) < 0.0))
			{
				f2_a = f2_a + Pi;
			}
			else
				if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) >= 0.0))
				{
					f2_a = f2_a + 2 * Pi;
				}
				else
					if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) < 0.0))
					{
						f2_a = f2_a + Pi;
					}

		//

		// Задание значения шага изменения угла поворота траектории БпЛА //

		double Lnr = Ln;
		double L2r = L2;
		double Bnr = Bn + 90.0;
		double B2r = B2 + 90.0;

		if (Ln >= 0.0)
		{
			Lnr = Ln;
		}
		else
			if (Ln < 0.0)
			{
				Lnr = Ln + 360.0;
			}

		if (L2 >= 0.0)
		{
			L2r = L2;
		}
		else
			if (L2 < 0.0)
			{
				L2r = L2 + 360.0;
			}

		if (abs(Lnr - L2r) >= 180.0 && Lnr < L2r)
		{
			L2r = L2r - 360.0;
		}

		if (abs(Lnr - L2r) >= 180.0 && Lnr > L2r)
		{
			Lnr = Lnr - 360.0;
		}

		if (abs(Lnr - L2r) < 180.0 && Lnr < L2r)
		{
			L2r = L2r;
		}

		if (abs(Lnr - L2r) < 180.0 && Lnr > L2r)
		{
			Lnr = Lnr;
		}

		if (((Bnr <= B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
			((Bnr <= B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))) ||
			((Bnr > B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
			((Bnr > B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))))
		{
			dkurs_24 = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                                         // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
		}
		else
			if (((Bnr <= B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
				((Bnr <= B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))) ||
				((Bnr > B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
				((Bnr > B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))))
			{
				dkurs_24 = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                                   // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
			}
				
		//
				
			Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал выход в район аэродрома");               // Запись в фильм комментария
						
		//

		double R = Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0));                                          // Вычисление требуемого радиуса разворота при максимально допустимом крене
		double D = sqrt((xg2 - xg1) * (xg2 - xg1) + (yg2 - yg1) * (yg2 - yg1) + (zg2 - zg1) * (zg2 - zg1));         // Вычисление расстояния между 1 и 2 точками

		if ((2 * R >= D) && (abs(f2_a - kursnm1) > Vnm1 * dt / R))                                                  // Если диаметр разворота больше расстояния между 1 и 2 точками, и разность курса и угла визирования 2 точки из 1 точки в горизонтальной плоскости больше  изменения угла поворота траектории БпЛА при значении 30 градусов его скоростного крена
		{
			if (((Bnr <= B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
				((Bnr <= B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))) ||
				((Bnr > B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
				((Bnr > B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))))
			{
				dkurs_24 = 2 * Vnm1 * dt / D;                                                                       // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
			}
			else
				if (((Bnr <= B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
					((Bnr <= B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))) ||
					((Bnr > B2r) && (Lnr >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
					((Bnr > B2r) && (Lnr < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))))
				{
					dkurs_24 = -2 * Vnm1 * dt / D;                                          // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
				}
					
		}

		fn_a = f2_a;                                                                        // Начальное значение угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		init_24 = false;                                                                    // Запрет инициализации исходных значений параметров при развороте на точку визирования
	}

	//
		
	// Разворот на точку визирования (условную заданную точку в районе аэродрома) //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	while (abs(fn_a - kursn) > abs(dkurs_24))                                      // До тех пор, пока разность угла поворота траектории и угла визирования в горизонтальной плоскости больше dfi_a
	{
		if (init_25 == false || init_26 == false || init_29 == false || init_30 == false || init_31 == false || init_32 == false || init_33 == false || init_34 == false || init_35 == false)       // Если уже рассчитывается снижение или набор высоты, горизонтирование с набором скорости или полет с доворотом на точку визирования
		{
			break;                                                                    // Стоп
		}

		kursn = kursnm1 + dkurs_24;                                                   // Расчет угла поворота траектории БпЛА в n-й момент времени
		
		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                   // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                   // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                      // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                      // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                      // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                 // Задание отсчетов времени

		gamn = atan(dkurs_24 * Vn * cos(tetan) / ((tetan - tetanm1) * Vn + dt * Settings.getEarthGravity() * cos(tetan)));       // Расчет угла скоростного крена БпЛА в n-й момент времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));          // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                          // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                            // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                            // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                            // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));             // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                              // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

		CPointLocal result2 = p2.toPointLocal(zentrnm1);                              // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg2 = result2.getPosition().getX();                                    // Определение координаты xg БпЛА в местной СК во 2 точке
		double yg2 = result2.getPosition().getY();                                    // Определение координаты yg БпЛА в местной СК во 2 точке
		double zg2 = result2.getPosition().getZ();                                    // Определение координаты zg БпЛА в местной СК во 2 точке

		fn_a = atan((xg2 - xgn) / (yg2 - ygn));                                       // Расчет угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени //

		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
		{
			fn_a = fn_a;
		}
		else
			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
			{
				fn_a = fn_a + Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
				{
					fn_a = fn_a + 2 * Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
					{
						fn_a = fn_a + Pi;
					}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                  // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                  // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                            // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Расчет значения скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		double gamn0 = 0.0;

		if ((F_n >= 0) && (F_n < (2 / dt)))
		{
			double gamnmax = gamn * 180.0 / Pi;
			double dgam = gamnmax / (2 / dt);
			double gamman = gamn0 + F_n * dgam;

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);          // Запись в фильм n-й точки в фильм	
            
			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки		
		}
		else
			if (F_n >= (2 / dt))
			{
				double gamman = gamn * 180.0 / Pi;                                                           // Пересчет значения скоростного крена БпЛА в n-й момент времени из радиан в градусы для вывода на интерфейс

				Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);    // Запись в фильм n-й точки в фильм
               
				plane.curPos.time = F_LastTime;
				plane.curPos.x = xn;
				plane.curPos.y = yn;
				plane.curPos.z = zn;
				plane.curPos.vx = Vxn;
				plane.curPos.vy = Vyn;
				plane.curPos.vz = Vzn;
				plane.curPos.fi = kursn;
				plane.curPos.teta = tetan;
				plane.curPos.gamma = gamman * Pi / 180.0;

				plane.Trajectory.push_back(plane.curPos);                                                    // Запись в вектор n-й точки		
			}

		//

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		kursnm1 = kursn;
		tetanm1 = tetan;

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}

	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Горизонтирование БпЛА после разворота //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_25 == true)                                            // Если инициализация исходных значений параметров разрешена при горизонтировании после разворота
	{
		tetaish_25 = tetan;                                         // Задание исходного угла наклона траектории БпЛА в начале горизонтирования после разворота
		gamish_25 = gamn;                                           // Задание исходного угла скоростного крена БпЛА в начале горизонтирования после разворота
		
		init_25 = false;                                            // Запрет инициализации исходных значений параметров в начале горизонтирования после разворота
	}

	double dteta = tetaish_25 / (0.6 / dt);                                // Расчет шага изменения угла наклона траектории БпЛА при горизонтировании после разворота
	double dgamma = gamish_25 / (2.0 / dt);                               // Расчет шага изменения угла скоростного крена БпЛА при горизонтировании после разворота

	while ((tetan != 0.0) || (gamn != 0.0))                         // До тех пор, пока угол наклона траектории или угол скоростного крена БпЛА в n-й момент времени не равен нулю
	{
		if (init_26 == false || init_29 == false || init_30 == false || init_31 == false || init_32 == false || init_33 == false || init_34 == false || init_35 == false)            // Если уже рассчитывается снижение или набор высоты, горизонтирование с набором скорости или полет с доворотом на точку визирования 
		{
			break;                                                  // Стоп
		}

		if (abs(tetan) > abs(dteta))                                // Если модуль угла наклона траектории БпЛА больше модуля шага изменения угла наклона траектории БпЛА при горизонтировании после разворота
		{
			tetan = tetanm1 - dteta;                                // Расчет значения угла наклона траектории БпЛА при горизонтировании после разворота в n-й момент времени
		}

		if (abs(tetan) <= abs(dteta))                               // Если модуль угла наклона траектории БпЛА меньше или равен модулю шага изменения угла наклона траектории БпЛА при горизонтировании после разворота
		{
			tetan = 0.0;                                            // Угол наклона траектории БпЛА при горизонтировании после разворота в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                 // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                 // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                              // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                    // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                    // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                    // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                               // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                     // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		if (abs(gamn) > abs(dgamma))                          // Если модуль угла скоростного крена БпЛА больше модуля шага изменения угла скоростного крена БпЛА при горизонтировании после разворота
		{
			gamn = gamn - dgamma;                             // Расчет значения угла скоростного крена БпЛА при горизонтировании после разворота в n-й момент времени
		}

		if (abs(gamn) <= abs(dgamma))                         // Если модуль угла скоростного крена БпЛА меньше или равен модулю шага изменения угла скоростного крена БпЛА при горизонтировании после разворота
		{
			gamn = 0.0;                                       // Угол скоростного крена БпЛА при горизонтировании после разворота в n-й момент времени приравнивается к нулю
		}

		double gamman = gamn * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись в фильм n-й точки
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
	// Набор заданной скорости //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_26 == true)                                                                   // Если инициализация исходных значений параметров разрешена при наборе заданной скорости (по ситуации)
	{
		Vish_26 = Vn;                                                                      // Задание исходной скорости БпЛА в начале набора заданной скорости (по ситуации)
		Hish_26 = hn;                                                                      // Задание исходного угла наклона траектории БпЛА в начале набора заданной скорости (по ситуации)
		tetaish_26 = tetan;                                                                // Задание исходного угла наклона траектории БпЛА в начале набора заданной скорости (по ситуации)
		init_26 = false;                                                                   // Запрет инициализации исходных значений параметров в начале набора заданной скорости (по ситуации)
	}
			
		double dV = -plane.ttx_bpla.nx_max * dt;
				
		while (Vn != Vzad)                                                                 // До тех пор, пока текущая скорость БпЛА не равна заданной скорости БпЛА
		{
			if (init_29 == false || init_30 == false || init_31 == false || init_32 == false || init_33 == false || init_34 == false || init_35 == false)              // Если уже рассчитывается снижение или набор высоты, горизонтирование с набором скорости или полет с дворотом на точку визирования
			{
				break;                                             // Стоп
			}

			if (abs(Vn - Vzad) > abs(dV))                          // Если модуль разности текущей скорости БпЛА и заданной скорости после разворота скорости меньше модуля шага изменения скорости
			{
				Vn = Vnm1 + dV;                                    // Расчет скорости БпЛА в n-й момент времени
			}

			if (abs(Vn - Vzad) <= abs(dV))                         // Если модуль разности текущей скорости БпЛА и заданной скорости после разворота скорости меньше или равен модулю шага изменения скорости
			{
				Vn = Vzad;                                         // Скорость БпЛА n-й момент времени приравнивается к заданной скорости
			}

			if (tetan != tetaish_26)                               // Если текущий угол наклона траектории БпЛА не равен исходному углу наклона траектории БпЛА в начале набора заданной скорости (по ситуации)
			{
				tetan = tetaish_26;                                // Текущий угол наклона траектории БпЛА приравнивается к исходному углу наклона траектории БпЛА в начале набора заданной скорости (по ситуации)
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Стабилизация заданной высоты полета БпЛА //

			if (hn != Hish_26)                                                                  // Если текущая высота не равна исходной высоте
			{
				hn = Hish_26;                                                                   // Текущая высота приравнивается к исходной высоте

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xn = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				yn = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				zn = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			//

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись n-й точки в фильм
           
			// Обновление параметров с интервалом 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//

			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Достижение заданной высоты БпЛА после разворота//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Набор высоты //

	if ((hn < Hzad) && (abs(hn - Hzad) > 3.0) && (init_31 == true && init_32 == true && init_33 == true && init_34 == true && init_35 == true))    // Если высота БпЛА в n-й момент времени меньше заданной высоты БпЛА после разворота и не выполняется снижение высоты, горизонтирование с набором скорости, полет с доворотом и горизонтирование
	{
		if (init_29 == true)                                                                       // Если инициализация исходных значений параметров разрешена при наборе высоты до среднего значения текущей и заданной высоты после разворота
		{
			Vish_29 = Vn;                                                                          // Задание исходной скорости БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
			Hish_29 = hn;                                                                          // Задание исходной высоты БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
			tetaish_29 = tetan;                                                                    // Задание исходного угла наклона траектории БпЛА в начале набора высоты до среднего значения текущей и заданной высоты после разворота
						
			if (Vish_29 < Vkr / 0.9)                                                               // Если текущая скорость БпЛА меньше 1/0,9 критической скорости
			{
				return 1;                                                                          // Набор высоты невозможен
			}

			init_29 = false;                                                                       // Запрет инициализации исходных значений параметров в начале набора высоты до среднего значения текущей и заданной высоты после разворота
		}

		// Задание угла наклона траектории при наборе высоты БпЛА после разворота

		double tetanab = 0.0;                                                                      // Задание начального значения угла наклона траектории при наборе высоты БпЛА после разворота

		if (Hzad - Hish_29 <= 100.0)
		{
			tetanab = 5.0 * Pi / 180.0;
		}
		else
			if ((Hzad - Hish_29 > 100.0) && (Hzad - Hish_29 <= 500.0))
			{
				tetanab = 10.0 * Pi / 180.0;
			}
			else
				if ((Hzad - Hish_29 > 500.0) && (Hzad - Hish_29 <= 1000.0))
				{
					tetanab = 15.0 * Pi / 180.0;
				}
				else
					if ((Hzad - Hish_29 > 1000.0) && (Hzad - Hish_29 <= 2500.0))
					{
						tetanab = 20.0 * Pi / 180.0;
					}
					else
						if (Hzad - Hish_29 > 2500.0)
						{
							tetanab = 30.0 * Pi / 180.0;
						}

		//

		double Tnab = (0.5 * (Hzad + Hish_29) - Hish_29) / (0.5 * (Vish_29 + Vish_29 * 0.95) * sin(0.5 * (tetanab + tetaish_29)));      // Интервал времени набора БпЛА среднего значения текущей и заданной высот
		double Nnab = ceil(Tnab / dt);                                                               // Количество отсчетов времени набора БпЛА среднего значения текущей и заданной высот               
		double dteta = (tetanab - tetaish_29) / Nnab;                                                // Шаг изменения угла набора БпЛА среднего значения текущей и заданной высот
		double dV = (Vish_29 * 0.95 - Vish_29) / Nnab;                                               // Шаг изменения скорости БпЛА

		while (hn < (Hish_29 + Hzad) / 2)                                                            // До тех пор, пока рассчитываемая высота меньше среднего значения текущей и заданной высот БпЛА                                          
		{
			if (Vn > Vish_29 * 0.95)                                                                 // Если скорость набора высоты в n-й момент времени больше 0,95 скорости в начале набора высоты БпЛА
			{
				Vn = Vnm1 + dV;                                                                      // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn <= Vish_29 * 0.95)                                                                // Если скорость набора высоты в n-й момент времени меньше или равна 0,95 скорости в начале набора высоты БпЛА
			{
				Vn = Vish_29 * 0.95;                                                                 // Скорость БпЛА в n-й момент времени приравнивается к 0,95 скорости в начале набора высоты БпЛА
			}

			if (tetan < tetanab)                                                                     // Если угол наклона траектории БпЛА в n-й момент времени меньше угла наклона траектории БпЛА в n-й момент времени
			{
				tetan = tetanm1 + dteta;                                                             // Расчет угла наклона траектории при наборе высоты БпЛА в n-й момент времени
			}

			if (tetan >= tetanab)                                                                    // Если угол наклона траектории БпЛА в n-й момент времени больше или равен углу наклона траектории БпЛА в n-й момент времени
			{
				tetan = tetanab;                                                                     // Угол наклона траектории при наборе высоты БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при наборе высоты
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                              // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                              // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                           // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                 // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                 // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                 // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                            // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                     // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                     // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                       // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                       // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                       // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                        // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                         // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                  // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                                  // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                                  // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                            // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                           // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);      // Запись в фильм n-й точки 
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                    // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                          // Продолжение полета БпЛА
			}

		}

		//

		if (init_30 == true)                                                                       // Если инициализация исходных значений параметров разрешена при наборе заданной высоты после разворота
		{
			Vish_30 = Vn;                                                                          // Задание исходной скорости БпЛА в начале набора заданной высоты после разворота
			Hish_30 = hn;                                                                          // Задание исходной высоты БпЛА в начале набора заданной высоты после разворота
			tetaish_30 = tetan;                                                                    // Задание исходного угла наклона траектории БпЛА в начале набора заданной высоты после разворота
			init_30 = false;                                                                       // Запрет инициализации исходных значений параметров в начале набора заданной высоты после разворота
		}

		Tnab = (Hzad - Hish_30) / (0.5 * (Vish_30 + 0.9 * Vish_29) * sin(0.5 * (tetaish_30)));     // Интервал времени набора БпЛА заданной высоты после разворота
		Nnab = ceil(Tnab / dt);                                                                    // Количество отсчетов времени набора БпЛА заданной высоты после разворота
		dteta = tetaish_30 / Nnab;                                                                 // Шаг изменения угла набора заданной высоты БпЛА после разворота
		dV = (0.9 * Vish_29 - Vish_30) / Nnab;                                                     // Шаг изменения скорости полета БпЛА до набора заданной высоты

		while (hn < Hzad)                                                                          // До тех пор, пока рассчитываемая высота БпЛА меньше заданной высоты
		{
			if (Vn > 0.9 * Vish_29)                                                                // Если скорость набора высоты в n-й момент времени больше 0,9 скорости в начале набора высоты БпЛА
			{
				Vn = Vnm1 + dV;                                                                    // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn <= 0.9 * Vish_29)                                                               // Если скорость набора высоты в n-й момент времени меньше или равна 0,9 скорости в начале набора высоты БпЛА
			{
				Vn = 0.9 * Vish_29;                                                                // Скорость БпЛА в n-й момент времени приравнивается к 0,9 заданной скорости после набора высоты
			}

			if (tetan > (0.5 / dt) * dteta)                                                                 // Если угол наклона траектории БпЛА в n-й момент времени больше 5 шагов изменения угла наклона траектории при наборе заданной высоты БпЛА
			{
				tetan = tetanm1 - dteta;                                                           // Расчет угла набора высоты БпЛА в n-й момент времени
			}

			if (tetan <= (0.5 / dt) * dteta)                                                                // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен 5 шагам изменения угла наклона траектории при наборе заданной высоты БпЛА
			{
				tetan = (0.5 / dt) * dteta;                                                                 // Угол набора высоты БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла наклона траектории при наборе заданной высоты БпЛА
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                          // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                   // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                   // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                     // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                     // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                     // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                      // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                       // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                                 // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                                 // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                           // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                          // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись в фильм n-й точки
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                             // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                   // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени набора высоты БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                         // Продолжение полета БпЛА
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Горизонтирование БпЛА и набор заданной скорости после достижения заданной высоты //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_31 == true)                                                                         // Если инициализация исходных значений параметров разрешена при горизонтировании и наборе заданной скорости после разворота
	{
		Vish_31 = Vn;                                                                            // Задание исходной скорости БпЛА в начале горизонтирования и набора заданной скорости после разворота
		tetaish_31 = tetan;                                                                      // Задание исходного угла наклона траектории БпЛА в начале горизонтирования и набора заданной скорости после разворота
		init_31 = false;                                                                         // Запрет инициализации исходных значений параметров в начале горизонтирования и набора заданной скорости после разворота
	}
	
	if (abs(Vzad - Vish_31) <= 1.0)                                                              // Если модуль разности заданной и исходной скорости меньше или равен 1 м/с
	{
		dV = (Vzad - Vish_31) / (0.1 / dt);                                                             // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 1 такта (0.1 с)
	}
	else
		if (abs(Vzad - Vish_31) > 1.0 && abs(Vzad - Vish_31) <= 25.0)                            // Если модуль разности заданной и исходной скорости меньше или равен 25 м/с
		{
			dV = (Vzad - Vish_31) / (2.0 / dt);                                                        // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 20 тактов (2 с)
		}
	else                                                                                         // В противном случае
		if ((abs(Vzad - Vish_31) > 25.0) && (abs(Vzad - Vish_31) <= 100.0))                      // Если модуль разности заданной и исходной при горизонтировании скорости больше 25 м/с и меньше или равен 100 м/с
		{
			dV = (Vzad - Vish_31) / (5.0 / dt);                                                        // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 50 тактов (5 с)
		}
		else                                                                                     // В противном случае
			if ((abs(Vzad - Vish_31) > 100.0) && (abs(Vzad - Vish_31) <= 200.0))                 // Если модуль разности заданной и исходной при горизонтировании скорости больше 100 м/с и меньше или равен 200 м/с
			{
				dV = (Vzad - Vish_31) / (10.0 / dt);                                                   // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 100 тактов (10 с)
			}
			else                                                                                 // В противном случае
				if (abs(Vzad - Vish_31) > 200.0)                                                 // Если модуль разности заданной и исходной при горизонтировании скорости больше 200 м/с
				{
					dV = (Vzad - Vish_31) / (20.0 / dt);                                               // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 200 тактов (20 с)
				}

	dteta = tetaish_31 / (0.3 / dt);                                  // Расчет шага изменения угла наклона траектори БпЛА при горизонтировании и наборе заданной скорости после достижения заданной высоты

	while ((Vn != Vzad) || (tetan != 0.0))                     // До тех пор, пока текущая скорость БпЛА не равна скорости БпЛА после разворота или текущий угол наклона траектории не равен нулю
	{
		if (init_32 == false || init_33 == false || init_34 == false || init_35 == false)        // Если уже рассчитывается полет с доворотом на точку визирования или горизонтирование 
		{
			break;                                             // Стоп
		}

		if (abs(Vn - Vzad) > abs(dV))                          // Если модуль разности текущей скорости БпЛА и заданной скорости больше модуля шага изменения скорости
		{
			Vn = Vnm1 + dV;                                    // Расчет скорости БпЛА в n-й момент времени
		}

		if (abs(Vn - Vzad) <= abs(dV))                         // Если модуль разности текущей скорости БпЛА и заданной скорости меньше или равен модулю шага изменения скорости
		{
			Vn = Vzad;                                         // Скорость БпЛА n-й момент времени приравнивается к заданной скорости
		}

		if (abs(tetan) > abs(dteta))                           // Если модуль угла наклона траектори БпЛА при горизонтировании после достижения заданной высоты больше модуля шага изменения угла наклона траектори БпЛА при горизонтировании после достижения заданной высоты
		{
			tetan = tetanm1 - dteta;                           // Расчет угла наклона траектории БпЛА при горизонтировании и наборе заданной скорости после достижения заданной высоты в n-й момент времени
		}
		else                                                   // В противном случае
		{
			tetan = 0.0;                                       // Угол наклона траектории БпЛА при горизонтировании и наборе заданной скорости после достижения заданной высоты в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                       // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                       // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                         // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                         // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                         // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                          // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                                                    // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                  // Значение угла скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись n-й точки в фильм
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
		
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Полет с доворотом на точку визирования //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_32 == true)                                          // Если инициализация исходных значений параметров разрешена при полете с доворотом на точку визирования
	{
		Hish_32 = hn;                                             // Задание исходной высоты в начале полета с доворотом на точку визирования

		double x1 = xn;                                           // Задание начального значения координаты x БпЛА в геоцентрической СК
		double y1 = yn;                                           // Задание начального значения координаты y БпЛА в геоцентрической СК
		double z1 = zn;                                           // Задание начального значения координаты z БпЛА в геоцентрической СК

		CPointGlobal p1 = CPointGlobal(F_LastTime, CPoint3D(x1, y1, z1));       // Создание начальной точки вывода БпЛА (1-й точки) в геоцентрической СК

		CPointLocal result1 = p1.toPointLocal(zentrnm1);          // Перевод точки p1 из геоцентрической СК в местную СК с центром в 1-й точке
		CPointLocal result2 = p2.toPointLocal(zentrnm1);          // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg1 = result1.getPosition().getX();                // Определение координаты xg БпЛА в местной СК (в 1 точке)
		double xg2 = result2.getPosition().getX();                // Определение координаты xg 2-й точки в местной СК (во 2 точке)

		double yg1 = result1.getPosition().getY();                // Определение координаты yg БпЛА в местной СК (в 1 точке)
		double yg2 = result2.getPosition().getY();                // Определение координаты yg 2-й точки в местной СК (во 2 точке)

		double zg1 = result1.getPosition().getZ();                // Определение координаты zg БпЛА в местной СК (в 1 точке)
		double zg2 = result2.getPosition().getZ();                // Определение координаты zg 2-й точки в местной СК (во 2 точке)

		f2_a = atan((xg2 - xg1) / (yg2 - yg1));                   // Расчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

		if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) >= 0.0))
		{
			f2_a = f2_a;
		}
		else
			if (((xg2 - xg1) >= 0.0) && ((yg2 - yg1) < 0.0))
			{
				f2_a = f2_a + Pi;
			}
			else
				if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) >= 0.0))
				{
					f2_a = f2_a + 2 * Pi;
				}
				else
					if (((xg2 - xg1) < 0.0) && ((yg2 - yg1) < 0.0))
					{
						f2_a = f2_a + Pi;
					}

		//

		// Задание значения шага изменения угла поворота траектории БпЛА //

		CPointGeo pg1 = p1.toPointGeo();                         // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bnm1 = pg1.getLatitude();                                // Определение широты БпЛА в n-й момент времени в геодезической СК
		Lnm1 = pg1.getLongitude();                               // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hnm1 = pg1.getAltitude();                                // Определение высоты БпЛА в n-й момент времени в геодезической СК

		double Lnm1r = Lnm1;
		double L2r = L2;
		double Bnm1r = Bnm1 + 90.0;
		double B2r = B2 + 90.0;

		if (Lnm1 >= 0.0)
		{
			Lnm1r = Lnm1;
		}
		else
			if (Lnm1 < 0.0)
			{
				Lnm1r = Lnm1 + 360.0;
			}

		if (L2 >= 0.0)
		{
			L2r = L2;
		}
		else
			if (L2 < 0.0)
			{
				L2r = L2 + 360.0;
			}

		if (abs(Lnm1r - L2r) >= 180.0 && Lnm1r < L2r)
		{
			L2r = L2r - 360.0;
		}

		if (abs(Lnm1r - L2r) >= 180.0 && Lnm1r > L2r)
		{
			Lnm1r = Lnm1r - 360.0;
		}

		if (abs(Lnm1r - L2r) < 180.0 && Lnm1r < L2r)
		{
			L2r = L2r;
		}

		if (abs(Lnm1r - L2r) < 180.0 && Lnm1r > L2r)
		{
			Lnm1r = Lnm1r;
		}

		if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
			((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))) ||
			((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
			((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))))
		{
			dkurs_32 = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                            // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
		}
		else
			if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
				((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))))
			{
				dkurs_32 = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;                      // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
			}
			   
		double R = Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0));                             // Вычисление требуемого радиуса разворота при максимально допустимом при управлении с наземной АСУ крене
		double Dn = sqrt((xg2 - xgn) * (xg2 - xgn) + (yg2 - ygn) * (yg2 - ygn) + (zg2 - zgn) * (zg2 - zgn));     // Вычисление расстояния между 1 и 2 точками

		if ((2 * R >= Dn) && (abs(f2_a - kursnm1) > Vnm1 * dt / R))                                     // Если диаметр разворота больше расстояния между 1 и 2 точками, и разность курса и угла визирования 2 точки из 1 точки в горизонтальной плоскости больше 30 градусов
		{
			if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
				((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) < 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 >= 0.0))) ||
				((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 >= 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) < 0.0))))
			{
				dkurs_32 = 2 * Vnm1 * dt / Dn;                                                           // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
			}
			else
				if (((Bnm1r <= B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
					((Bnm1r <= B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))) ||
					((Bnm1r > B2r) && (Lnm1r >= L2r) && ((kursnm1 < Pi) && (f2_a - (kursnm1 + Pi) >= 0.0) || (kursnm1 >= Pi) && (f2_a - kursnm1 < 0.0))) ||
					((Bnm1r > B2r) && (Lnm1r < L2r) && ((kursnm1 < Pi) && (f2_a - kursnm1 < 0.0) || (kursnm1 >= Pi) && (f2_a - (kursnm1 - Pi) >= 0.0))))
				{
					dkurs_32 = -2 * Vnm1 * dt / Dn;                                                      // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
				}
		}
		
		//

		fn_a = f2_a;                                                                                     // Угол визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		// Определение расчетного угла наклона траектории БпЛА при снижении

		if ((Hish_32 - Hsn_1) <= 100.0 && (Hish_32 - Hsn_1 > 0.0))
		{
			tetasn_1 = -5.0 * Pi / 180.0;
		}
		else
			if ((Hish_32 - Hsn_1 > 100.0) && (Hish_32 - Hsn_1 <= 500.0))
			{
				tetasn_1 = -10.0 * Pi / 180.0;
			}
			else
				if ((Hish_32 - Hsn_1 > 500.0) && (Hish_32 - Hsn_1 <= 1000.0))
				{
					tetasn_1 = -15.0 * Pi / 180.0;
				}
				else
					if ((Hish_32 - Hsn_1 > 1000.0) && (Hish_32 - Hsn_1 <= 2500.0))
					{
						tetasn_1 = -20.0 * Pi / 180.0;
					}
					else
						if (Hish_32 - Hsn_1 > 2500.0)
						{
							tetasn_1 = -30.0 * Pi / 180.0;
						}
						
		init_32 = false;                                                                           // Запрет инициализации исходных значений параметров разрешена при полете с доворотом на точку визирования
	}

	//

	double Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));       // Расчет расстояния до точки в начальный момент времени

	// Определение примерного расстояния, требуемого для полета БпЛА до условной заданной точки в районе аэродрома
	
	if (round(Hish_32) > Hsn_1 + 10.0)
	{
		D_a = 1.5 * sqrt(((Hish_32 - Hsn_1) * tan(Pi / 2.0 + tetasn_1 / 2.0) + ((1.1 * Vzad + Vkres) / 2 * 5.0)) * ((Hish_32 - Hsn_1) * tan(Pi / 2.0 + tetasn_1 / 2.0) + ((1.1 * Vzad + Vkres) / 2 * 5.0)) + (Hish_32 - Hsn_1) * (Hish_32 - Hsn_1));
	}
	else	
	{
	    D_a = 20.0 * Vzad * dt;
	}
	
	//

	while (Dn > D_a)                                                                             // До тех пор, пока дальность до точки больше D_a
	{
		if (init_33 == false || init_34 == false || init_35 == false)                            // Если уже рассчитывается горизонтирование после доворота
		{
			break;                                             // Стоп
		}

		if (abs(fn_a - kursn) >= abs(dkurs_32))                // Если модуль разности угла визирования точки в горизонтальной плоскости и угла поворота траектории БпЛА в n-й момент времени больше или равна шагу изменения угла поворота траектории БпЛА
		{
			kursn = kursnm1 + dkurs_32;                        // Расчет угла поворота траектории БпЛА в n-й момент времени
		}
		else                                                   // В противном случае
		{
			kursn = fn_a;                                      // Угол поворота траектории приравнивается к углу визирования
		}

		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		double Vxgn = Vn * cos(tetan) * sin(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                          // Задание отсчетов времени
				
		tetanm1 = tetan;

		gamn = atan((kursn - kursnm1) * Vn * cos(tetan) / ((tetan - tetanm1) * Vn + dt * Settings.getEarthGravity() * cos(tetan)));       // Расчет угла скоростного крена БпЛА в n-й момент времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn != Hish_32)                                                                  // Если текущая высота не равна исходной высоте
		{
			hn = Hish_32;                                                                   // Текущая высота приравнивается к исходной высоте
		}
		
		CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
		CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

		xn = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		yn = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		zn = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
		CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

		xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
		ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
		zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени

		CPointLocal result2 = p2.toPointLocal(zentrnm1);                                // Перевод точки p2 из геоцентрической СК в местную СК с центром в 1-й точке

		double xg2 = result2.getPosition().getX();                                      // Определение координаты xg 2-й точки в местной СК (во 2 точке)
		double yg2 = result2.getPosition().getY();                                      // Определение координаты yg 2-й точки в местной СК (во 2 точке)
		double zg2 = result2.getPosition().getZ();                                      // Определение координаты zg 2-й точки в местной СК (во 2 точке)

		Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));        // Расчет расстояния до точки в начальный момент времени

		fn_a = atan((xg2 - xgn) / (yg2 - ygn));                   // Расчет угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из точки в n-й момент времени //

		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
		{
			fn_a = fn_a;
		}
		else
			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
			{
				fn_a = fn_a + Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
				{
					fn_a = fn_a + 2 * Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
					{
						fn_a = fn_a + Pi;
					}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                  // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                  // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                            // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = gamn * 180.0 / Pi;

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);         // Запись в фильм n-й точки	
        
		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn;

		plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки	
		
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		kursnm1 = kursn;
						
		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}

	}
		
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
	// Снижение //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (hn > Hsn_1)
	{
		if (init_33 == true)
		{
			Hish_33 = hn;
			Vish_33 = Vn;
			tetaish_33 = tetan;

			init_33 = false;
		}

		// Определение угла наклона траектории при снижении БпЛА
		
		double tetasn = 0.0;

		if (Hish_33 - Hsn_1 <= 100.0)
		{
			tetasn = -5.0 * Pi / 180.0;
		}
		else
			if ((Hish_33 - Hsn_1 > 100.0) && (Hish_33 - Hsn_1 <= 500.0))
			{
				tetasn = -10.0 * Pi / 180.0;
			}
			else
				if ((Hish_33 - Hsn_1 > 500.0) && (Hish_33 - Hsn_1 <= 1000.0))
				{
					tetasn = -15.0 * Pi / 180.0;
				}
				else
					if ((Hish_33 - Hsn_1 > 1000.0) && (Hish_33 - Hsn_1 <= 2500.0))
					{
						tetasn = -20.0 * Pi / 180.0;
					}
					else
						if (Hish_33 - Hsn_1 > 2500.0)
						{
							tetasn = -30.0 * Pi / 180.0;
						}

		//

		double Tsn = (0.5 * (Hsn_1 + Hish_33) - Hish_33) / (0.5 * (Vish_33 + 1.05 * Vish_33) * sin(0.5 * (tetasn + tetaish_33)));     // Интервал времени снижения БпЛА до половины разницы между текущей и заданной высотами БпЛА
		size_t Nsn = (size_t) ceil(Tsn / dt);                                                                                         // Количество отсчетов времени снижения БпЛА до половины разницы между текущей и заданной высотами БпЛА               
		double dV = (1.05 * Vish_33 - Vish_33) / Nsn;                                                                                 // Шаг изменения скорости полета БпЛА после начала снижения до половины разницы между текущей и заданной высотами БпЛА
		double dteta = (tetasn - tetaish_33) / Nsn;                                                                                   // Шаг изменения угла снижения БпЛА до половины разницы между текущей и заданной высотами БпЛА

		while (hn > 0.5 * (Hsn_1 + Hish_33))                                                   // До тех пор, пока рассчитываемая высота больше среднего значения текущей и заданной высот БпЛА
		{
			if (init_34 == false || init_35 == false)                                          // Если уже рассчитывается горизонтирование после доворота
			{
				break;                                                                         // Стоп
			}
			
			if (Vn < Vish_33 * 1.05)                                                           // Если скорость снижения высоты в n-й момент времени больше 1,05 скорости в начале снижения
			{
				Vn = Vnm1 + dV;                                                                // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn >= Vish_33 * 1.05)                                                          // Если скорость снижения высоты в n-й момент времени меньше или равна 1,05 скорости в начале снижения
			{
				Vn = Vish_33 * 1.05;                                                           // Скорость БпЛА в n-й момент времени приравнивается к 1,05 скорости в начале снижения
			}

			if (tetan > tetasn)                                                                // Если угол наклона траектории БпЛА в n-й момент времени больше заданного угла наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetanm1 + dteta;                                                       // Расчет угла наклона траектории БпЛА в n-й момент времени
			}

			if (tetan <= tetasn)                                                               // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен заданному углу наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetasn;                                                                // Угол наклона траектории БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при снижении БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                     // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                           // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                           // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                           // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                      // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                        // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                       // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись n-й точки в фильм
            
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}

		//

		if (init_34 == true)                                                                         // Если инициализация исходных значений параметров разрешена при снижении до заданной высоты после разворота
		{
			Vish_34 = Vn;                                                                            // Задание исходной скорости БпЛА в начале снижения до заданной высоты после разворота
			Hish_34 = hn;                                                                            // Задание исходной высоты БпЛА в начале снижения до заданной высоты после разворота
			tetaish_34 = tetan;                                                                      // Задание исходного угла наклона траектории БпЛА в начале снижения до заданной высоты после разворота
			init_34 = false;                                                                         // Запрет инициализации исходных значений параметров в начале снижения до заданной высоты после разворота
		}

		Tsn = (Hsn_1 - Hish_34) / (0.5 * (Vish_34 + 1.1 * Vish_33) * sin(0.5 * (tetaish_34)));       // Расчет интервала времени снижения БпЛА до заданной высоты после разворота
		Nsn = (size_t) ceil(Tsn / dt);                                                               // Расчет количества отсчетов времени снижения БпЛА до заданной высоты после разворота
		dV = (1.1 * Vish_33 - Vish_34) / Nsn;                                                        // Шаг изменения скорости полета БпЛА после начала снижения до половины разницы между текущей и заданной высотами БпЛА
		dteta = tetaish_34 / Nsn;	                                                                 // Расчет шага изменения угла наклона траектории БпЛА при снижении после разворота

		while ((hn > Hsn_1))                                                                         // До тех пор, пока рассчитываемая высота БпЛА будет больше или равна заданной высоте
		{
			if (init_35 == false)                                                                    // Если уже рассчитывается горизонтирование после доворота
			{
				break;                                                                               // Стоп
			}

			if (Vn < 1.1 * Vish_33)                                                                  // Если скорость БпЛА в n-й момент времени меньше 1,1 скорости полета в начале снижения
			{
				Vn = Vnm1 + dV;                                                                      // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn >= 1.1 * Vish_33)                                                                 // Если скорость БпЛА в n-й момент времени больше или равна 1,1 скорости полета в начале снижения
			{
				Vn = 1.1 * Vish_33;                                                                  // Скорость БпЛА в n-й момент времени приравнивается к 1,1 скорости полета в начале снижения
			}

			if (tetan < (0.5 / dt) * dteta)                                                                   // Если угол наклона траектории БпЛА в n-й момент времени меньше 5 шагов изменения угла наклона траектории при снижении БпЛА после разворота
			{
				tetan = tetanm1 - dteta;                                                             // Угол снижения высоты БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории БпЛА при снижении высоты после разворота
			}

			if (tetan >= (0.5 / dt) * dteta)                                                                  // Если угол наклона траектории БпЛА в n-й момент времени больше или равен 5 шаам изменения угла наклона траектории при снижении БпЛА после разворота
			{
				tetan = (0.5 / dt) * dteta;                                                                   // Угол наклона траектории БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла наклона траектории при снижении БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                              // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                              // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                           // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                 // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                 // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                 // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                            // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                         // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                        // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);   // Запись в фильм n-й точки
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                              // Запись n-й точки в вектор

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                    // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                          // Продолжение полета БпЛА
			}
		}
	}

	if (init_33 == false)
	{
	
	// Горизонтирование БпЛА и набор заданной скорости //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (init_35 == true)                                                                    // Если инициализация исходных значений параметров разрешена при горизонтировании БпЛА и наборе заданной скорости после достижения заданной высоты
		{
			Vish_35 = Vn;                                                                       // Задание исходной скорости БпЛА в начале набора заданной скорости
			tetaish_35 = tetan;                                                                 // Задание исходного угла наклона траектории БпЛА в начале набора заданной скорости
			init_35 = false;                                                                    // Запрет инициализации исходных значений параметров в начале набора заданной скорости
		}

		if (abs(Vkres - Vish_35) <= 1.0)                                                        // Если модуль разности заданной и исходной скорости меньше или равен 1 м/с
		{
			dV = (Vkres - Vish_35) / (0.1 / dt);                                                       // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 1 такта (0.5 с)
		}
		else
			if (abs(Vkres - Vish_35) > 1.0 && abs(Vkres - Vish_35) <= 25.0)                     // Если модуль разности заданной и исходной скорости меньше или равен 25 м/с
			{
				dV = (Vkres - Vish_35) / (2.0 / dt);                                                  // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 20 тактов (2 с)
			}
		else                                                                                    // В противном случае
			if ((abs(Vkres - Vish_35) > 25.0) && (abs(Vkres - Vish_35) <= 100.0))               // Если модуль разности заданной и исходной при горизонтировании скорости больше 25 м/с и меньше или равен 100 м/с
			{
				dV = (Vkres - Vish_35) / (5.0 / dt);                                                  // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 50 тактов (5 с)
			}
			else                                                                                // В противном случае
				if ((abs(Vkres - Vish_35) > 100.0) && (abs(Vkres - Vish_35) <= 200.0))          // Если модуль разности заданной и исходной при горизонтировании скорости больше 100 м/с и меньше или равен 200 м/с
				{
					dV = (Vkres - Vish_35) / (10.0 / dt);                                             // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 100 тактов (10 с)
				}
				else                                                                            // В противном случае
					if (abs(Vkres - Vish_35) > 200.0)                                           // Если модуль разности заданной и исходной при горизонтировании скорости больше 200 м/с
					{
						dV = (Vkres - Vish_35) / (20.0 / dt);                                         // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 200 тактов (20 с)
					}

		dteta = tetaish_35 / (0.3 / dt);                                                               // Шаг изменения угла наклона траектории БпЛА при наборе заданной скорости

		while ((Vn != Vkres) || (tetan != 0.0))                                                 // До тех пор, пока текущая скорость БпЛА не равна крейсерской или текущий угол наклона траектории не равен нулю
		{

			if (abs(Vn - Vkres) > abs(dV))                                                      // Если модуль разности текущей скорости и крейсерской скорости после снижения больше модуля шага изменения скорости
			{
				Vn = Vnm1 + dV;                                                                 // Расчет скорости БпЛА в n-й момент времени
			}
			else                                                                                // В противном случае
			{
				Vn = Vkres;                                                                     // Текущая скорость БпЛА приравнивается к крейсерской скорости
			}

			if (tetan < 0.0)                                                                    // Если угол наклона траектории БпЛА в n-й момент времени меньше нуля
			{
				tetan = tetanm1 - dteta;                                                        // Расчет угла наклона траектории БпЛА в n-й момент времени
			}

			if (tetan >= 0)                                                                     // Если угол наклона траектории БпЛА в n-й момент времени больше или равен нулю
			{
				tetan = 0.0;                                                                    // Угол наклона траектории БпЛА в n-й момент времени приравнивается к нулю
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                         // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                         // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                      // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                            // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                            // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                            // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                       // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                        // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                       // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования и набора заданной скорости в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение горизонтирования и набора заданной скорости
			}
		}

	}
	
	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Вышел в район аэродрома");                // Запись в фильм комментария
    
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	init_24 = true;                                                                      // Разрешение инициализации исходных значений параметров при развороте БпЛА в ходе полета в район аэродрома
	init_25 = true;                                                                      // Разрешение инициализации исходных значений параметров при горизонтировании БпЛА после разворота
	init_26 = true;                                                                      // Разрешение инициализации исходных значений параметров при наборе заданной скорости (по ситуации)
	init_29 = true;                                                                      // Разрешение инициализации исходных значений параметров при наборе высоты БпЛА до среднего значения текущей и заданной высот после разворота
	init_30 = true;                                                                      // Разрешение инициализации исходных значений параметров при наборе заданной высоты БпЛА после разворота
	init_31 = true;                                                                      // Разрешение инициализации исходных значений параметров при горизонтировании и наборе заданной скорости БпЛА после достижения заданной высоты
	init_32 = true;                                                                      // Разрешение инициализации исходных значений параметров при полете БпЛА с доворотом на точку
	init_33 = true;                                                                      // Разрешение инициализации исходных значений параметров при снижении высоты до среднего значения текущей и заданной высот
	init_34 = true;                                                                      // Разрешение инициализации исходных значений параметров при снижении высоты до заданной высоты
	init_35 = true;                                                                      // Разрешение инициализации исходных значений параметров при горизонтировании БпЛА и наборе заданной скорости после достижения заданной высоты
	init_40 = true;                                                                      // Разрешение инициализации исходных значений параметров при определении условной заданной точки в районе аэродрома

	F_n = 0;                                                                             // Установление текущего отсчета положения БпЛА в 0

	return 1;                                                                            // Окончание полета БпЛА в район аэродрома

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////// Модель захода БпЛА на посадку //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Zahod_na_posadku()

{
	
	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                  // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                       // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Обновление параметров с интервалом 1 с

	double xnm1 = plane.curPos.x;                                        // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                        // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                        // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                      // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                      // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                      // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                    // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                  // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                  // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах
		
	//

	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                                           // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                                           // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                                                 // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                                                 // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                                                 // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double xgn = xgnm1;                                                   // Задание начального значения координаты xg БпЛА в местной СК в в n-й момент времени
	double ygn = ygnm1;                                                   // Задание начального значения координаты yg БпЛА в местной СК в в n-й момент времени
	double zgn = zgnm1;                                                   // Задание начального значения координаты zg БпЛА в местной СК в в n - й момент времени

	double xn = xnm1;                                                     // Задание начального значения координаты x БпЛА в геоцентрической СК в в n-й момент времени
	double yn = ynm1;                                                     // Задание начального значения координаты y БпЛА в геоцентрической СК в в n-й момент времени
	double zn = znm1;                                                     // Задание начального значения координаты z БпЛА в геоцентрической СК в в n-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                      // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                    // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                   // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                    // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double Bn = Bnm1;                                                     // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                     // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                     // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                   // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);    // Расчет скорости БпЛА в (n-1)-й момент времени
	double Vn = Vnm1;                                                     // Задание начального значения скорости БпЛА в n-й момент времени

	// Приведение kursnm1 к интервалу от 0 до 2 пи

	if (kursnm1 >= 2 * Pi)
	{
		kursnm1 = kursnm1 - 2 * Pi;
	}

	if (kursnm1 < 0)
	{
		kursnm1 = kursnm1 + 2 * Pi;
	}

	//

	double kursn = kursnm1;                                               // Задание начального значения угла поворота траектории БпЛА при развороте в n-й момент времени
	double tetan = tetanm1;                                               // Задание начального значения угла наклона траектории БпЛА при развороте в n-й момент времени
	double gamn = gamnm1;                                                 // Задание начального значения угла скоростного крена БпЛА при развороте в n-й момент времени

	//

	// Первый разворот //

	if (init_41 == true)                                                 // Если инициализация исходных значений параметров разрешена при первом развороте
	{
		kursish_41 = kursnm1;                                            // Задание исходного угла поворота траектории БпЛА в начале первого разворота
		tetaish_41 = tetanm1;                                            // Задание исходного угла наклона траектории БпЛА в начале первого разворота
		Vish_41 = Vnm1;                                                  // Задание исходной скорости БпЛА в начале первого разворота
		Hish_41 = hnm1;                                                  // Задание исходной высоты БпЛА в начале первого разворота
		
		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал заход на посадку");         // Запись в фильм комментария

		init_41 = false;                                                 // Запрет инициализации исходных значений параметров при первом развороте
	}
			
	double kursvz = plane.kursvz * Pi / 180.0;                           // Задание курса взлета БпЛА
	
	// Приведение kursvz в пределы от 0 до 2 пи //
		
	if (abs(kursvz) >= 2 * Pi)
	{
		kursvz = kursvz - 2 * Pi * floor(kursvz / (2 * Pi));
	}

	if (kursvz < 0)
	{
		kursvz = kursvz + 2 * Pi;
	}

	//

	double kzah = kursvz + Pi;                                      // Определение угла захода на посадку
	
	// Приведение kzah в пределы от 0 до 2 пи //

	if (kzah >= 2 * Pi)
	{
		kzah = kzah - 2 * Pi;
	}

	//

	double ugolraz = kzah - kursish_41;                              // Вычисление угла разворота
	
	//
		
	double Vsv = plane.ttx_bpla.V_sv;                                     // Задание скорости сваливания БпЛА
	double krenmax = plane.ttx_bpla.kren_max;                             // Задание максимально допустимого угла крена БпЛА

	// Задание значения шага изменения угла поворота траектории БпЛА //

	double dkurs = 0.0;                                              // Задание начального значения шага изменения угла поворота траектории БпЛА при первом развороте для достижения нужного курса захода на посадку

	if (ugolraz > 0)
	{
		dkurs = dt * Pi / 180.0;                                 // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте (для первого разворота)
	}
	else
		{
		dkurs = -dt * Pi / 180.0;                                // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте (для первого разворота)
		}

	
	size_t Nraz = (size_t)floor(ugolraz / dkurs);                   // Расчет количества отсчетов времени разворота БпЛА
	double Traz = Nraz * dt;                                        // Расчет интервала времени разворота БпЛА
	
	double nraz = ugolraz / dkurs - (double)Nraz;                   // Расчет остатка времени от округления при расчете количества отсчетов времени разворота
	double dobk = nraz * dkurs;                                     // Расчет изменения угла поворота траектории за остаток времени
	double dteta = 0.0;                                             // Задание шага изменения угла наклона траектории БпЛА

	if ((cur_F_n > Nraz) && (F_n < Nraz))                           // Если номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разворота БпЛА, а текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		cur_F_n = Nraz;                                             // Номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени разворота БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)                                 // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
	{
		if (cur_F_n > Nraz)                                         // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разбега БпЛА
		{
			break;                                                  // Стоп
		}

		if (F_n == (Nraz - 1))                                      // Если текущий отсчет времени равен (Nraz - 1)
		{
			dkurs = dkurs + dobk;                                   // Расчет шага изменения угла поворота траектории БпЛА при развороте в (Nraz - 1)-й момент времени (с учетом добавки)
		}

		kursn = kursnm1 + dkurs;                                    // Расчет значения угла поворота траектории БпЛА при развороте в n-й момент времени

		// Приведение kursn в пределы от 0 до 2 пи //
				
		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}
		
		//

		double Vxgn = Vn * cos(tetan) * sin(kursn);                // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                             // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		gamn = atan(dkurs * Vn * cos(tetan) / (dteta * Vn + dt * Settings.getEarthGravity() * cos(tetan))); // Расчет угла скоростного крена БпЛА при развороте в n-й момент времени в радианах

		F_LastTime = F_LastTime + dt;                                                       // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn != Hish_41)                                                                  // Если высота БпЛА в n-й момент времени не равна исходной высоте Hish_41
		{
			hn = Hish_41;                                                                   // Текущая высота БпЛА приравнивается к исходной высоте Hish_41

			CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                               // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                               // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                         // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Обновление параметров с интервалом 0,1 с

		kursnm1 = kursn;
		tetanm1 = tetan;

		//

		// Определение значения скоростного крена БпЛА в n-й момент времени

		double gamn0 = 0.0;

		if ((F_n >= 0) && (F_n < 2 / dt))
		{
			double gamnmax = gamn * 180.0 / Pi;
			double dgam = gamnmax / (2 / dt);
			double gamman = gamn0 + F_n * dgam;

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);          // Запись в фильм n-й точки
           
			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки
		}
		else
			if ((F_n >= 2 / dt) && (F_n <= Nraz - (2 / dt)))
			{
				double gamman = gamn * 180.0 / Pi;

				Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);    // Запись в фильм n-й точки
               
				// Запись параметров движения БпЛА

				plane.curPos.time = F_LastTime;
				plane.curPos.x = xn;
				plane.curPos.y = yn;
				plane.curPos.z = zn;
				plane.curPos.vx = Vxn;
				plane.curPos.vy = Vyn;
				plane.curPos.vz = Vzn;
				plane.curPos.fi = kursn;
				plane.curPos.teta = tetan;
				plane.curPos.gamma = gamman * Pi / 180.0;

				plane.Trajectory.push_back(plane.curPos);                                                    // Запись в вектор n-й точки
			}
			else
				if ((F_n > Nraz - (2 / dt)) && (F_n <= Nraz))
				{
					double gamnmax = gamn * 180.0 / Pi;
					double dgam = gamnmax / (2 / dt);
					double gamman = gamnmax - (F_n - (Nraz - (2 / dt))) * dgam;

					Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки
                   
					// Запись параметров движения БпЛА

					plane.curPos.time = F_LastTime;
					plane.curPos.x = xn;
					plane.curPos.y = yn;
					plane.curPos.z = zn;
					plane.curPos.vx = Vxn;
					plane.curPos.vy = Vyn;
					plane.curPos.vz = Vzn;
					plane.curPos.fi = kursn;
					plane.curPos.teta = tetan;
					plane.curPos.gamma = gamman * Pi / 180.0;

					plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки
				}

		//

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		//
				
	}

	if (F_n < Nraz)                                                                                       // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		return 0;                                                                                         // Продолжение полета БпЛА
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	// Горизонтирование БпЛА и набор заданной скорости //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	cur_F_n = F_n + deltaF;                                                                  // Номер отсчета времени полета БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (init_42 == true)                                                                     // Если инициализация исходных значений параметров разрешена при горизонтировании и наборе заданной скорости БпЛА
	{
		Vish_42 = Vn;                                                                        // Задание исходной скорости БпЛА в начале горизонтирования и набора заданной скорости
		tetaish_42 = tetan;                                                                  // Задание исходного угла наклона траектории БпЛА в начале горизонтирования и набора заданной скорости
		Hish_42 = hn;                                                                        // Задание исходной высоты БпЛА в начале горизонтирования и набора заданной скорости
		
		init_42 = false;                                                                     // Запрет инициализации исходных значений параметров при горизонтировании и наборе заданной скорости
	}

	double Vpolraz = plane.ttx_bpla.V_kres;                                                       // Задание скорости полета БпЛА после первого разворота
	double dV = 0.0;                                                                         // Задание шага изменения скорости БпЛА

	if (abs(Vpolraz - Vish_42) <= 1.0)                                                       // Если модуль разности заданной и исходной скорости меньше или равен 1 м/с
	{
		dV = (Vpolraz - Vish_42) / (0.1 / dt);                                                      // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 1 такта (0.5 с)
	}
	else
		if (abs(Vpolraz - Vish_42) > 1.0 && abs(Vpolraz - Vish_42) <= 25.0)                  // Если модуль разности заданной и исходной скорости меньше или равен 25 м/с
		{
			dV = (Vpolraz - Vish_42) / (2.0 / dt);                                                 // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 20 тактов (2 с)
		}
	else                                                                                     // В противном случае
		if ((abs(Vpolraz - Vish_42) > 25.0) && (abs(Vpolraz - Vish_42) <= 100.0))            // Если модуль разности заданной и исходной при горизонтировании скорости больше 25 м/с и меньше или равен 100 м/с
		{
			dV = (Vpolraz - Vish_42) / (5.0 / dt);                                                 // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 50 тактов (5 с)
		}
		else                                                                                 // В противном случае
			if ((abs(Vpolraz - Vish_42) > 100.0) && (abs(Vpolraz - Vish_42) <= 200.0))       // Если модуль разности заданной и исходной при горизонтировании скорости больше 100 м/с и меньше или равен 200 м/с
			{
				dV = (Vpolraz - Vish_42) / (10.0 / dt);                                            // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 100 тактов (10 с)
			}
			else                                                                             // В противном случае
				if (abs(Vpolraz - Vish_42) > 200.0)                                          // Если модуль разности заданной и исходной при горизонтировании скорости больше 200 м/с
				{
					dV = (Vpolraz - Vish_42) / (20.0 / dt);                                        // Расчет шага изменения скорости полета БпЛА на заданной высоте исходя из 200 тактов (20 с)
				}

	dteta = tetaish_42 / (0.3 / dt);                                                                // Шаг изменения угла наклона траектории БпЛА при наборе заданной скорости

	while ((Vn != Vpolraz) || (tetan != 0.0))                                                // До тех пор, пока текущая скорость БпЛА не равна заданной или текущий угол наклона траектории не равен нулю
	{
		
		if (init_44 == false || init_45 == false || init_46 == false || init_47 == false || init_48 == false || init_49 == false || init_50 == false || init_51 == false)   // Если уже рассчитывается горизонтирование после доворота
		{
			break;                                                                           // Стоп
		}

		
		if (abs(Vn - Vpolraz) > abs(dV))                                                     // Если модуль разности текущей скорости и заданной скорости больше модуля шага изменения скорости
		{
			Vn = Vnm1 + dV;                                                                  // Расчет скорости БпЛА в n-й момент времени
		}
		else                                                                                 // В противном случае
		{
			Vn = Vpolraz;                                                                    // Текущая скорость БпЛА приравнивается к заданной скорости
		}

		if (tetan < 0.0)                                                                     // Если угол наклона траектории БпЛА в n-й момент времени меньше нуля
		{
			tetan = tetanm1 - dteta;                                                         // Расчет угла наклона траектории БпЛА в n-й момент времени
		}

		if (tetan >= 0)                                                                      // Если угол наклона траектории БпЛА в n-й момент времени больше или равен нулю
		{
			tetan = 0.0;                                                                     // Угол наклона траектории БпЛА в n-й момент времени приравнивается к нулю
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);                                          // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                          // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                       // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                             // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                             // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                             // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                        // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                              // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                             // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                              // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn != Hish_42)                                                                   // Если высота БпЛА в n-й момент времени не равна исходной высоте Hish_42
		{
			hn = Hish_42;                                                                    // Текущая высота БпЛА приравнивается к исходной высоте Hish_42

			CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = 0.0;                                                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
      
		// Обновление параметров через 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

		//
				
		//

		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования и набора заданной скорости в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Полет БпЛА до точки, из которой условная точка визируется под прямым углом, для вычисления радиуса второго разворота //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	CPointGlobal p2 = plane.object.getPoint(0);                // Расчет координат аэродрома (2-й точки) в геоцентрической СК

	double x2 = p2.getPosition().getX();                       // Определение координаты x 2-й точки в геоцентрической СК
	double y2 = p2.getPosition().getY();                       // Определение координаты y 2-й точки в геоцентрической СК
	double z2 = p2.getPosition().getZ();                       // Определение координаты z 2-й точки в геоцентрической СК

	CPointGeo pg2 = p2.toPointGeo();                           // Преобразование точки pg2 из геоцентрической СК в геодезическую СК

	double B2 = pg2.getLatitude();                             // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double L2 = pg2.getLongitude();                            // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double h2 = pg2.getAltitude();                             // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	if (h2 != Hsn_1)                                           // Если высота расположения начальной точки отлична от Hsn_2
	{
		h2 = Hsn_1;                                            // Высота начальной точки приравнивается Hsn_2
	}

	pg2 = CPointGeo(p2.getTime(), B2, L2, h2);                 // Создание точки pg2 в геодезической СК со скорректированной высотой
	p2 = pg2.toPointGlobal();                                  // Перевод точки pg2 в геоцентрическую СК

	x2 = p2.getPosition().getX();                              // Определение координаты x 2-й точки в геоцентрической СК
	y2 = p2.getPosition().getY();                              // Определение координаты y 2-й точки в геоцентрической СК
	z2 = p2.getPosition().getZ();                              // Определение координаты z 2-й точки в геоцентрической СК

	if (init_43 == true)                                       // Если инициализация исходных значений параметров разрешена при вычислении радиуса второго разворота
	{
						
		CPointLocal result2 = p2.toPointLocal(zentrnm1);                                 // Перевод точки p2 из геоцентрической СК в местную СК

		double xg2r = result2.getPosition().getX() - 50000.0 * sin(kursvz);              // Задание координаты xg условной точки в местной СК 
		double yg2r = result2.getPosition().getY() - 50000.0 * cos(kursvz);              // Задание координаты yg условной точки в местной СК
		double zg2r = result2.getPosition().getZ();                                      // Задание координаты zg условной точки в местной СК

		CPointLocal res2 = CPointLocal(p2.getTime(), CPoint3D(xg2r, yg2r, zg2r));        // Создание условной точки в местной СК 
		CPointGlobal resgeo2 = res2.toPointGlobal(zentrnm1);                             // Преобразование созданной точки из местной СК в геоцентрическую СК

		double x2r = resgeo2.getPosition().getX();                                       // Определение координаты x условной точки в геоцентрической СК
		double y2r = resgeo2.getPosition().getY();                                       // Определение координаты y условной точки в геоцентрической СК
		double z2r = resgeo2.getPosition().getZ();                                       // Определение координаты z условной точки в геоцентрической СК

		double frn = atan((xg2r - xgn) / (yg2r - ygn));                    // Расчет угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени

		// Пересчет значения угла визирования в горизонтальной плоскости условной точки из 1 точки //

		if (((xg2r - xgn) >= 0.0) && ((yg2r - ygn) >= 0.0))
		{
			frn = frn;
		}
		else
			if (((xg2r - xgn) >= 0.0) && ((yg2r - ygn) < 0.0))
			{
				frn = frn + Pi;
			}
			else
				if (((xg2r - xgn) < 0.0) && ((yg2r - ygn) >= 0.0))
				{
					frn = frn + 2 * Pi;
				}
				else
					if (((xg2r - xgn) < 0.0) && ((yg2r - ygn) < 0.0))
					{
						frn = frn + Pi;
					}

		//

		double xgrnm1 = xgn;                                             // Определение координаты xgr БпЛА в (n-1)-й момент времени
		double ygrnm1 = ygn;                                             // Определение координаты ygr БпЛА в (n-1)-й момент времени
		double zgrnm1 = zgn;                                             // Определение координаты zgr БпЛА в (n-1)-й момент времени

		double xgrn = xgrnm1;                                            // Определение координаты xgr БпЛА в (n-1)-й момент времени
		double ygrn = ygrnm1;                                            // Определение координаты ygr БпЛА в (n-1)-й момент времени
		double zgrn = zgrnm1;                                            // Определение координаты zgr БпЛА в (n-1)-й момент времени

		double xrn = xnm1;                                               // Задание начального значения координаты x БпЛА в геоцентрической СК в в n-й момент времени для вычисления радиуса разворота
		double yrn = ynm1;                                               // Задание начального значения координаты y БпЛА в геоцентрической СК в в n-й момент времени для вычисления радиуса разворота
		double zrn = znm1;                                               // Задание начального значения координаты z БпЛА в геоцентрической СК в в n-й момент времени для вычисления радиуса разворота

		double time = 0.0;

		size_t k = 1;
		
		while (abs(abs((frn - kursvz) - floor((frn - kursvz) / (Pi)) * Pi) - Pi / 2.0) >= Pi / 360.0)  // До тех пор, пока разность угла визирования в горизонтальной плоскости и угла взлета больше 0,5 градуса
		{

			double Vk = Vnm1 / 10.0;                                     // Расчет скорости БпЛА в n-й момент времени

			double Vxgn = Vk * cos(tetan) * sin(kursn);                  // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vk * cos(tetan) * cos(kursn);                  // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vk * sin(tetan);                               // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgrn = xgrnm1 + Vxgn * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygrn = ygrnm1 + Vygn * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgrn = zgrnm1 + Vzgn * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			frn = atan((xg2r - xgrn) / (yg2r - ygrn));                   // Расчет угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени
			
			// Пересчет значения угла визирования в горизонтальной плоскости условной точки из 1 точки //

			if (((xg2r - xgrn) >= 0.0) && ((yg2r - ygrn) >= 0.0))
			{
				frn = frn;
			}
			else
				if (((xg2r - xgrn) >= 0.0) && ((yg2r - ygrn) < 0.0))
				{
					frn = frn + Pi;
				}
				else
					if (((xg2r - xgrn) < 0.0) && ((yg2r - ygrn) >= 0.0))
					{
						frn = frn + 2 * Pi;
					}
					else
						if (((xg2r - xgrn) < 0.0) && ((yg2r - ygrn) < 0.0))
						{
							frn = frn + Pi;
						}

			//
			time = time + dt;                                                     // Задание отсчетов времени

			CPointLocal res2 = CPointLocal(time, CPoint3D(xgrn, ygrn, zgrn));     // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo2 = res2.toPointGlobal(zentrnm1);                  // Преобразование созданной точки из местной СК в геоцентрическую СК

			xrn = resgeo2.getPosition().getX();                                   // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yrn = resgeo2.getPosition().getY();                                   // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zrn = resgeo2.getPosition().getZ();                                   // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			R = sqrt((xrn - x2r) * (xrn - x2r) + (yrn - y2r) * (yrn - y2r) + (zrn - z2r) * (zrn - z2r)) / 2;

			if (R < 100)
			{
				R = 100;                                                          // Задание радиуса второго разворота

				break;
			}

			// Обновление параметров //

			xgrnm1 = xgrn;
			ygrnm1 = ygrn;
			zgrnm1 = zgrn;

			//
			
			k++;
		}

		if (R != 100)
		{
			R = sqrt((xrn - x2r) * (xrn - x2r) + (yrn - y2r) * (yrn - y2r) + (zrn - z2r) * (zrn - z2r)) / 2;    // Вычисление радиуса второго разворота
		}

		R1 = R;

		if (R < Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(1.5 * krenmax * Pi / 180.0)))                                   // Если радиус второго разворота меньше, чем радиус при скоростном крене БпЛА 30 градусов
		{
			R = Vnm1 * Vnm1 / (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0));                                         // Радиус приравнивается к радиусу при скоростном крене БпЛА 30 градусов
			R2 = R;
		}

		init_43 = false;                                                                                        // Запрет инициализации исходных значений параметров при вычислении радиуса второго разворота
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Полет до условной точки второго разворота //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	if (init_47 == true)                                                   // Если инициализация исходных значений параметров разрешена при полете до условной точки второго разворота
	{
		Hish_47 = hn;                                                      // Задание исходной высоты БпЛА в начале полета до условной точки второго разворота

		CPointLocal result2 = p2.toPointLocal(zentrnm1);                   // Перевод точки p2 из геоцентрической СК в местную СК

		double xg2u = result2.getPosition().getX() - 10.0 * plane.ttx_bpla.H_kres * sin(kursvz);             // Определение координаты xg условной точки в местной СК 
		double yg2u = result2.getPosition().getY() - 10.0 * plane.ttx_bpla.H_kres * cos(kursvz);             // Определение координаты yg условной точки в местной СК

		if (plane.ttx_bpla.H_kres > 5000.0)
		{
			xg2u = result2.getPosition().getX() - 10.0 * plane.ttx_bpla.H_kres * sin(kursvz);              // Определение координаты xg условной точки в местной СК 
			yg2u = result2.getPosition().getY() - 10.0 * plane.ttx_bpla.H_kres * cos(kursvz);              // Определение координаты yg условной точки в местной СК
		}
		
		double zg2u = result2.getPosition().getZ();                                      // Определение координаты zg условной точки в местной СК

		CPointLocal res2 = CPointLocal(p2.getTime(), CPoint3D(xg2u, yg2u, zg2u));        // Создание условной точки в местной СК 
		CPointGlobal resgeo2 = res2.toPointGlobal(zentrnm1);                             // Преобразование созданной точки из местной СК в геоцентрическую СК

		x2u = resgeo2.getPosition().getX();                                              // Определение координаты x условной точки в геоцентрической СК
		y2u = resgeo2.getPosition().getY();                                              // Определение координаты y условной точки в геоцентрической СК
		z2u = resgeo2.getPosition().getZ();                                              // Определение координаты z условной точки в геоцентрической СК
				
		Da = sqrt(((x2u - xn) * (x2u - xn) + (y2u - yn) * (y2u - yn) + (z2u - zn) * (z2u - zn)) - 4 * R1 * R1);   // Исходное расстояние до условной точки
		
		//
			   		
		init_47 = false;                                                   // Запрет инициализации исходных значений параметров при полете до условной точки второго разворота
	}
	
	double Dn = sqrt(((x2u - xn) * (x2u - xn) + (y2u - yn) * (y2u - yn) + (z2u - zn) * (z2u - zn)) - 4 * R1 * R1);  // Расчет расстояния от точки в n-й момент времени до проекции условной точки на линию полета БпЛА
		
	if (Da < 20000.0)
	{
		while (Dn > 2.0 * Vn * dt + Hish_47)                               // До тех пор, пока расстояние от точки в n-й момент времени до условной точки больше 2 * Vn * dt
		{
			if (init_44 == false || init_45 == false || init_46 == false || init_48 == false || init_49 == false || init_50 == false || init_51 == false)    // Если уже рассчитываются дальнейшие этапы полета
			{
				break;                                                     // Стоп
			}

			Vn = Vnm1;                                                     // Расчет скорости БпЛА в n-й момент времени

			double Vxgn = Vn * cos(tetan) * sin(kursn);                    // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                    // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                 // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                       // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                       // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                       // Расчет координаты zg БпЛА в местной СК в n-й момент времени
						
			//

			F_LastTime = F_LastTime + dt;                                  // Задание отсчетов времени
						
			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

			if (hn != Hish_47)                                             // Если текущая высота БпЛА в n-й момент времени не равна исходной высоте Hish_47
			{
				hn = Hish_47;                                              // Текущая высота БпЛА приравнивается к исходной высоте Hish_47

				CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			Dn = sqrt(((x2u - xn) * (x2u - xn) + (y2u - yn) * (y2u - yn) + (z2u - zn) * (z2u - zn)) - 4 * R1 * R1);    // Расчет расстояния от точки в n-й момент времени до проекции условной точки на линию полета БпЛА

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                  // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
			
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования и набора заданной скорости в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Второй разворот //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_44 == true)                                                                           // Если инициализация исходных значений параметров разрешена при втором развороте
	{
		kursish_44 = kursn;                                                                        // Задание исходного угла поворота траектории БпЛА в начале второго разворота
		tetaish_44 = tetan;                                                                        // Задание исходного угла наклона траектории БпЛА в начале второго разворота
		Vish_44 = Vn;                                                                              // Задание исходной скорости БпЛА в начале второго разворота
		Hish_44 = hn;                                                                              // Задание исходной высоты БпЛА в начале второго разворота

		Nish_44 = F_n;                                                                             // Исходное значение отсчета моделирования в начале второго разворота 
		
		// Задание значения шага изменения угла поворота траектории БпЛА //
		
		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                          // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                                    // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                                   // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                                    // Определение высоты БпЛА в n-й момент времени в геодезической СК

		CPointLocal result1 = pn.toPointLocal(zentrnm1);                                           // Перевод точки pno из геоцентрической СК в местную СК

		xgn = result1.getPosition().getX();                                                        // Определение координаты xg БпЛА в местной СК в n-й момент времени
		ygn = result1.getPosition().getY();                                                        // Определение координаты yg БпЛА в местной СК в n-й момент времени
		zgn = result1.getPosition().getZ();                                                        // Определение координаты zg БпЛА в местной СК в n-й момент времени

		CPointGlobal p2o = CPointGlobal(F_LastTime, CPoint3D(x2, y2, z2));                         // Создание точки pno в n-й момент времени в геоцентрической СК

		CPointLocal result2 = p2o.toPointLocal(zentrnm1);                                          // Перевод точки pno из геоцентрической СК в местную СК

		double xg2 = result2.getPosition().getX();                                                 // Определение координаты xg БпЛА в местной СК в n-й момент времени
		double yg2 = result2.getPosition().getY();                                                 // Определение координаты yg БпЛА в местной СК в n-й момент времени
		double zg2 = result2.getPosition().getZ();                                                 // Определение координаты zg БпЛА в местной СК в n-й момент времени
		
		double fkt = atan((xg2 - xgn) / (yg2 - ygn));                                              // Расчет угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени

			// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

		if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
		{
			fkt = fkt;
		}
		else
			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
			{
				fkt = fkt + Pi;
			}
			else
				if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
				{
					fkt = fkt + 2 * Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
					{
						fkt = fkt + Pi;
					}

		// Задание значения шага изменения угла поворота траектории БпЛА //

		double Lnr = Ln;
		double L2r = L2;
		double Bnr = Bn + 90.0;
		double B2r = B2 + 90.0;

		if (Ln >= 0.0)
		{
			Lnr = Ln;
		}
		else
			if (Ln < 0.0)
			{
				Lnr = Ln + 360.0;
			}

		if (L2 >= 0.0)
		{
			L2r = L2;
		}
		else
			if (L2 < 0.0)
			{
				L2r = L2 + 360.0;
			}

		if (abs(Lnr - L2r) >= 180.0 && Lnr < L2r)
		{
			L2r = L2r - 360.0;
		}

		if (abs(Lnr - L2r) >= 180.0 && Lnr > L2r)
		{
			Lnr = Lnr - 360.0;
		}

		if (abs(Lnr - L2r) < 180.0 && Lnr < L2r)
		{
			L2r = L2r;
		}

		if (abs(Lnr - L2r) < 180.0 && Lnr > L2r)
		{
			Lnr = Lnr;
		}
			   
		if (((Bnr >= B2r) && (Lnr < L2r) && (kursvz >= fkt) && (kursvz <= Pi)) ||
			((Bnr >= B2r) && (Lnr < L2r) && (kursvz >= Pi) && (kursvz <= fkt + Pi)) ||
			((Bnr >= B2r) && (Lnr >= L2r) && (kursvz >= 0.0) && (kursvz <= fkt - Pi)) ||
			((Bnr >= B2r) && (Lnr >= L2r) && (kursvz >= fkt) && (kursvz <= 2 * Pi)) ||
			((Bnr < B2r) && (Lnr < L2r) && (kursvz >= fkt) && (kursvz <= Pi)) ||
			((Bnr < B2r) && (Lnr < L2r) && (kursvz >= Pi) && (kursvz <= fkt + Pi)) ||
			((Bnr < B2r) && (Lnr >= L2r) && (kursvz >= 0.0) && (kursvz <= fkt - Pi)) ||
			((Bnr < B2r) && (Lnr >= L2r) && (kursvz >= fkt) && (kursvz <= 2 * Pi)))
		{
			dkurs_44 = dt * Vish_44 / R;                                                            // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте (для второго разворота)
		}
		else
			if (((Bnr >= B2r) && (Lnr < L2r) && (kursvz >= 0.0) && (kursvz < fkt)) ||
				((Bnr >= B2r) && (Lnr < L2r) && (kursvz > fkt + Pi) && (kursvz <= 2 * Pi)) ||
				((Bnr >= B2r) && (Lnr >= L2r) && (kursvz > fkt - Pi) && (kursvz <= Pi)) ||
				((Bnr >= B2r) && (Lnr >= L2r) && (kursvz >= Pi) && (kursvz < fkt)) ||
				((Bnr < B2r) && (Lnr < L2r) && (kursvz >= 0.0) && (kursvz < fkt)) ||
				((Bnr < B2r) && (Lnr < L2r) && (kursvz > fkt + Pi) && (kursvz <= 2 * Pi)) ||
				((Bnr < B2r) && (Lnr >= L2r) && (kursvz > fkt - Pi) && (kursvz <= Pi)) ||
				((Bnr < B2r) && (Lnr >= L2r) && (kursvz >= Pi) && (kursvz < fkt)))
			{
				dkurs_44 = -dt * Vish_44 / R;                                                       // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте (для второго разворота)
			}
		
		//

		init_44 = false;                                                                           // Запрет инициализации исходных значений параметров при втором развороте
	}
	
	ugolraz = kursvz - kursish_44;                                           // Вычисление угла разворота

	//
	   
	Nraz = (size_t)floor(abs(ugolraz / dkurs_44));                           // Расчет количества отсчетов времени разворота БпЛА
	Traz = Nraz * dt;                                                        // Расчет интервала времени разворота БпЛА

	nraz = abs(ugolraz / dkurs_44) - (double)Nraz;                           // Расчет остатка времени от округления при расчете количества отсчетов времени разворота
	dobk = nraz * dkurs_44;                                                  // Расчет изменения угла поворота траектории за остаток времени
	dteta = 0.0;                                                             // Расчет шага изменения угла наклона траектории БпЛА

	size_t cur_F_n_44;
	cur_F_n_44 = cur_F_n;

	if ((cur_F_n > Nish_44 + Nraz) && (F_n < Nish_44 + Nraz))                // Если номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разворота БпЛА, а текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		cur_F_n_44 = Nish_44 + Nraz;                                         // Номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени разворота БпЛА
	}
		
	for (F_n; F_n < cur_F_n_44; F_n++)                                       // Для текущих отсчетов времени положения БпЛА, меньших номера отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
	{
		if (cur_F_n_44 > Nish_44 + Nraz)                                     // Если номер отсчета времени разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени разворота БпЛА
		{
			break;                                                           // Стоп
		}

		if (F_n == (Nish_44 + Nraz - 1))                                     // Если текущий отсчет времени равен (Nraz - 1)
		{
			dkurs_44 = dkurs_44 + dobk;                                      // Расчет шага изменения угла поворота траектории БпЛА при развороте в (Nraz - 1)-й момент времени (с учетом добавки)
		}

		kursn = kursnm1 + dkurs_44;                                          // Расчет значения угла поворота траектории БпЛА при развороте в n-й момент времени

		// Приведение kursn к интервалу от 0 до 2 пи
				
		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}
			
		//

		double Vxgn = Vn * cos(tetan) * sin(kursn);                         // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                         // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                      // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                            // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                            // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                            // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		gamn = atan(dkurs_44 * Vn * cos(tetan) / (dteta * Vn + dt * Settings.getEarthGravity() * cos(tetan))); // Расчет угла скоростного крена БпЛА при развороте в n-й момент времени в радианах

		F_LastTime = F_LastTime + dt;                                       // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn != Hish_44)                                                  // Если текущая высота БпЛА в n-й момент времени не равна исходной высоте Hish_44
		{
			hn = Hish_44;                                                   // Текущая высота БпЛА приравнивается к исходной высоте Hish_44

			CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                     // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                     // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                               // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Обновление параметров с интервалом 0,1 с

		kursnm1 = kursn;
		tetanm1 = tetan;

		//

		// Определение значения скоростного крена БпЛА в n-й момент времени

		double gamn0 = 0.0;

		if ((F_n >= Nish_44) && (F_n < Nish_44 + (2 / dt)))
		{
			double gamnmax = gamn * 180.0 / Pi;
			double dgam = gamnmax / (2 / dt);
			double gamman = gamn0 + (F_n - Nish_44) * dgam;

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);           // Запись в фильм n-й точки
          
			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                                          // Запись в вектор n-й точки
		}
		else
			if ((F_n >= Nish_44 + (2 / dt)) && (F_n <= Nish_44 + Nraz - (2 / dt)))
			{
				double gamman = gamn * 180.0 / Pi;

				Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);     // Запись в фильм n-й точки
               
				// Запись параметров движения БпЛА

				plane.curPos.time = F_LastTime;
				plane.curPos.x = xn;
				plane.curPos.y = yn;
				plane.curPos.z = zn;
				plane.curPos.vx = Vxn;
				plane.curPos.vy = Vyn;
				plane.curPos.vz = Vzn;
				plane.curPos.fi = kursn;
				plane.curPos.teta = tetan;
				plane.curPos.gamma = gamman * Pi / 180.0;

				plane.Trajectory.push_back(plane.curPos);                                                    // Запись в вектор n-й точки
			}
			else
				if ((F_n > Nish_44 + Nraz - (2 / dt)) && (F_n <= Nish_44 + Nraz))
				{
					if (R != R2)
					{
						double gamnmax = gamn * 180.0 / Pi;
						double dgam = gamnmax / (2 / dt);
						double gamman = gamnmax - (F_n - (Nish_44 + Nraz - (2 / dt))) * dgam;

						Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки
                       
						// Запись параметров движения БпЛА

						plane.curPos.time = F_LastTime;
						plane.curPos.x = xn;
						plane.curPos.y = yn;
						plane.curPos.z = zn;
						plane.curPos.vx = Vxn;
						plane.curPos.vy = Vyn;
						plane.curPos.vz = Vzn;
						plane.curPos.fi = kursn;
						plane.curPos.teta = tetan;
						plane.curPos.gamma = gamman * Pi / 180.0;

						plane.Trajectory.push_back(plane.curPos);                                                  // Запись в вектор n-й точки
					}
					else
					{
						double gamman = plane.curPos.gamma * 180.0 / Pi;

						Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки
                       
					    // Запись параметров движения БпЛА

						plane.curPos.time = F_LastTime;
						plane.curPos.x = xn;
						plane.curPos.y = yn;
						plane.curPos.z = zn;
						plane.curPos.vx = Vxn;
						plane.curPos.vy = Vyn;
						plane.curPos.vz = Vzn;
						plane.curPos.fi = kursn;
						plane.curPos.teta = tetan;
						plane.curPos.gamma = gamman * Pi / 180.0;

						plane.Trajectory.push_back(plane.curPos);                                                  // Запись в вектор n-й точки
					}
				}

		//

		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		//
				
	}

	if (F_n < Nish_44 + Nraz || deltaF == 0)                                                              // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разворота БпЛА
	{
		return 0;                                                                                         // Продолжение полета БпЛА
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Продолжение второго разворота (в случае разворота со скоростным креном 30 градусов) //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (R == R2)                                                                 // Если радиус второго разворота равен радиусу разворота со скоростным креном 30 градусов
	{
		
		CPointGlobal p2o = CPointGlobal(F_LastTime, CPoint3D(x2, y2, z2));       // Создание точки p2o в n-й момент времени в геоцентрической СК

		CPointLocal result2 = p2o.toPointLocal(zentrnm1);                        // Перевод точки pno из геоцентрической СК в местную СК

		double xg2 = result2.getPosition().getX();                               // Определение координаты xg условной точки в местной СК
		double yg2 = result2.getPosition().getY();                               // Определение координаты yg условной точки в местной СК
		double zg2 = result2.getPosition().getZ();                               // Определение координаты zg условной точки в местной СК

		if (init_48 == true)                                                     // Если инициализация исходных значений параметров разрешена при втором развороте со скоростным креном 30 градусов
		{
			Hish_48 = hn;                                                        // Задание исходной высоты БпЛА в начале второго разворота со скоростным креном 30 градусов
						
			f2_t = atan((xg2 - xgn) / (yg2 - ygn));                              // Расчет исходного угла визирования в горизонтальной плоскости условной точки

			// Пересчет значения угла визирования в горизонтальной плоскости 2 точки из 1 точки //

			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
			{
				f2_t = f2_t;
			}
			else
				if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
				{
					f2_t = f2_t + Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
					{
						f2_t = f2_t + 2 * Pi;
					}
					else
						if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
						{
							f2_t = f2_t + Pi;
						}
			
			//

			fn_t = f2_t;                                                       // Определение начального значения угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени

			init_48 = false;                                                   // Запрет инициализации исходных значений параметров при втором развороте со скоростным креном 30 градусов
		}

		double dkurs = 0.0;                                                    // Задание шага изменения угла поворота траектории БпЛА

		if (dkurs_44 > 0.0)                                                    // Если шаг изменения угла поворота траектории БпЛА dkurs_44 больше 0
		{
			dkurs = (Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;      // Расчет шага изменения угла поворота траектории БпЛА в ходе второго правого разворота со скоростным креном 30 градусов
		}
		else                                                                   // В противном случае
		{
			dkurs = -(Settings.getEarthGravity() * tan(krenmax * Pi / 180.0) / Vnm1) * dt;     // Расчет шага изменения угла поворота траектории БпЛА в ходе второго левого разворота со скоростным креном 30 градусов
		}

		while (abs(abs((kursn - kursvz) - floor((kursn - kursvz) / (Pi / 2.0)) * Pi / 2.0) - Pi / 4.0) >= Pi / 720.0)  // До тех пор, пока разность угла поворота траектории и угла визирования в горизонтальной плоскости больше или равна 45 градусов при точности 0,5 градуса
		{
			if (init_45 == false || init_46 == false || init_49 == false || init_50 == false || init_51 == false)      // Если уже рассчитываются последующие этапы полета
			{
				break;                                                         // Стоп
			}

			Vn = Vnm1;                                                         // Расчет скорости БпЛА в n-й момент времени
			kursn = kursnm1 + dkurs;                                           // Расчет угла поворота траектории БпЛА в n-й момент времени

			// Приведение kursn к интервалу от 0 до 2 пи

			if (kursn >= 2 * Pi)
			{
				kursn = kursn - 2 * Pi;
			}

			if (kursn < 0)
			{
				kursn = kursn + 2 * Pi;
			}

			//

			double Vxgn = Vn * cos(tetan) * sin(kursn);                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                   // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                         // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                         // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                         // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			//

			F_LastTime = F_LastTime + dt;                                   // Задание отсчетов времени

			gamn = atan(dkurs * Vn * cos(tetan) / (dteta * Vn + dt * Settings.getEarthGravity() * cos(tetan))); // Расчет скоростного крена БпЛА при развороте в n-й момент времени в радианах
			
			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                         // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                        // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                         // Определение высоты БпЛА в n-й момент времени в геодезической СК

			if (hn != Hish_48)                                              // Если текущая высота БпЛА в n-й момент времени не равна исходной высоте Hish_48
			{
				hn = Hish_48;                                               // Текущая высота БпЛА приравнивается к исходной высоте Hish_48

				CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}
				
			fn_t = atan((xg2 - xgn) / (yg2 - ygn));                         // Расчет угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени

			// Пересчет значения угла визирования в горизонтальной плоскости условной точки из точки в n-й момент времени //

			if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) >= 0.0))
			{
				fn_t = fn_t;
			}
			else
				if (((xg2 - xgn) >= 0.0) && ((yg2 - ygn) < 0.0))
				{
					fn_t = fn_t + Pi;
				}
				else
					if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) >= 0.0))
					{
						fn_t = fn_t + 2 * Pi;
					}
					else
						if (((xg2 - xgn) < 0.0) && ((yg2 - ygn) < 0.0))
						{
							fn_t = fn_t + Pi;
						}

			//

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени
						
			double gamman = gamn * 180.0 / Pi;                                                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;
			kursnm1 = kursn;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени второго разворота со скоростным креном 30 градусов в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Третий разворот до выхода БпЛА на линию взлета (в случае разворота со скоростным креном 30 градусов) //
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (init_49 == true)                                                                      // Если инициализация исходных значений параметров разрешена при третьем развороте 
		{
			Hish_49 = hn;                                                                         // Задание исходной высоты БпЛА в начале третьего разворота
			
			// Определение шага и направления третьего разворота //

			double a = (R2 * sin(Pi / 4.0) + R2 - 2 * R1);

			double b = (R2 * sin(Pi / 4.0) * (R2 * sin(Pi / 4.0) + R2 - 2 * R1) / (R2 - R2 * sin(Pi / 4.0)));

			double c = sqrt(a * a + b * b);

			double R3 = c * sin((Pi - Pi / 4.0) / 2.0) / sin(Pi / 4.0);

			if (dkurs_44 < 0.0)                                                                   // Если шаг изменения угла поворота траектории dkurs_44 меньше 0 (то есть второй разворот - левый)
			{
				dkurs_49 = Vnm1 * dt / R3;                                                        // Расчет шага изменения угла поворота траектории при третьем правом развороте
			}
			else                                                                                  // В противном случае
			{
				dkurs_49 = -Vnm1 * dt / R3;                                                       // Расчет шага изменения угла поворота траектории при третьем левом развороте
			}

			//

			gamish_49 = plane.curPos.gamma;                                                          // Исходный угол скоростного крена БпЛА в начале третьего разворота в радианах

			gammin = atan(dkurs_49 * Vn * cos(tetan) / (dteta * Vn + dt * Settings.getEarthGravity() * cos(tetan))); // Расчет угла скоростного крена БпЛА при третьем развороте в n-й момент времени в радианах

			init_49 = false;                                                                         // Запрет инициализации исходных значений параметров при третьем развороте 
		}
		
		dteta = 0.0;                                                                                // Задание шага изменения угла наклона траектории БпЛА
				
		double dgam = (gamish_49 - gammin) / (3.0 / dt);                                                  // Задание шага изменения угла скоростного крена БпЛА

		while (abs(kursvz - kursn) > abs(dkurs_49))                                                 // До тех пор, пока модуль разности курса взлета и угла поворота траектории больше модуля шага изменения угла поворота траектории
		{
			if (init_45 == false || init_46 == false || init_50 == false || init_51 == false)       // Если уже рассчитываются последующие этапы полета
			{
				break;                                                                              // Стоп
			}

			Vn = Vnm1;                                                                              // Расчет скорости БпЛА в n-й момент времени
			kursn = kursnm1 + dkurs_49;                                                             // Расчет угла поворота траектории БпЛА в n-й момент времени

			// Приведение kursn к интервалу от 0 до 2 пи

			if (kursn >= 2 * Pi)
			{
				kursn = kursn - 2 * Pi;
			}

			if (kursn < 0)
			{
				kursn = kursn + 2 * Pi;
			}

			//

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                            // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                         // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                               // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                               // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                               // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			//

			F_LastTime = F_LastTime + dt;                                                          // Задание отсчетов времени
										
			gamn = gamnm1 - dgam;                                                                  // Расчет угла скоростного крена БпЛА в n-й момент времени

			if ((gammin < 0) && (gamn < gammin))
			{
				gamn = gammin;
			}

			if ((gammin > 0) && (gamn > gammin))
			{
				gamn = gammin;
			}
						
			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                   // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                   // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                   // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                    // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                     // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                                              // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                                             // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                                              // Определение высоты БпЛА в n-й момент времени в геодезической СК

			if (hn != Hish_49)                                                                  // Если текущая высота БпЛА в n-й момент времени не равна исходной высоте Hish_49
			{
				hn = Hish_49;                                                                   // Текущая высота БпЛА приравнивается к исходной высоте Hish_49

				CPointGeo p2kgn = CPointGeo(F_LastTime, Bn, Ln, hn);                            // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal p2kn = p2kgn.toPointGlobal();                                      // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xn = p2kn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				yn = p2kn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				zn = p2kn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}
						
			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = gamn * 180.0 / Pi;                                                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
            
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;
			kursnm1 = kursn;
			gamnm1 = gamn;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени третьего разворота в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}

	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Горизонтирование БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	if (init_45 == true)                                                                     // Если инициализация исходных значений параметров разрешена при горизонтировании
	{
		tetaish_45 = tetan;                                                                  // Задание исходного угла наклона траектории БпЛА в начале горизонтирования
		kursish_45 = kursn;                                                                  // Задание исходного угла поворота траектории БпЛА в начале горизонтирования
		gammaish_45 = plane.curPos.gamma;                                                    // Задание исходного угла скоростного крена БпЛА в начале горизонтирования
		
		init_45 = false;                                                                     // Запрет инициализации исходных значений параметров в начале набора заданной скорости
	}
	
	gamnm1 = plane.curPos.gamma;                                                            // Задание начального значения угла скоростного крена БпЛА в (n-1)-й момент времени
	gamn = gamnm1;                                                                          // Задание начального значения угла скоростного крена БпЛА в n-й момент времени

	dkurs = (kursvz - kursish_45) / (0.5 / dt);                                                    // Задание шага изменения угла поворота траектрии БпЛА
	
	dteta = tetaish_45 / 5.0;                                                               // Шаг изменения угла наклона траектории БпЛА при наборе заданной скорости
	double dgamma = gammaish_45 / (2.0 / dt);                                                     // Задание шага изменения угла скоростного крена БпЛА

	while ((kursn != kursvz) || (tetan != 0.0) || (gamn != 0.0))                            // До тех пор, пока текущий угол поворота траектории не равен курсу взлета, или текущий угол наклона траектории не равен нулю, или текущий угол скоростного крена не равен нулю
	{

		if (init_46 == false || init_50 == false || init_51 == false)                       // Если уже рассчитываются последующие этапы полета БпЛА
		{
			break;                                                                          // Стоп
		}


		if (abs(kursvz - kursn) >= abs(dkurs))                                              // Если модуль разности текущей курса взлета БпЛА и угла поворота траетории больше или равен модулю шага изменения угла поворота траектории БпЛА
		{
			kursn = kursnm1 + dkurs;                                                        // Расчет угла поворота траектории БпЛА в n-й момент времени
		}
		
		// Приведение kursn к интервалу от 0 до 2 пи

		if (kursn >= 2 * Pi)
		{
			kursn = kursn - 2 * Pi;
		}

		if (kursn < 0)
		{
			kursn = kursn + 2 * Pi;
		}

		//

		if (abs(kursvz - kursn) < abs(dkurs))                                              // Если модуль разности текущей курса взлета БпЛА и угла поворота траетории меньше модуля шага изменения угла поворота траектории БпЛА
		{
			kursn = kursvz;                                                                // Текущая скорость БпЛА приравнивается к крейсерской скорости
		}
		
		if (abs(tetan) >= abs(dteta))                                                      // Если модуль угла наклона траектории БпЛА в n-й момент времени больше или равен модулю шага изменения угла наклона траектории БпЛА
		{
			tetan = tetanm1 - dteta;                                                       // Расчет угла наклона траектории БпЛА в n-й момент времени
		}

		if (abs(tetan) < abs(dteta))                                                       // Если модуль угла наклона траектории БпЛА в n-й момент времени меньше модуля шага изменения угла наклона траектории БпЛА
		{
			tetan = 0.0;                                                                   // Угол наклона траектории БпЛА в n-й момент времени приравнивается к нулю
		}
				
		if (abs(gamn) >= abs(dgamma))                                                      // Если модуль угла скоростного крена БпЛА в n-й момент времени больше или равен модулю шага изменения угла скоростного крена БпЛА
		{
			gamn = gamnm1 - dgamma;                                                        // Расчет угла скоростного крена БпЛА в n-й момент времени
		}
		
		if (abs(gamn) < abs(dgamma))                                                       // Если модуль угла скоростного крена БпЛА в n-й момент времени меньше модуля шага изменения угла скоростного крена БпЛА
		{
			gamn = 0.0;                                                                    // Угол скоростного крена БпЛА в n-й момент времени приравнивается к нулю
		}
		
		double Vxgn = Vn * cos(tetan) * sin(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                     // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                           // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                           // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                           // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                      // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));               // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                               // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                 // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                 // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                 // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                  // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                   // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                            // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                           // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК
				
		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = gamn * 180.0 / Pi;                                                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись в фильм n-й точки 
        
		// Обновление параметров через 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		kursnm1 = kursn;
		tetanm1 = tetan;
		gamnm1 = gamn;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamman * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования и набора заданной скорости в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Полет БпЛА до расстояния 7 км от условной точки, расположенной на высоте Hsn_1 над аэродромом //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_46 == true)                                                                     // Если инициализация исходных значений параметров разрешена при полете БпЛА до условной точки
	{
		Hish_46 = hn;                                                                        // Задание исходной высоты БпЛА в начале полета до условной точки
		tetaish_46 = tetan;                                                                  // Задание исходного угла наклона траектории БпЛА в начале полета до условной точки
		kursish_46 = kursn;                                                                  // Задание исходного угла поворота траектории БпЛА в начале полета до условной точки
		
		init_46 = false;                                                                     // Запрет инициализации исходных значений параметров в начале полета до условной точки
	}

	Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));        // Расчет расстояния до точки в начальный момент времени
		
	while (Dn > 7000.0)                                                                      // До тех пор, пока дальность до точки больше 7 км
	{

		if (init_50 == false || init_51 == false)                                            // Если уже рассчитывается последующий этап полета БпЛА
		{
			break;                                                                           // Стоп
		}

		if (tetan != tetaish_46)                                                             // Если текущий угол наклона траектории БпЛА не равен исходному углу наклона траектории БпЛА
		{
			tetan = tetaish_46;                                                              // Текущий угол наклона траектории БпЛА приравнивается к исходному углу наклона траектории БпЛА
		}

		double Vxgn = Vn * cos(tetan) * sin(kursvz);                                         // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursvz);                                         // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                                                       // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                             // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                             // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                                                             // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                        // Задание отсчетов времени

		gamn = 0.0;                                                                          // Задание угла скоростного крена БпЛА в n-й момент времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                                             // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                                             // Определение высоты БпЛА в n-й момент времени в геодезической СК

		if (hn != Hish_46)                                                                  // Если текущая высота не равна исходной высоте Hish_46
		{
			hn = Hish_46;                                                                   // Текущая высота приравнивается к исходной высоте Hish_46

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));              // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		Dn = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));    // Расчет расстояния до точки в начальный момент времени
				
		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                  // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                  // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                            // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamman = gamn * 180.0 / Pi;

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);         // Запись в фильм n-й точки	
       
		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursvz;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn;

		plane.Trajectory.push_back(plane.curPos);                                                         // Запись в вектор n-й точки	


		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;
			

		//
				
		//

		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования после разворота БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}

	}

	// Cнижение //			
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
		if (init_50 == true)                                           // Если инициализация исходных значений параметров разрешена при снижении БпЛА до среднего значения текущей и заданной высот
		{
			Hish_50 = hn;                                              // Исходная высота в начале снижения до среднего значения текущей и заданной высот
			Vish_50 = Vn;                                              // Исходная скорость БпЛА в начале снижения до среднего значения текущей и заданной высот
			tetaish_50 = tetan;                                        // Исходный угол наклона траектории БпЛА в начале снижения до среднего значения текущей и заданной высот
			
			Dish_50 = sqrt((x2 - xn) * (x2 - xn) + (y2 - yn) * (y2 - yn) + (z2 - zn) * (z2 - zn));   // Исходное расстояние до аэродрома

			init_50 = false;                                           // Запрет инициализации исходных значений параметров в начале снижения до среднего значения текущей и заданной высот
		}
		
		double tetasn = -2 * atan((Hish_50 - Hsn_3) / (Dish_50 - 1000.0));        // Расчет значения угла наклона траектории БпЛА на средней высоте
				
		double Tsn = (0.5 * (Hsn_3 + Hish_50) - Hish_50) / (0.5 * (Vish_50 + 0.825 * Vish_50) * sin(0.5 * (tetasn + tetaish_50)));    // Интервал времени снижения БпЛА до среднего значения текущей и заданной высот
		size_t Nsn = (size_t) floor(Tsn / dt);                                                                                        // Количество отсчетов времени снижения БпЛА до среднего значения текущей и заданной высот               
		dV = (0.825 * Vish_50 - Vish_50) / Nsn;                                                                                       // Шаг изменения скорости полета БпЛА после начала снижения до среднего значения текущей и заданной высот
		dteta = (tetasn - tetaish_50) / Nsn;                                                                                          // Шаг изменения угла снижения БпЛА до среднего значения текущей и заданной высот

		while (hn > (Hsn_3 + Hish_50) / 2)                                                     // До тех пор, пока рассчитываемая высота больше среднего значения текущей и заданной высот БпЛА
		{
			
			if (Vn > 0.825 * Vish_50)                                                          // Если скорость снижения высоты в n-й момент времени больше 0,825 скорости в начале снижения
			{
				Vn = Vnm1 + dV;                                                                // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn <= 0.825 * Vish_50)                                                         // Если скорость снижения высоты в n-й момент времени меньше или равна 0,825 скорости в начале снижения
			{
				Vn = 0.825 * Vish_50;                                                          // Скорость БпЛА в n-й момент времени приравнивается к 0,825 скорости в начале снижения
			}

			if (tetan > tetasn)                                                                // Если угол наклона траектории БпЛА в n-й момент времени больше заданного угла наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetanm1 + dteta;                                                       // Расчет угла наклона траектории БпЛА в n-й момент времени
			}

			if (tetan <= tetasn)                                                               // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен заданному углу наклона траектории БпЛА при снижении после разворота
			{
				tetan = tetasn;                                                                // Угол наклона траектории БпЛА в n-й момент времени приравнивается к заданному углу наклона траектории при снижении БпЛА после разворота
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                     // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                           // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                           // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                           // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                      // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                              // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                        // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                       // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);  // Запись n-й точки в фильм
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                           // Продолжение полета БпЛА
			}
		}

		// Снижение до заданной высоты //

		if (init_51 == true)                                                                        // Если инициализация исходных значений параметров разрешена при снижении до заданной высоты 
		{
			Hish_51 = hn;                                                                           // Задание исходной высоты БпЛА в начале снижения до заданной высоты 
			tetaish_51 = tetan;                                                                     // Задание исходного угла наклона траектории БпЛА в начале снижения до заданной высоты 
			
			init_51 = false;                                                                        // Запрет инициализации исходных значений параметров в начале снижения до заданной высоты 
		}

		tetasn = -3.0 * Pi / 180.0;                                                                 // Угол наклона траектории БпЛА на заданной высоте
			   		
		Tsn = (Hsn_3 - Hish_51) / (0.5 * (Vish_50 + 0.65 * Vish_50) * sin(0.5 * (tetasn + tetaish_51)));      // Расчет интервала времени снижения БпЛА до заданной высоты 
		Nsn = (size_t) floor(Tsn / dt);                                                             // Расчет количества отсчетов времени снижения БпЛА до заданной высоты 
		dV = (0.65 * Vish_50 - Vish_50) / Nsn;                                                      // Шаг изменения скорости полета БпЛА после начала снижения до заданной высоты
		dteta = (tetasn - tetaish_51) / Nsn;	                                                    // Расчет шага изменения угла наклона траектории БпЛА при снижении до заданной высоты

		while (hn > Hsn_3)                                                                          // До тех пор, пока рассчитываемая высота БпЛА будет больше заданной высоты
		{
			
			if (Vn > 0.65 * Vish_50)                                                                // Если скорость БпЛА в n-й момент времени больше 0,65 скорости полета в начале снижения
			{
				Vn = Vnm1 + dV;                                                                     // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vn <= 0.65 * Vish_50)                                                               // Если скорость БпЛА в n-й момент времени меньше или равна 0,65 скорости полета в начале снижения
			{
				Vn = 0.65 * Vish_50;                                                                // Скорость БпЛА в n-й момент времени приравнивается к 0,65 скорости полета в начале снижения
			}

			if (tetan < tetasn)                                                                     // Если угол наклона траектории БпЛА в n-й момент времени меньше угла наклона траектории на заданной высоте
			{
				tetan = tetanm1 + dteta;                                                            // Расчет угла наклона траектории БпЛА
			}

			if (tetan >= tetasn)                                                                    // Если угол наклона траектории БпЛА в n-й момент времени больше или равен углу наклона траектории на заданной высоте
			{
				tetan = tetasn;                                                                     // Угол наклона траектории БпЛА в n-й момент времени приравнивается к углу наклона траектории на заданной высоте
			}

			double Vxgn = Vn * cos(tetan) * sin(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			double Vygn = Vn * cos(tetan) * cos(kursn);                                             // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			double Vzgn = Vn * sin(tetan);                                                          // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgn = xgnm1 + Vxgn * dt;                                                                // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygn = ygnm1 + Vygn * dt;                                                                // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgn = zgnm1 + Vzgn * dt;                                                                // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                                           // Задание отсчетов времени

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                    // Создание точки в n-й момент времени в местной СК с центром в начальной точке
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                    // Преобразование созданной точки из местной СК в геоцентрическую СК

			xn = resgeo1.getPosition().getX();                                                      // Определение координаты x точки в n-й момент времени в геоцентрической СК
			yn = resgeo1.getPosition().getY();                                                      // Определение координаты y точки в n-й момент времени в геоцентрической СК
			zn = resgeo1.getPosition().getZ();                                                      // Определение координаты z точки в n-й момент времени в геоцентрической СК

			CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                       // Создание точки в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pn.toPointGeo();                                                        // Преобразование созданной точки из геоцентрической СК в геодезическую СК

			hn = pgn.getAltitude();                                                                 // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xn - xnm1) / (yn - ynm1));

			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

			//

			Vxn = Vn * cos(cn) * sin(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vyn = Vn * cos(cn) * cos(rn);                                                               // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vzn = Vn * sin(cn);                                                                         // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamman = 0.0;                                                                        // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamman);   // Запись в фильм n-й точки
           
			// Обновление параметров через 0,1 с

			xgnm1 = xgn;
			ygnm1 = ygn;
			zgnm1 = zgn;

			xnm1 = xn;
			ynm1 = yn;
			znm1 = zn;

			Vnm1 = Vn;
			tetanm1 = tetan;

			// Запись параметров движения БпЛА

			plane.curPos.time = F_LastTime;
			plane.curPos.x = xn;
			plane.curPos.y = yn;
			plane.curPos.z = zn;
			plane.curPos.vx = Vxn;
			plane.curPos.vy = Vyn;
			plane.curPos.vz = Vzn;
			plane.curPos.fi = kursn;
			plane.curPos.teta = tetan;
			plane.curPos.gamma = gamman * Pi / 180.0;

			plane.Trajectory.push_back(plane.curPos);                                             // Запись n-й точки в вектор

			//
						
			F_n++;

			if (F_n == cur_F_n)                                                                  // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени снижения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                        // Продолжение полета БпЛА
			}
		}
	
	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Зашел на посадку");   // Запись в фильм комментария

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	init_41 = true;                                                                      // Разрешение инициализации исходных значений параметров при первом развороте
	init_42 = true;                                                                      // Разрешение инициализации исходных значений параметров при горизонтировании и наборе заданной скорости БпЛА
	init_43 = true;                                                                      // Разрешение инициализации исходных значений параметров при вычислении радиуса второго разворота БпЛА
	init_44 = true;                                                                      // Разрешение инициализации исходных значений параметров при втором развороте БпЛА
	init_45 = true;                                                                      // Разрешение инициализации исходных значений параметров при горизонтировании БпЛА
	init_46 = true;                                                                      // Разрешение инициализации исходных значений параметров при полете БпЛА до условной точки
	init_47 = true;                                                                      // Разрешение инициализации исходных значений параметров при полете до условной точки второго разворота БпЛА
	init_48 = true;                                                                      // Разрешение инициализации исходных значений параметров при втором развороте БпЛА со скоростным креном 30 градусов
	init_49 = true;                                                                      // Разрешение инициализации исходных значений параметров при третьем развороте БпЛА
	init_50 = true;                                                                      // Разрешение инициализации исходных значений параметров при снижении БпЛА до половины суммы текущей и заданной высоты
	init_51 = true;                                                                      // Разрешение инициализации исходных значений параметров при снижении БпЛА до заданной высоты

	F_n = 0;                                                                             // Установление текущего отсчета положения БпЛА в 0

	return 1;                                                                            // Окончание захода на посадку

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////// Модель посадки БпЛА ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Posadka()
{
		
	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                                             // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                                                 // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Считываемые параметры //

	double xnm1 = plane.curPos.x;                                                                  // Определение координаты x БпЛА в геоцентрической СК в (n-1)-й момент времени
	double ynm1 = plane.curPos.y;                                                                  // Определение координаты y БпЛА в геоцентрической СК в (n-1)-й момент времени
	double znm1 = plane.curPos.z;                                                                  // Определение координаты z БпЛА в геоцентрической СК в (n-1)-й момент времени
	double Vxnm1 = plane.curPos.vx;                                                                // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в (n-1)-й момент времени
	double Vynm1 = plane.curPos.vy;                                                                // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в (n-1)-й момент времени
	double Vznm1 = plane.curPos.vz;                                                                // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в (n-1)-й момент времени
	double kursnm1 = plane.curPos.fi;                                                              // Определение угла поворота траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double tetanm1 = plane.curPos.teta;                                                            // Определение угла наклона траектории БпЛА при наборе высоты в (n-1)-й момент времени в радианах
	double gamnm1 = plane.curPos.gamma;                                                            // Определение угла скоростного крена БпЛА при наборе высоты в (n-1)-й момент времени в радианах
		
	CPointGlobal pnm1 = CPointGlobal(F_LastTime, CPoint3D(xnm1, ynm1, znm1));                      // Создание начальной точки pnm1 в геоцентрической СК

	CPoint3D zentrnm1(xnm1, ynm1, znm1);                                                           // Создание центра местной СК в начальной точке pnm1
	CPointLocal resultnm1 = pnm1.toPointLocal(zentrnm1);                                           // Перевод точки pnm1 из геоцентрической СК в местную СК

	double xgnm1 = resultnm1.getPosition().getX();                                                 // Определение начального значения координаты xg БпЛА в местной СК в (n-1)-й момент времени
	double ygnm1 = resultnm1.getPosition().getY();                                                 // Определение начального значения координаты yg БпЛА в местной СК в (n-1)-й момент времени
	double zgnm1 = resultnm1.getPosition().getZ();                                                 // Определение начального значения координаты zg БпЛА в местной СК в (n-1)-й момент времени

	double Vnm1 = sqrt(Vxnm1 * Vxnm1 + Vynm1 * Vynm1 + Vznm1 * Vznm1);                             // Определение скорости БпЛА в (n-1)-й момент времени

	CPointGeo pgnm1 = pnm1.toPointGeo();                                                           // Преобразование созданной точки из геоцентрической СК в геодезическую СК

	double Bnm1 = pgnm1.getLatitude();                                                             // Определение начального значения широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgnm1.getLongitude();                                                            // Определение начального значения  долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgnm1.getAltitude();                                                             // Определение начального значения  высоты БпЛА в (n-1)-й момент времени в геодезической СК

	double xn = xnm1;                                                                              // Задание начального значения координаты x БпЛА в геоцентрической СК в n-й момент времени
	double yn = ynm1;                                                                              // Задание начального значения координаты y БпЛА в геоцентрической СК в n-й момент времени
	double zn = znm1;                                                                              // Задание начального значения координаты z БпЛА в геоцентрической СК в n-й момент времени

	double xgn = xgnm1;                                                                            // Задание начального значения координаты xg БпЛА в местной СК в n-й момент времени
	double ygn = ygnm1;                                                                            // Задание начального значения координаты yg БпЛА в местной СК в n-й момент времени
	double zgn = zgnm1;                                                                            // Задание начального значения координаты zg БпЛА в местной СК в n-й момент времени

	double Bn = Bnm1;                                                                              // Задание начального значения широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                                              // Задание начального значения долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                                              // Задание начального значения высоты БпЛА в n-й момент времени в геодезической СК

	double Vxn = Vxnm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени
	double Vyn = Vynm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени
	double Vzn = Vznm1;                                                                            // Задание начального значения проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени

	double Vn = Vnm1;                                                                              // Задание начального значения скорости БпЛА в n-й момент времени	

	double kursn = kursnm1;                                                                        // Задание начального значения угла поворота траектории БпЛА при наборе высоты в n-й момент времени
	double tetan = tetanm1;                                                                        // Задание начального значения угла наклона траектории БпЛА при наборе высоты в n-й момент времени

	double Vsv = plane.ttx_bpla.V_sv;                                                                   // Скорость сваливания БпЛА

	// Этап планирования //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_52 == true)                                                                           // Если инициализация исходных значений параметров разрешена при планировании
	{
		Hish_52 = hn;                                                                              // Исходная высота в начале планирования БпЛА
		Vish_52 = Vn;                                                                              // Исходная скорость БпЛА в начале планирования
		tetaish_52 = tetan;                                                                        // Исходный угол наклона траектории БпЛА в начале планирования

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал планирование");            // Запись в фильм комментария

		init_52 = false;                                                                           // Запрет инициализации исходных значений параметров в начале планирования БпЛА
	}

	double Vpolsn = 1.2 * Vsv;                                                                     // Задание скорости после планирования
	double tetasn = -Pi / 180.0;                                                                   // Задание угла наклона траектории БпЛА после планирования

	double Tsn = (Hsn_4 - Hish_52) / (0.5 * (Vish_52 + Vpolsn) * sin(0.5 * (tetasn + tetaish_52)));     // Расчет интервала времени планирования БпЛА
	size_t Nsn = (size_t)floor(Tsn / dt);                                                          // Расчет количества отсчетов времени снижения БпЛА               
	double dV = (Vpolsn - Vish_52) / Nsn;                                                          // Расчет шага изменения скорости полета БпЛА при снижении
	double dteta = (tetasn - tetaish_52) / Nsn;                                                    // Расчет шага изменения угла наклона траектори БпЛА при снижении 
	
	if ((cur_F_n > Nsn) && (F_n < Nsn))                                                            // Если номер отсчета времени планирования БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени планирования БпЛА, а текущий отсчет времени положения БпЛА меньше количества отсчетов времени планирования БпЛА
	{
		cur_F_n = Nsn;                                                                             // Номер отсчета времени планирования БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным количеству отсчетов времени планирования БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)
	{

		if (cur_F_n > Nsn)                                                                         // Если номер отсчета времени планирования БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше количества отсчетов времени планирования БпЛА
		{
			break;                                                                                 // Стоп
		}

		if (Vnm1 > Vpolsn)
		{
			Vn = Vnm1 + dV;                                   // Расчет скорости БпЛА при планировании в n-й момент времени
		}

		if (Vnm1 <= Vpolsn)
		{
			Vn = Vpolsn;                                      // Расчет скорости БпЛА при планировании в n-й момент времени
		}

		if (tetanm1 < tetasn)
		{
			tetan = tetanm1 + dteta;                          // Расчет угла наклона траектории БпЛА при планировании в n-й момент времени
		}
		
		if (tetanm1 >= tetasn)
		{
			tetan = tetasn;                                   // Расчет угла наклона траектории БпЛА при планировании в n-й момент времени
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                              // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                              // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                              // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                         // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                               // Определение высоты точки в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn - Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);             // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);             // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                       // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamn = 0.0;                        // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamn);     // Запись n-й точки в фильм
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                            // Запись в вектор n-й точки 
	}

	if (cur_F_n == Nsn)                                                                      // Если номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен количеству отсчетов времени разбега БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Завершил планирование");        // Запись в фильм комментария
	}

	if (F_n < Nsn)                                                                           // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разбега БпЛА
	{
		return 0;                                                                            // Продолжение полета БпЛА
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Этап выравнивания //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_53 == true)                                                                    // Если инициализация исходных значений параметров разрешена при выравнивании БпЛА
	{
		Hish_53 = hn;                                                                       // Исходная высота в начале выравнивания БпЛА
		Vish_53 = Vn;                                                                       // Исходная скорость БпЛА в начале выравнивания
		tetaish_53 = tetan;                                                                 // Исходный угол наклона траектории БпЛА в начале выравнивания БпЛА

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал выравнивание");     // Запись в фильм комментария

		init_53 = false;                                                                    // Запрет инициализации исходных значений параметров в начале выравнивания БпЛА
	}

	Vpolsn = 1.1 * Vsv;                                                                     // Задание скорости БпЛА после выравнивания
	tetasn = -Pi / 360.0;                                                                   // Задание угла наклона траектории БпЛА после выравнивания

	double Tvyr = (Hsn_5 - Hish_53) / (0.5 * (Vish_53 + Vpolsn) * sin(0.5 * (tetasn + tetaish_53)));    // Расчет интервала времени выравнивания БпЛА
	size_t Nvyr = (size_t)floor(Tvyr / dt);                                                             // Расчет количества отсчетов времени выравнивания БпЛА
	dV = (Vpolsn - Vish_53) / Nvyr;                                                                     // Расчет шага изменения скорости полета БпЛА при выравнивании
	dteta = (tetasn - tetaish_53) / Nvyr;                                                               // Расчет шага изменения угла снижения БпЛА при выравнивании

	cur_F_n = F_n + deltaF;                                                                // Номер отсчета времени выравнивания БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (cur_F_n > Nsn + Nvyr && F_n < Nsn + Nvyr)                                          // Если номер отсчета времени выравнивания БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени планирования БпЛА и отсчетов времени выравнивания БпЛА
	{
		cur_F_n = Nsn + Nvyr;                                                              // Номер отсчета времени выравнивания БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным суммарному количеству отсчетов времени планирования БпЛА и отсчетов времени выравнивания БпЛА
	}
	
	for (F_n; F_n < cur_F_n; F_n++)
	{

		if (cur_F_n > Nsn + Nvyr)                                                          // Если номер отсчета времени выравнивания БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени планирования и выравнивания БпЛА
		{
			break;                                                                         // Стоп
		}

		if (Vnm1 > Vpolsn)
		{
			Vn = Vnm1 + dV;                                   // Расчет скорости БпЛА при выравнивании в n-й момент времени
		}

		if (Vnm1 <= Vpolsn)
		{
			Vn = Vpolsn;                                      // Расчет скорости БпЛА при выравнивании в n-й момент времени
		}

		if (tetanm1 < tetasn)
		{
			tetan = tetanm1 + dteta;                          // Расчет угла наклона траектории БпЛА при выравнивании в n-й момент времени
		}

		if (tetanm1 >= tetasn)
		{
			tetan = tetasn;                                   // Расчет угла наклона траектории БпЛА при выравнивании в n-й момент времени
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени
		
		xgn = xgnm1 + Vxgn * dt;                              // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                              // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                              // Расчет координаты zg БпЛА в местной СК в n-й момент времени
				
		F_LastTime = F_LastTime + dt;                                                       // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                               // Определение высоты точки в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                           // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                           // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                     // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamn = 0.0;                                                                      // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamn); // Запись в фильм n-й точки 
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		//

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки 
	}

	if (cur_F_n == Nsn + Nvyr)                                                                  // Если номер отсчета времени выравнивания БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен суммарному количеству отсчетов времени планирования и выравнивания БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Завершил выравнивание");           // Запись в фильм комментария
	}

	if (F_n < Nsn + Nvyr)                                                                       // Если текущий отсчет времени положения БпЛА меньше количества отсчетов времени разбега БпЛА
	{
		return 0;                                                                               // Продолжение полета БпЛА
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Этап выдерживания //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	if (init_54 == true)                                                                       // Если инициализация исходных значений параметров разрешена при выдерживании БпЛА
	{
		Hish_54 = 1.0;                                                                         // Исходная высота в начале выдерживания БпЛА
		Vish_54 = Vn;                                                                          // Исходная скорость БпЛА в начале выдерживания
		tetaish_54 = tetan;                                                                    // Исходный угол наклона траектории БпЛА в начале выдерживания БпЛА

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал выдерживание");        // Запись в фильм комментария

		init_54 = false;                                                                       // Запрет инициализации исходных значений параметров в начале выдерживания БпЛА
	}

	Vpolsn = 1.1 * Vsv;                                                                        // Задание скорости БпЛА после выдерживания
	tetasn = 0.0;                                                                              // Задание угла наклона траектории БпЛА после выдерживания

	double Tvyd = (Hsn_6 - Hish_54) / (0.5 * (Vish_54 + Vpolsn) * sin(0.5 * (tetasn + tetaish_54)));    // Расчет интервала времени выдерживания БпЛА
	size_t Nvyd = (size_t)ceil(Tvyd / dt);                                                              // Расчет количества отсчетов времени выдерживания БпЛА
	dV = (Vpolsn - Vish_54) / Nvyd;                                                                     // Расчет шага изменения скорости полета БпЛА при выдерживании
	dteta = (tetasn - tetaish_54) / Nvyd;                                                               // Расчет шага изменения угла снижения БпЛА при выдерживании

	cur_F_n = F_n + deltaF;                                                                    // Номер отсчета времени взлета БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (cur_F_n > Nsn + Nvyr + Nvyd && F_n < Nsn + Nvyr + Nvyd)                                // Если номер отсчета времени выдерживания БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени планирования, выравнивания и выдерживания БпЛА
	{
		cur_F_n = Nsn + Nvyr + Nvyd;                                                           // Номер отсчета времени выдерживания БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным суммарному количеству отсчетов времени планирования, выравнивания и выдерживания БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)
	{

		if (cur_F_n > Nsn + Nvyr + Nvyd)                                                      // Если номер отсчета времени выдерживания БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени планирования, выравнивания и выдерживания БпЛА
		{
			break;                                                                            // Стоп
		}

		if (Vnm1 > Vpolsn)
		{
			Vn = Vnm1 + dV;                                    // Расчет скорости БпЛА при выдерживании в n-й момент времени
		}

		if (Vnm1 <= Vpolsn)
		{
			Vn = Vpolsn;                                      // Расчет скорости БпЛА при выдерживании в n-й момент времени
		}

		if (tetanm1 < tetasn)
		{
			tetan = tetanm1 + dteta;                          // Расчет угла наклона траектории БпЛА при выдерживании в n-й момент времени
		}

		if (tetanm1 >= tetasn)
		{
			tetan = tetasn;                                   // Расчет угла наклона траектории БпЛА при выдерживании в n-й момент времени
		}

		double Vxgn = Vn * cos(tetan) * sin(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(tetan) * cos(kursn);           // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = Vn * sin(tetan);                        // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                              // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                              // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1 + Vzgn * dt;                              // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                      // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                  // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                  // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                  // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                   // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                    // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                               // Определение высоты точки в n-й момент времени в геодезической СК

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));

		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));

		//

		Vxn = Vn * cos(cn) * sin(rn);                                                           // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);                                                           // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                                                                     // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamn = 0.0;                                                                      // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamn); // Запись в фильм n-й точки 
        
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;

		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		//

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                               // Запись в вектор n-й точки 
	}

	if (cur_F_n == Nsn + Nvyr + Nvyd)                                                           // Если номер отсчета времени выдерживания БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен суммарному количеству отсчетов времени планирования, выравнивания и выдерживания БпЛА
	{
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Завершил выдерживание");           // Запись в фильм комментария
	}

	if (F_n < Nsn + Nvyr + Nvyd)                                                                // Если текущий отсчет времени положения БпЛА меньше суммарного количества отсчетов времени планирования, выравнивания и выдерживания БпЛА
	{
		return 0;                                                                               // Продолжение полета БпЛА
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Пробег БпЛА //
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_55 == true)                                                                       // Если инициализация исходных значений параметров разрешена при пробеге БпЛА
	{
		Hish_55 = hn;                                                                          // Исходная высота в начале пробега БпЛА
		Vish_55 = Vn;                                                                          // Исходная скорость БпЛА в начале пробега

		Film.writeLog(plane.object.getObjNum(), F_LastTime + dt, "Начал пробег");              // Запись в фильм комментария

		init_55 = false;                                                                       // Запрет инициализации исходных значений параметров в начале пробега БпЛА
	}
		
	Vpolsn = 0.001;                                                                            // Задание скорости БпЛА после пробега
	double Lprob = plane.ttx_bpla.L_prob;                                                           // Определение дистанции пробега БпЛА
	double Tprob = 2 * Lprob / Vish_55;                                                        // Расчет времени пробега БпЛА
	size_t Nprob = (size_t)floor(Tprob / dt);                                                  // Расчет количества отсчетов пробега БпЛА
	dV = (Vpolsn - Vish_55) / Nprob;                                                           // Расчет шага изменения скорости БпЛА при пробеге

	cur_F_n = F_n + deltaF;                                                                    // Номер отсчета времени пробега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	if (cur_F_n > Nsn + Nvyr + Nvyd + Nprob && F_n < Nsn + Nvyr + Nvyd + Nprob)                // Если номер отсчета времени пробега БпЛА в конце интервала моделирования траектории БпЛА (1 с) больше суммарного количества отсчетов времени планирования, выравнивания, выдерживания и пробега БпЛА
	{
		cur_F_n = Nsn + Nvyr + Nvyd + Nprob;                                                   // Номер отсчета времени пробега БпЛА в конце интервала моделирования траектории БпЛА (1 с) принимается равным суммарному количеству отсчетов времени планирования, выравнивания, выдерживания и пробега БпЛА
	}

	for (F_n; F_n < cur_F_n; F_n++)
	{
		if (Vnm1 > Vpolsn)
		{
			Vn = Vnm1 + dV;                                                                   // Расчет скорости БпЛА при пробеге в n-й момент времени
		}

		if (Vnm1 <= Vpolsn)
		{
			Vn = Vpolsn;                                                                     // Расчет скорости БпЛА при пробеге в n-й момент времени
		}

		double Vxgn = Vn * sin(kursn);                                                       // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		double Vygn = Vn * cos(kursn);                                                       // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		double Vzgn = 0.0;                                                                   // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgn = xgnm1 + Vxgn * dt;                                                             // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygn = ygnm1 + Vygn * dt;                                                             // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgn = zgnm1;                                                                         // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                                        // Задание отсчетов времени

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgn, ygn, zgn));                 // Создание точки в n-й момент времени в местной СК с центром в начальной точке
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1);                                 // Преобразование созданной точки из местной СК в геоцентрическую СК

		xn = resgeo1.getPosition().getX();                                                   // Определение координаты x точки в n-й момент времени в геоцентрической СК
		yn = resgeo1.getPosition().getY();                                                   // Определение координаты y точки в n-й момент времени в геоцентрической СК
		zn = resgeo1.getPosition().getZ();                                                   // Определение координаты z точки в n-й момент времени в геоцентрической СК

		CPointGlobal pn = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));                    // Создание точки в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pn.toPointGeo();                                                     // Преобразование созданной точки из геоцентрической СК в геодезическую СК

		hn = pgn.getAltitude();                                                              // Определение высоты точки в n-й момент времени в геодезической СК

		// Стабилизация заданной высоты разбега БпЛА и пересчет параметров движения БпЛА //

		if (hn != 0.0)                                                                       // Если текущая высота не равна исходной высоте
		{
			hn = 0.0;                                                                        // Текущая высота приравнивается к исходной высоте

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xn = pkn.getPosition().getX();                                                   // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			yn = pkn.getPosition().getY();                                                   // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			zn = pkn.getPosition().getZ();                                                   // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xn, yn, zn));               // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1);                                // Перевод точки pno из геоцентрической СК в местную СК

			xgn = result1.getPosition().getX();                                              // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygn = result1.getPosition().getY();                                              // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgn = result1.getPosition().getZ();                                              // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}
			
		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xn - xnm1) / (yn - ynm1));
		
		if (((xn - xnm1) >= 0.0) && ((yn - ynm1) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xn - xnm1) >= 0.0) && ((yn - ynm1) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xn - xnm1) < 0.0) && ((yn - ynm1) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xn - xnm1) < 0.0) && ((yn - ynm1) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((zn - znm1) * cos(rn) / (yn - ynm1));
		
		//

		Vxn = Vn * cos(cn) * sin(rn);             // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vyn = Vn * cos(cn) * cos(rn);             // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vzn = Vn * sin(cn);                       // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени
				
		double gamn = 0.0;                        // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(plane.object.getObjNum(), F_LastTime, xn, yn, zn, Vxn, Vyn, Vzn, gamn); // Запись n-й точки в фильм
       
		// Обновление параметров с интервалом 0,1 с

		xgnm1 = xgn;
		ygnm1 = ygn;
		zgnm1 = zgn;
		
		xnm1 = xn;
		ynm1 = yn;
		znm1 = zn;

		Vnm1 = Vn;
		tetanm1 = tetan;

		//

		// Запись параметров движения БпЛА

		plane.curPos.time = F_LastTime;
		plane.curPos.x = xn;
		plane.curPos.y = yn;
		plane.curPos.z = zn;
		plane.curPos.vx = Vxn;
		plane.curPos.vy = Vyn;
		plane.curPos.vz = Vzn;
		plane.curPos.fi = kursn;
		plane.curPos.teta = tetan;
		plane.curPos.gamma = gamn * Pi / 180.0;

		plane.Trajectory.push_back(plane.curPos);                                                   // Запись в вектор n-й точки 
						
	}

	if (cur_F_n == Nsn + Nvyr + Nvyd + Nprob)                                                       // Если номер отсчета времени пробега БпЛА в конце интервала моделирования траектории БпЛА (1 с) равен суммарному количеству отсчетов времени планирования, выравнивания, выдерживания и пробега БпЛА
	{	
		Film.writeLog(plane.object.getObjNum(), F_LastTime, "Остановка. Полет завершен");           // Запись в фильм комментария
		
		init_52 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при планировании БпЛА
		init_53 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при выравнивании БпЛА
		init_54 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при выдерживании БпЛА
		init_55 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при пробеге БпЛА

		F_n = 0;                                                                                    // Установление текущего отсчета положения БпЛА в 0

		return 1;                                                                                   // Окончание посадки БпЛА
	}

	if (F_n < Nsn + Nvyr + Nvyd + Nprob)                                                            // Если текущий отсчет времени положения БпЛА меньше суммарного количества отсчетов времени планирования, выравнивания, выдерживания и пробега БпЛА
	{
		return 0;                                                                                   // Продолжение полета БпЛА
	}
	else
	{
		return 1;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////// Модель наведения БпЛА на НПЦ ////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Navedenie()
{

	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	int deltaF = (int)round((maxT - F_LastTime) / dt);                  // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                     // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Определение факта существования траектории НПЦ

	
 	curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

	if (curTarPosPlusDt.time == -1)
	{
		Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
		return -1;
	}

	curTarPos = getCurPosNPC(F_LastTime);
	
	// Обновление параметров с интервалом 1 с
	
	double xnm1t = curTarPos.x;
	double ynm1t = curTarPos.y;
	double znm1t = curTarPos.z;
	double Vxnm1t = curTarPos.vx;
	double Vynm1t = curTarPos.vy;
	double Vznm1t = curTarPos.vz;
	double finm1t = curTarPos.fi;                                    // в радианах
	double tetanm1t = curTarPos.teta;                                // в радианах
	double gammanm1t = curTarPos.gamma;                              // в радианах

	double xnm1f = this->plane.curPos.x;
	double ynm1f = this->plane.curPos.y;
	double znm1f = this->plane.curPos.z;
	double Vxnm1f = this->plane.curPos.vx;
	double Vynm1f = this->plane.curPos.vy;
	double Vznm1f = this->plane.curPos.vz;
	double finm1f = this->plane.curPos.fi;                           // в радианах
	double tetanm1f = this->plane.curPos.teta;                       // в радианах
	double gammanm1f = this->plane.curPos.gamma;                     // в радианах

	//

	// Приведение finm1f к интервалу от 0 до 2 пи

	if (finm1f >= 2 * Pi)
	{
		finm1f = finm1f - 2 * Pi;
	}

	if (finm1f < 0)
	{
		finm1f = finm1f + 2 * Pi;
	}

	//

	// Приведение fit к интервалу от 0 до 2 пи

	if (finm1t >= 2 * Pi)
	{
		finm1t = finm1t - 2 * Pi;
	}

	if (finm1t < 0)
	{
		finm1t = finm1t + 2 * Pi;
	}

	//

	CPointGlobal pt = CPointGlobal(F_LastTime, CPoint3D(xnm1t, ynm1t, znm1t));    // Создание начальной точки НПЦ в геоцентрической СК
	CPointGlobal pf = CPointGlobal(F_LastTime, CPoint3D(xnm1f, ynm1f, znm1f));    // Создание начальной точки БпЛА в геоцентрической СК

	CPointGeo pgf = pf.toPointGeo();                                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

	double Bnm1 = pgf.getLatitude();                                              // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgf.getLongitude();                                             // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgf.getAltitude();                                              // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	CPoint3D zentrnm1f(xnm1f, ynm1f, znm1f);                                     // Создание центра местной СК в начальной точке АК

	CPointLocal result1 = pf.toPointLocal(zentrnm1f);                            // Перевод точки pf из геоцентрической СК в местную СК 
	CPointLocal result2 = pt.toPointLocal(zentrnm1f);                            // Перевод точки pt из геоцентрической СК в местную СК 

	double xgnm1f = result1.getPosition().getX();                                // Определение координаты xg БпЛА в местной СК в начальной точке 
	double xgnm1t = result2.getPosition().getX();                                // Определение координаты xg НПЦ в местной СК в начальной точке 

	double ygnm1f = result1.getPosition().getY();                                // Определение координаты yg БпЛА в местной СК в начальной точке
	double ygnm1t = result2.getPosition().getY();                                // Определение координаты yg НПЦ в местной СК в начальной точке

	double zgnm1f = result1.getPosition().getZ();                                // Определение координаты zg БпЛА в местной СК в начальной точке
	double zgnm1t = result2.getPosition().getZ();                                // Определение координаты zg НПЦ в местной СК в начальной точке
			   
	double Vnm1f = sqrt(Vxnm1f * Vxnm1f + Vynm1f * Vynm1f + Vznm1f * Vznm1f);    // Скорость БпЛА в (n-1)-й момент времени
	double Vnf = Vnm1f;                                                          // Скорость БпЛА в n-й момент времени

	double Vxgnm1f = Vnm1f * cos(tetanm1f) * sin(finm1f);                        // Расчет проекции вектора скорости БпЛА на ось OgXg в начальный момент времени
	double Vygnm1f = Vnm1f * cos(tetanm1f) * cos(finm1f);                        // Расчет проекции вектора скорости БпЛА на ось OgYg в начальный момент времени
	double Vzgnm1f = Vnm1f * sin(tetanm1f);                                      // Расчет проекции вектора скорости БпЛА на ось OgZg в начальный момент времени

	double Vxgnf = Vxgnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgXg в МСК в n-й момент времени 
	double Vygnf = Vygnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgYg в МСК в n-й момент времени 
	double Vzgnf = Vzgnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgZg в МСК в n-й момент времени 

	double Vnm1t = sqrt(Vxnm1t * Vxnm1t + Vynm1t * Vynm1t + Vznm1t * Vznm1t);    // Скорость НПЦ в (n-1)-й момент времени
	double Vnt = Vnm1t;                                                          // Начальное значение скорости НПЦ в n-й момент времени

	double finf = finm1f;                                                        // Угол поворота траектории БпЛА в n-й момент времени	
	double tetanf = tetanm1f;                                                    // Угол наклона траектории БпЛА в n-й момент времени
	double gammanf = gammanm1f;                                                  // Угол скоростного крена БпЛА в n-й момент времени в радианах

	double xgnf = xgnm1f;                                                        // Определение координаты xg БпЛА в местной СК в n-й момент времени 	
	double ygnf = ygnm1f;                                                        // Определение координаты yg БпЛА в местной СК в n-й момент времени 
	double zgnf = zgnm1f;                                                        // Определение координаты zg БпЛА в местной СК в n-й момент времени 

	double xnf = xnm1f;                                                          // Определение координаты x БпЛА в геоцентрической СК в n-й момент времени 
	double ynf = ynm1f;                                                          // Определение координаты y БпЛА в геоцентрической СК в n-й момент времени 
	double znf = znm1f;                                                          // Определение координаты z БпЛА в геоцентрической СК в n-й момент времени 

	double Vxnf = Vxnm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени 
	double Vynf = Vynm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени 
	double Vznf = Vznm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени 

	double Bn = Bnm1;                                                            // Определение широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК

	double fint = finm1t;                                                        // Угол поворота траектории БпЛА в n-й момент времени	

	double xnt = xnm1t;                                                          // Определение координаты x НПЦ в ГСК в n-й момент времени
	double ynt = ynm1t;                                                          // Определение координаты y НПЦ в ГСК в n-й момент времени
	double znt = znm1t;                                                          // Определение координаты z НПЦ в ГСК в n-й момент времени 

	double xgnt = xgnm1t;                                                        // Определение координаты xg НПЦ в МСК в n-й момент времени
	double ygnt = ygnm1t;                                                        // Определение координаты yg НПЦ в ГСК в n-й момент времени
	double zgnt = zgnm1t;                                                        // Определение координаты zg НПЦ в МСК в n-й момент времени

	//

	double kren_maxf = this->plane.ttx_bpla.kren_max;                                  // Максимально допустимый угол крена БпЛА
	double D_pol = 1.5 * missile_Dpm;
	
	if (Pasp == 1)
	{
		D_pol = 10.0 * missile_Dpm;
	}

    double Dn = sqrt((xgnm1t - xgnm1f) * (xgnm1t - xgnm1f) + (ygnm1t - ygnm1f) * (ygnm1t - ygnm1f));           // Расчет расстояния до НПЦ

    if ((Prpo == 1) && (init_68 == true))
    {
        if ((Pnpt == 0) || (Pnpt == 2))
        {
            xgnm1t = result2.getPosition().getX() - D_pol * sin(finm1t);
            ygnm1t = result2.getPosition().getY() - D_pol * cos(finm1t);
        }

        if (Pnpt == 1)
        {
            xgnm1t = result2.getPosition().getX() + D_pol * sin(finm1t);
            ygnm1t = result2.getPosition().getY() + D_pol * cos(finm1t);
        }

        Dn = sqrt((xgnm1t - xgnm1f) * (xgnm1t - xgnm1f) + (ygnm1t - ygnm1f) * (ygnm1t - ygnm1f));
    }

	//

	if (init_64 == true)                                                        // Если инициализация исходных значений параметров разрешена при наведении БпЛА на НПЦ до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса БпЛА 
	{
		Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Начал наведение на НПЦ");                   // Запись в фильм комментария

		Hish_64 = hn;                                                           // Задание высоты БпЛА в n-й момент времени в геодезической СК
		
        if ((Prpo == 1) && ((Pnpt == 0) || (Pnpt == 2)))
        {
            xgnm1t = result2.getPosition().getX() - D_pol * sin(fint);
            ygnm1t = result2.getPosition().getY() - D_pol * cos(fint);
        }

        if ((Prpo == 1) && (Pnpt == 1))
        {
            xgnm1t = result2.getPosition().getX() + D_pol * sin(fint);
            ygnm1t = result2.getPosition().getY() + D_pol * cos(fint);
        }

		ft_64 = atan((xgnm1t - xgnm1f) / (ygnm1t - ygnm1f));                    // Расчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА //

		if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
		{
			ft_64 = ft_64;
		}
		else
			if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) < 0.0))
			{
				ft_64 = ft_64 + Pi;
			}
			else
				if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
				{
					ft_64 = ft_64 + 2 * Pi;
				}
				else
					if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) < 0.0))
					{
						ft_64 = ft_64 + Pi;
					}

		//

		double Vf_64 = sqrt(Vxnm1f * Vxnm1f + Vynm1f * Vynm1f + Vznm1f * Vznm1f);                   // Определение скорости БпЛА в начальный момент времени

         // Задание значения шага изменения угла поворота траектории БпЛА //

        double R = Vf_64 * Vf_64 / (Settings.getEarthGravity() * kren_maxf * Pi / 180.0);

        double L1 = abs(ft_64 - finm1f) * R;
        double L2 = (2 * Pi - abs(ft_64 - finm1f)) * R;

        if (L1 >= L2)
        {
            if ((ft_64 - finm1f) >= 0.0)
            {
                dkurs_64 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_64) * dt;    // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
            }
            else
            {
                dkurs_64 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_64) * dt;
            }
        }
        else
        {
            if ((ft_64 - finm1f) >= 0.0)
            {
                dkurs_64 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_64) * dt;   // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
            }
            else
            {
                dkurs_64 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_64) * dt;
            }
        }

		fn_bzps = ft_64;                                                                           // Угол визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		init_64 = false;                                                                           // Запрет инициализации исходных значений параметров в начале наведения БпЛА на НПЦ
	}

	//

	// Наведение БпЛА на НПЦ до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	while ((abs(fn_bzps - finf) >= abs(dkurs_64)))                                               // До тех пор, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса
	{

		if (init_65 == false || init_67 == false || init_68 == false || init_69 == false || init_70 == false)     // Если уже рассчитывается последующие этапы полета БпЛА в процессе наведения на НПЦ 
		{
			break;                                                                               // Стоп
		}

		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time == -1)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);

		fint = curTarPos.fi;

		xnt = curTarPos.x;                                             // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                             // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                             // Координата z НПЦ в геоцентрической СК в n-й момент времени

		finf = finm1f + dkurs_64;                                      // Расчет угла поворота траектории БпЛА в n-й момент времени

		// Прведение угла finf к пределам от 0 до 2 пи

		if (finf >= 2 * Pi)
		{
			finf = finf - 2 * Pi;
		}

		if (finf < 0)
		{
			finf = finf + 2 * Pi;
		}

		//

		tetanm1f = 0.0;                                                // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
		tetanf = tetanm1f;                                             // Расчет угла наклона траектории БпЛА в n-й момент времени

		Vnf = Vnm1f;                                                   // Расчет скорости БпЛА в n-й момент времени

		Vxgnf = Vnf * cos(tetanf) * sin(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgXg в n-й момент времени
		Vygnf = Vnf * cos(tetanf) * cos(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgYg в n-й момент времени
		Vzgnf = Vnf * sin(tetanf);                                     // Расчет проекции вектора скорости БпЛА на ось OgZg в n-й момент времени

		xgnf = xgnm1f + dt * Vxgnf;                                    // Расчет координаты xg в n-й момент времени
		ygnf = ygnm1f + dt * Vygnf;                                    // Расчет координаты yg в n-й момент времени
		zgnf = zgnm1f + dt * Vzgnf;                                    // Расчет координаты zg в n-й момент времени

		gammanf = atan((dkurs_64)* Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени

		F_LastTime = F_LastTime + dt;                                  // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                   // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК
		
		if ((Prpo == 1) && ((Pnpt == 0) || (Pnpt == 2)))
		{
			xgnt = result2.getPosition().getX() - D_pol * sin(fint);
			ygnt = result2.getPosition().getY() - D_pol * cos(fint);
		}

		if ((Prpo == 1) && (Pnpt == 1))
		{
			xgnt = result2.getPosition().getX() + D_pol * sin(fint);
			ygnt = result2.getPosition().getY() + D_pol * cos(fint);
		}

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                        // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if (hn != Hish_64)                                             // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
		{
			hn = Hish_64;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени

		}

		//

		fn_bzps = atan((xgnt - xgnf) / (ygnt - ygnf));                                       // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bzps = fn_bzps;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bzps = fn_bzps + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bzps = fn_bzps + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bzps = fn_bzps + Pi;
					}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		double gamn0 = 0.0;

		if ((F_n >= 0) && (F_n < (2 / dt)))
		{
			double gamnmaxf = gammanf * 180.0 / Pi;
			double dgam = gamnmaxf * dt;
			double gamnf = gamn0 + F_n * dgam;
			Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
           
			this->plane.curPos.time = F_LastTime;
			this->plane.curPos.x = xnf;
			this->plane.curPos.y = ynf;
			this->plane.curPos.z = znf;
			this->plane.curPos.vx = Vxnf;
			this->plane.curPos.vy = Vynf;
			this->plane.curPos.vz = Vznf;
			this->plane.curPos.fi = finf;                                               // в радианах
			this->plane.curPos.teta = tetanf;                                           // в радианах
			this->plane.curPos.gamma = gamnf * Pi / 180.0;                              // в радианах

			plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

		}
		else
			if (F_n >= (2 / dt))
			{
				double gamnf = gammanf * 180.0 / Pi;                                    // Пересчет значения скоростного крена БпЛА в n-й момент времени из радиан в градусы для вывода на интерфейс
				Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
              
				this->plane.curPos.time = F_LastTime;
				this->plane.curPos.x = xnf;
				this->plane.curPos.y = ynf;
				this->plane.curPos.z = znf;
				this->plane.curPos.vx = Vxnf;
				this->plane.curPos.vy = Vynf;
				this->plane.curPos.vz = Vznf;
				this->plane.curPos.fi = finf;                                         // в радианах
				this->plane.curPos.teta = tetanf;                                     // в радианах
				this->plane.curPos.gamma = gamnf * Pi / 180.0;                        // в радианах

				plane.Trajectory.push_back(plane.curPos);                             // Запись n-й точки в вектор

			}

		//

		// Обновление параметров

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;
		finm1f = finf;
		Vnm1f = Vnf;

		//

		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени наведения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	//

	// Наведение БпЛА до дальности пуска АСП (или заданной дальности) //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_65 == true)                                                                        // Если инициализация исходных значений параметров разрешена при полете БпЛА до дальности пуска АСП (или заданной дальности)
	{
		Fish_65 = F_n;                                                                          // Исходное значение отсчета времени в начале полета БпЛА до дальности пуска АСП (или заданной дальности)

        if ((Prpo == 1) && ((Pnpt == 0) || (Pnpt == 2)))
        {
            xgnt = result2.getPosition().getX() - D_pol * sin(fint);
            ygnt = result2.getPosition().getY() - D_pol * cos(fint);
        }

        if ((Prpo == 1) && (Pnpt == 1))
        {
            xgnt = result2.getPosition().getX() + D_pol * sin(fint);
            ygnt = result2.getPosition().getY() + D_pol * cos(fint);
        }

        Dish_65 = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf));
		
		if (Pasp == 1)
		{
			dHish_65 = 5.0 * R_os - hn;
		}
		else
		{
			dHish_65 = 0.0;
		}
		
		Hish_65 = hn;
		Vish_65 = Vnf;

		init_65 = false;                                                                        // Запрет инициализации исходных значений параметров в начале полета БпЛА до дальности пуска АСП (или заданной дальности)
	}
		
    Dn = sqrt((xgnm1t - xgnm1f) * (xgnm1t - xgnm1f) + (ygnm1t - ygnm1f) * (ygnm1t - ygnm1f));           // Расчет расстояния до НПЦ

    if ((Prpo == 1) && (init_68 == true))
    {
        if ((Pnpt == 0) || (Pnpt == 2))
        {
            xgnm1t = result2.getPosition().getX() - D_pol * sin(finm1t);
            ygnm1t = result2.getPosition().getY() - D_pol * cos(finm1t);
        }

        if (Pnpt == 1)
        {
            xgnm1t = result2.getPosition().getX() + D_pol * sin(finm1t);
            ygnm1t = result2.getPosition().getY() + D_pol * cos(finm1t);
        }

        Dn = sqrt((xgnm1t - xgnm1f) * (xgnm1t - xgnm1f) + (ygnm1t - ygnm1f) * (ygnm1t - ygnm1f));
    }

	double tetasn = -(asin(dHish_65 / Dish_65) + Pi / 2.0) / 2.0 * (0.0035 * missile_Dpm + 2.0);
	double dV = (plane.ttx_bpla.V_ataki - Vish_65) * dt;
	double Nsn = ceil(Dish_65 / ((plane.ttx_bpla.V_ataki + Vish_65) / 2.0)) / dt;
	double dteta = (tetasn - tetaish_65) / Nsn;                                             // Шаг изменения угла снижения БпЛА до среднего значения текущей и заданной высот
	
    double D_at = missile_Dpm;                                                                  // Дальность пуска АСП

    if (Prpo == 1 && Pasp == 0)
    {
        D_at = missile_Dpm / 2;
    }
	
	while (Dn >= D_at)                                                                          // До тех пор, пока дальность до НПЦ больше или равна дальности обнаружения БРЛС
	{

		if (init_67 == false || init_68 == false || init_69 == false || init_70 == false)       // Если уже рассчитывается следующие этапы полета БпЛА при наведении 
		{
			break;                                                                              // Стоп
		}


		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time == -1)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);

		if (Pasp == 1)
		{
			if (hn > 0.5 * (Hish_65 + 5.0 * R_os))                                                  // Если рассчитываемая высота больше среднего значения текущей и заданной высот
			{
				if (tetanf > tetasn)                                                                // Если угол наклона траектории БпЛА в n-й момент времени больше заданного угла снижения высоты БпЛА
				{
					tetanf = tetanm1f + dteta;                                                      // Расчет угла снижения высоты БпЛА в n-й момент времени
				}

				if (tetanf <= tetasn)                                                               // Если угол наклона траектории БпЛА в n-й момент времени меньше или равен заданному углу снижения высоты БпЛА                                                                               // В противном случае
				{
					tetanf = tetasn;                                                                // Угол снижения высоты БпЛА в n-й момент времени приравнивается к заданному углу снижения высоты БпЛА
				}

			}

			if (hn > 5.0 * R_os && hn <= 0.5 * (Hish_65 + 5.0 * R_os))                              // Если рассчитываемая высота больше заданной высоты БпЛА
			{
				if (tetanf < (2.0 / dt) * dteta)                                                    // Если угол наклона траектории БпЛА в n-й момент времени меньше 5 шагов изменения угла наклона траектории при снижении БпЛА
				{
					tetanf = tetanm1f - dteta;                                                      // Расчет угла снижения высоты БпЛА в n-й момент времени
				}

				if (tetanf >= (2.0 / dt) * dteta)                                                   // Если угол наклона траектории БпЛА в n-й момент времени больше или равен 5 шагам изменения угла наклона траектории при снижении БпЛА
				{
					tetanf = (2.0 / dt) * dteta;                                                    // Угол наклона траектории БпЛА в n-й момент времени приравнивается к 5 шагам изменения угла наклона траектории при снижении БпЛА
				}

			}

			if (Vnf < plane.ttx_bpla.V_ataki)                                                       // Если скорость снижения высоты в n-й момент времени меньше 1,05 скорости в начале снижения
			{
				Vnf = Vnm1f + dV;                                                                   // Расчет скорости БпЛА в n-й момент времени
			}

			if (Vnf >= plane.ttx_bpla.V_ataki)                                                      // Если скорость снижения высоты в n-й момент времени больше или равна 1,05 скорости в начале снижения
			{
				Vnf = plane.ttx_bpla.V_ataki;                                                       // Скорость БпЛА в n-й момент времени приравнивается к 1,05 скорости в начале снижения
			}

		}
		else
		{
			tetanm1f = 0.0;                                                // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
			tetanf = tetanm1f;                                             // Расчет угла наклона траектории БпЛА в n-й момент времени
			Vnf = Vnm1f;		                                           // Расчет скорости БпЛА в n-й момент времени
		}

		fint = curTarPos.fi;

		xnt = curTarPos.x;                                                 // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                                 // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                                 // Координата z НПЦ в геоцентрической СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                      // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                           // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК
		
		if ((Prpo == 1) && ((Pnpt == 0) || (Pnpt == 2)))
		{
			xgnt = result2.getPosition().getX() - D_pol * sin(fint);
			ygnt = result2.getPosition().getY() - D_pol * cos(fint);
		}

		if ((Prpo == 1) && (Pnpt == 1))
		{
			xgnt = result2.getPosition().getX() + D_pol * sin(fint);
			ygnt = result2.getPosition().getY() + D_pol * cos(fint);
		}

		fn_bzps = atan((xgnt - xgnf) / (ygnt - ygnf));                     // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bzps = fn_bzps;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bzps = fn_bzps + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bzps = fn_bzps + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bzps = fn_bzps + Pi;
					}

		//  

		double dfif = (fn_bzps - finm1f) * dt;                                    // Расчет шага изменения угла поворота траектории БпЛА

		if (abs(finf - fn_bzps) > abs(dfif))
		{
			finf = finm1f + dfif;
		}
		else
		{
			finf = fn_bzps;
		}
		
		
		Vxgnf = Vnf * cos(tetanf) * sin(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		Vygnf = Vnf * cos(tetanf) * cos(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		Vzgnf = Vnf * sin(tetanf);                                                  // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgnf = xgnm1f + Vxgnf * dt;                                                 // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygnf = ygnm1f + Vygnf * dt;                                                 // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgnf = zgnm1f + Vzgnf * dt;                                                 // Расчет координаты zg БпЛА в местной СК в n-й момент времени
				
		// Приведение значения dfif к требуемому виду

		if (dfif > Pi / 2.0)
		{
			dfif = dfif - 2.0 * Pi;
		}

		if (dfif < -Pi / 2.0)
		{
			dfif = dfif + 2.0 * Pi;
		}

		//

		// Расчет угла скоростного крена БпЛА

		if (Fish_65 <= F_n && F_n < Fish_65 + (2 / dt))
		{
			double gammafmin = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));
			double gammafmax = this->plane.curPos.gamma;
			double dgamma = (gammafmax - gammafmin) * dt;
			gammanf = this->plane.curPos.gamma - dgamma;
		}
		else
		{
			if (F_n != cur_F_n - deltaF)
			{
				gammanf = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени
			}
			else
			{
				gammanf = gammanm1f;
			}
		}

		//

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();          		                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if ((hn != Hish_64) && (Pasp == 0))                                                 // Если текущая высота не равна исходной высоте в начале наведения БпЛА в ЗПС
		{
			hn = Hish_64;                                                                   // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));           // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                              // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                            // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                            // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                            // Определение координаты zg БпЛА в местной СК в n-й момент времени

		}

		if ((hn < 5.0 * R_os) && (Pasp == 1))                                               // Если текущая высота не равна исходной высоте в начале наведения БпЛА в ЗПС
		{
			hn = 5.0 * R_os;                                                                // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени

		}

		//

		Dn = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf));            // Расчет расстояния до НПЦ в n-й момент времени

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                            // Запись n-й точки в фильм
       
		// Обновление параметров //

		Vnm1f = Vnf;
		finm1f = finf;
		gammanm1f = gammanf;
		tetanm1f = tetanf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		this->plane.curPos.time = F_LastTime;
		this->plane.curPos.x = xnf;
		this->plane.curPos.y = ynf;
		this->plane.curPos.z = znf;
		this->plane.curPos.vx = Vxnf;
		this->plane.curPos.vy = Vynf;
		this->plane.curPos.vz = Vznf;
		this->plane.curPos.fi = finf;                                                // в радианах 
		this->plane.curPos.teta = tetanf;                                            // в радианах
		this->plane.curPos.gamma = gammanf;                                          // в радианах

		plane.Trajectory.push_back(plane.curPos);                                    // Запись n-й точки в вектор

		//

		F_n++;

		if (F_n == cur_F_n)                                                          // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени наведения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                // Продолжение полета БпЛА
		}

	}

	//

	// Горизонтирование БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_67 == true)                                                                       // Если инициализация исходных значений параметров разрешена при горизонтровании БпЛА
	{
		gammaish_67 = gammanf;                                                                 // Исходное значение угла скоростного крена БпЛА в начале горизонтирования
		Hish_67 = hn;
		init_67 = false;                                                                       // Запрет инициализации исходных значений параметров в начале горизонтирования БпЛА
	}

	while (abs(gammanf) > 0.0001)                                                              // До тех пор, пока скоростной крен БпЛА не равен 0
	{
		if (init_68 == false || init_69 == false || init_70 == false)                          // Если уже рассчитывается последующие этапы полета БпЛА в процессе наведения на НПЦ 
		{
			break;                                                                             // Стоп
		}

		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time == -1)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);

		fint = curTarPos.fi;

		xnt = curTarPos.x;                                                   // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                                   // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                                   // Координата z НПЦ в геоцентрической СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                        // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                   // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК

		if ((Prpo == 1) && ((Pnpt == 0) || (Pnpt == 2)))
		{
			xgnt = result2.getPosition().getX() - D_pol * sin(fint);
			ygnt = result2.getPosition().getY() - D_pol * cos(fint);
		}

		if ((Prpo == 1) && (Pnpt == 1))
		{
			xgnt = result2.getPosition().getX() + D_pol * sin(fint);
			ygnt = result2.getPosition().getY() + D_pol * cos(fint);
		}

		fn_bzps = atan((xgnt - xgnf) / (ygnt - ygnf));                      // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bzps = fn_bzps;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bzps = fn_bzps + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bzps = fn_bzps + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bzps = fn_bzps + Pi;
					}

		//

		Vnf = Vnm1f;		                                          // Расчет скорости БпЛА в n-й момент времени

		finf = fn_bzps;                                               // Расчет угла поворота траектории БпЛА в n-й момент времени

		tetanf = 0.0;                                                 // Расчет угла наклона траектории БпЛА в n-й момент времени

		Vxgnf = Vnf * sin(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		Vygnf = Vnf * cos(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		Vzgnf = 0.0;                                                  // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgnf = xgnm1f + Vxgnf * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygnf = ygnm1f + Vygnf * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgnf = zgnm1f + Vzgnf * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		// Расчет шага изменения угла скоростного крена БпЛА

		double dgamma = 0.0;

		if (gammaish_67 > 0.0)
		{
			dgamma = gammaish_67 / ceil(gammaish_67 * 180.0 / (Pi * (0.15 / dt)));
		}
		else
		{
			dgamma = gammaish_67 / floor(gammaish_67 * 180.0 / (Pi * (0.15 / dt)));
		}

		if ((gammanf < 0.0) && (abs(gammanf) > abs(dgamma)))
		{
			gammanf = gammanf + dgamma;
		}
		else
		if (gammanf > dgamma)
		{
			gammanf = gammanf - dgamma;
		}

		if (abs(gammanf) <= abs(dgamma))
		{
			gammanf = 0.0;
		}

		//

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);                 // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                                   // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                                   // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                                   // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));      // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                                     // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                               // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                              // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();          		                              // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if (hn != Hish_67)                                                    // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
		{
			hn = Hish_67;                                                     // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                             // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                        // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                 // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                 // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                 // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));           // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                              // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                            // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                            // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                            // Определение координаты zg БпЛА в местной СК в n-й момент времени

		}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                            // Запись n-й точки в фильм
       
		// Обновление параметров //

		Vnm1f = Vnf;
		finm1f = finf;
		tetanm1f = tetanf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		this->plane.curPos.time = F_LastTime;
		this->plane.curPos.x = xnf;
		this->plane.curPos.y = ynf;
		this->plane.curPos.z = znf;
		this->plane.curPos.vx = Vxnf;
		this->plane.curPos.vy = Vynf;
		this->plane.curPos.vz = Vznf;
		this->plane.curPos.fi = finf;                                               // в радианах 
		this->plane.curPos.teta = tetanf;                                           // в радианах
		this->plane.curPos.gamma = gammanf;                                         // в радианах

		plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

		//
		
		F_n++;

		if (F_n == cur_F_n)                                                         // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                               // Продолжение полета БпЛА
		}

	}

	if (Prpo == 1)
	{
		if (init_68 == true)                                                        // Если инициализация исходных значений параметров разрешена при наведении БпЛА на НПЦ до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса БпЛА 
		{
			
			Hish_68 = hn;                                                           // Задание высоты БпЛА в n-й момент времени в геодезической СК

            CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));   // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
            CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                      // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

            xgnm1t = result2.getPosition().getX();                                  // Определение координаты xg НПЦ в n-й момент времени в местной СК 
            ygnm1t = result2.getPosition().getY();                                  // Определение координаты yg НПЦ в n-й момент времени в местной СК

			ft_68 = atan((xgnm1t - xgnm1f) / (ygnm1t - ygnm1f));                    // Расчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА

			// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА //

			if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
			{
				ft_68 = ft_68;
			}
			else
				if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) < 0.0))
				{
					ft_68 = ft_68 + Pi;
				}
				else
					if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
					{
						ft_68 = ft_68 + 2 * Pi;
					}
					else
						if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) < 0.0))
						{
							ft_68 = ft_68 + Pi;
						}

			//

			double Vf_68 = sqrt(Vxnm1f * Vxnm1f + Vynm1f * Vynm1f + Vznm1f * Vznm1f);                  // Определение скорости БпЛА в начальный момент времени

            // Задание значения шага изменения угла поворота траектории БпЛА //

            double R = Vf_68 * Vf_68 / (Settings.getEarthGravity() * kren_maxf * Pi / 180.0);

            double L1 = abs(ft_68 - finm1f) * R;
            double L2 = (2 * Pi - abs(ft_68 - finm1f)) * R;

            if (L1 >= L2)
            {
                if ((ft_68 - finm1f) >= 0.0)
                {
                    dkurs_68 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_68) * dt;    // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
                }
                else
                {
                    dkurs_68 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_68) * dt;
                }
            }
            else
            {
                if ((ft_68 - finm1f) >= 0.0)
                {
                    dkurs_68 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_68) * dt;   // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
                }
                else
                {
                    dkurs_68 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_68) * dt;
                }
            }

			fn_68 = ft_68;                                                                             // Угол визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

			init_68 = false;                                                                           // Запрет инициализации исходных значений параметров в начале наведения БпЛА на НПЦ
		}

		//

		// Наведение БпЛА на НПЦ до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						 
		while ((abs(fn_68 - finf) >= 2 * abs(dkurs_68)))                         // До тех пор, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса
		{

			if (init_69 == false || init_70 == false)                            // Если уже рассчитывается последующие этапы полета БпЛА в процессе наведения на НПЦ 
			{
				break;                                                           // Стоп
			}
			
			curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

			if (curTarPosPlusDt.time == -1)
			{
				Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
				return -1;
			}

			curTarPos = getCurPosNPC(F_LastTime);
			
			xnt = curTarPos.x;                                             // Координата x НПЦ в геоцентрической СК в n-й момент времени
			ynt = curTarPos.y;                                             // Координата y НПЦ в геоцентрической СК в n-й момент времени
			znt = curTarPos.z;                                             // Координата z НПЦ в геоцентрической СК в n-й момент времени

			finf = finm1f + dkurs_68;                                      // Расчет угла поворота траектории БпЛА в n-й момент времени

			// Прведение угла finf к пределам от 0 до 2 пи

			if (finf >= 2 * Pi)
			{
				finf = finf - 2 * Pi;
			}

			if (finf < 0)
			{
				finf = finf + 2 * Pi;
			}

			//

			tetanm1f = 0.0;                                                // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
			tetanf = tetanm1f;                                             // Расчет угла наклона траектории БпЛА в n-й момент времени

			Vnf = Vnm1f;                                                   // Расчет скорости БпЛА в n-й момент времени

			Vxgnf = Vnf * cos(tetanf) * sin(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgXg в n-й момент времени
			Vygnf = Vnf * cos(tetanf) * cos(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgYg в n-й момент времени
			Vzgnf = Vnf * sin(tetanf);                                     // Расчет проекции вектора скорости БпЛА на ось OgZg в n-й момент времени

			xgnf = xgnm1f + dt * Vxgnf;                                    // Расчет координаты xg в n-й момент времени
			ygnf = ygnm1f + dt * Vygnf;                                    // Расчет координаты yg в n-й момент времени
			zgnf = zgnm1f + dt * Vzgnf;                                    // Расчет координаты zg в n-й момент времени

			gammanf = atan((dkurs_68)* Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени

			F_LastTime = F_LastTime + dt;                                  // Задание отсчетов времени

			CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
			CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                   // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

			xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
			ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
			zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

			xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();                                        // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Корректировка высоты БпЛА

			if (hn != Hish_68)                                             // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
			{
				hn = Hish_68;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));              // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			//

			fn_68 = atan((xgnt - xgnf) / (ygnt - ygnf));                                         // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

			// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
			{
				fn_68 = fn_68;
			}
			else
				if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
				{
					fn_68 = fn_68 + Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
					{
						fn_68 = fn_68 + 2 * Pi;
					}
					else
						if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
						{
							fn_68 = fn_68 + Pi;
						}

			//

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

			//

			Vxnf = Vnf * cos(cn) * sin(rn);         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vynf = Vnf * cos(cn) * cos(rn);         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vznf = Vnf * sin(cn);                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			// Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			double gamn0 = 0.0;

			if ((F_n >= 0) && (F_n < (2 / dt)))
			{
				double gamnmaxf = gammanf * 180.0 / Pi;
				double dgam = gamnmaxf * dt;
				double gamnf = gamn0 + F_n * dgam;
				Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
              
				this->plane.curPos.time = F_LastTime;
				this->plane.curPos.x = xnf;
				this->plane.curPos.y = ynf;
				this->plane.curPos.z = znf;
				this->plane.curPos.vx = Vxnf;
				this->plane.curPos.vy = Vynf;
				this->plane.curPos.vz = Vznf;
				this->plane.curPos.fi = finf;                                               // в радианах
				this->plane.curPos.teta = tetanf;                                           // в радианах
				this->plane.curPos.gamma = gamnf * Pi / 180.0;                              // в радианах

				plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

			}
			else
				if (F_n >= (2 / dt))
				{
					double gamnf = gammanf * 180.0 / Pi;                                 // Пересчет значения скоростного крена БпЛА в n-й момент времени из радиан в градусы для вывода на интерфейс
					Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
                   
					this->plane.curPos.time = F_LastTime;
					this->plane.curPos.x = xnf;
					this->plane.curPos.y = ynf;
					this->plane.curPos.z = znf;
					this->plane.curPos.vx = Vxnf;
					this->plane.curPos.vy = Vynf;
					this->plane.curPos.vz = Vznf;
					this->plane.curPos.fi = finf;                                         // в радианах
					this->plane.curPos.teta = tetanf;                                     // в радианах
					this->plane.curPos.gamma = gamnf * Pi / 180.0;                        // в радианах

					plane.Trajectory.push_back(plane.curPos);                             // Запись n-й точки в вектор

				}

			//

			// Обновление параметров

			xnm1f = xnf;
			ynm1f = ynf;
			znm1f = znf;

			xgnm1f = xgnf;
			ygnm1f = ygnf;
			zgnm1f = zgnf;
			finm1f = finf;
			Vnm1f = Vnf;

			//

			F_n++;

			if (F_n == cur_F_n)                                                           // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени наведения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                                 // Продолжение полета БпЛА
			}
		}

		//

		// Наведение до дальности пуска АСП //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (init_69 == true)                                                                        // Если инициализация исходных значений параметров разрешена при полете БпЛА до дальности пуска АСП
		{
			Fish_69 = F_n;                                                                          // Исходное значение отсчета времени в начале полета БпЛА до дальности пуска АСП

			Dish_69 = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf));
			
			init_69 = false;                                                                        // Запрет инициализации исходных значений параметров в начале полета БпЛА до дальности пуска АСП
		}

		Dn = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf));                   // Расчет расстояния до НПЦ
		
		while (Dn >= missile_Dpm)                                                                   // До тех пор, пока дальность до НПЦ больше или равна дальности пуска АСП
		{

			if (init_70 == false)                                                                   // Если уже рассчитывается следующие этапы полета БпЛА при наведении 
			{
				break;                                                                              // Стоп
			}
			
			curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

			if (curTarPosPlusDt.time == -1)
			{
				Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
				return -1;
			}

			curTarPos = getCurPosNPC(F_LastTime);

			tetanm1f = 0.0;                                                    // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
			tetanf = tetanm1f;                                                 // Расчет угла наклона траектории БпЛА в n-й момент времени
			Vnf = Vnm1f;		                                               // Расчет скорости БпЛА в n-й момент времени
						
			xnt = curTarPos.x;                                                 // Координата x НПЦ в геоцентрической СК в n-й момент времени
			ynt = curTarPos.y;                                                 // Координата y НПЦ в геоцентрической СК в n-й момент времени
			znt = curTarPos.z;                                                 // Координата z НПЦ в геоцентрической СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                      // Задание отсчетов времени

			CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
			CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                   // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

			xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
			ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
			zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК				

			fn_68 = atan((xgnt - xgnf) / (ygnt - ygnf));                         // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

			// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
			{
				fn_68 = fn_68;
			}
			else
				if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
				{
					fn_68 = fn_68 + Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
					{
						fn_68 = fn_68 + 2 * Pi;
					}
					else
						if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
						{
							fn_68 = fn_68 + Pi;
						}

			//  

			double dfif = (fn_68 - finm1f) * dt;                  // Расчет шага изменения угла поворота траектории БпЛА

			if (abs(finf - fn_68) > abs(dfif))
			{
				finf = finm1f + dfif;
			}
			else
			{
				finf = fn_68;
			}
						
			Vxgnf = Vnf * cos(tetanf) * sin(finf);                        // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			Vygnf = Vnf * cos(tetanf) * cos(finf);                        // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			Vzgnf = Vnf * sin(tetanf);                                    // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgnf = xgnm1f + Vxgnf * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = ygnm1f + Vygnf * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = zgnm1f + Vzgnf * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени
						
			// Приведение значения dfif к требуемому виду

			if (dfif > Pi / 2.0)
			{
				dfif = dfif - 2.0 * Pi;
			}

			if (dfif < -Pi / 2.0)
			{
				dfif = dfif + 2.0 * Pi;
			}

			//

			// Расчет угла скоростного крена БпЛА

			if (Fish_69 <= F_n && F_n < Fish_69 + (2 / dt))
			{
				double gammafmin = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));
				double gammafmax = this->plane.curPos.gamma;
				double dgamma = (gammafmax - gammafmin) * dt;
				gammanf = this->plane.curPos.gamma - dgamma;
			}
			else
			{
				if (F_n != cur_F_n - deltaF)
				{
					gammanf = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени
				}
				else
				{
					gammanf = gammanm1f;
				}
			}

			//

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

			xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();          		                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Корректировка высоты БпЛА

			if ((hn != Hish_68) && (Pasp == 0))                                                  // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
			{
				hn = Hish_68;                                                                    // Задание высоты БпЛА в n-й момент времени в геодезической СК

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			if ((hn < 5.0 * R_os) && (Pasp == 1))                                                // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
			{
				hn = 5.0 * R_os;                                                                 // Задание высоты БпЛА в n-й момент времени в геодезической СК

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			//

			Dn = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf));            // Расчет расстояния до НПЦ в n-й момент времени

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

			//

			Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                            // Запись n-й точки в фильм
           
			// Обновление параметров //

			Vnm1f = Vnf;
			finm1f = finf;
			gammanm1f = gammanf;
			tetanm1f = tetanf;

			xgnm1f = xgnf;
			ygnm1f = ygnf;
			zgnm1f = zgnf;

			xnm1f = xnf;
			ynm1f = ynf;
			znm1f = znf;

			this->plane.curPos.time = F_LastTime;
			this->plane.curPos.x = xnf;
			this->plane.curPos.y = ynf;
			this->plane.curPos.z = znf;
			this->plane.curPos.vx = Vxnf;
			this->plane.curPos.vy = Vynf;
			this->plane.curPos.vz = Vznf;
			this->plane.curPos.fi = finf;                                                // в радианах 
			this->plane.curPos.teta = tetanf;                                            // в радианах
			this->plane.curPos.gamma = gammanf;                                          // в радианах

			plane.Trajectory.push_back(plane.curPos);                                    // Запись n-й точки в вектор

			//

			F_n++;

			if (F_n == cur_F_n)                                                         // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени наведения БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                               // Продолжение полета БпЛА
			}

		}

		//

		// Горизонтирование БпЛА //
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (init_70 == true)                                                    // Если инициализация исходных значений параметров разрешена при горизонтровании БпЛА
		{
			gammaish_70 = gammanf;                                              // Исходное значение угла скоростного крена БпЛА в начале горизонтирования
			Hish_70 = hn;
			init_70 = false;                                                    // Запрет инициализации исходных значений параметров в начале горизонтирования БпЛА
		}

		while (abs(gammanf) > 0.0001)                                                  // До тех пор, пока скоростной крен БпЛА не равен 0
		{

			curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

			if (curTarPosPlusDt.time == -1)
			{
				Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Наведение невозможно. Цель отсутствует");    // Запись в фильм комментария
				return -1;
			}

			curTarPos = getCurPosNPC(F_LastTime);
						
			xnt = curTarPos.x;                                                   // Координата x НПЦ в геоцентрической СК в n-й момент времени
			ynt = curTarPos.y;                                                   // Координата y НПЦ в геоцентрической СК в n-й момент времени
			znt = curTarPos.z;                                                   // Координата z НПЦ в геоцентрической СК в n-й момент времени

			F_LastTime = F_LastTime + dt;                                        // Задание отсчетов времени

			CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
			CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                   // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

			xgnt = result2.getPosition().getX();                                 // Определение координаты xg НПЦ в n-й момент времени в местной СК 
			ygnt = result2.getPosition().getY();                                 // Определение координаты yg НПЦ в n-й момент времени в местной СК
			zgnt = result2.getPosition().getZ();                                 // Определение координаты zg НПЦ в n-й момент времени в местной СК
						
			fn_68 = atan((xgnt - xgnf) / (ygnt - ygnf));                         // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

			// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
			{
				fn_68 = fn_68;
			}
			else
				if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
				{
					fn_68 = fn_68 + Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
					{
						fn_68 = fn_68 + 2 * Pi;
					}
					else
						if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
						{
							fn_68 = fn_68 + Pi;
						}

			//

			Vnf = Vnm1f;		                                          // Расчет скорости БпЛА в n-й момент времени

			finf = fn_68;                                                 // Расчет угла поворота траектории БпЛА в n-й момент времени

			tetanf = 0.0;                                                 // Расчет угла наклона траектории БпЛА в n-й момент времени

			Vxgnf = Vnf * sin(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
			Vygnf = Vnf * cos(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
			Vzgnf = 0.0;                                                  // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

			xgnf = xgnm1f + Vxgnf * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = ygnm1f + Vygnf * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = zgnm1f + Vzgnf * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

			// Расчет шага изменения угла скоростного крена БпЛА

			double dgamma = 0.0;

			if (gammaish_70 > 0.0)
			{
				dgamma = gammaish_70 / ceil(gammaish_70 * 180.0 / (Pi * (0.15 / dt)));
			}
			else
			{
				dgamma = gammaish_70 / floor(gammaish_70 * 180.0 / (Pi * (0.15 / dt)));
			}

			if ((gammanf < 0.0) && (abs(gammanf) > abs(dgamma)))
			{
				gammanf = gammanf + dgamma;
			}
			else
				if (gammanf > dgamma)
				{
					gammanf = gammanf - dgamma;
				}

			if (abs(gammanf) <= abs(dgamma))
			{
				gammanf = 0.0;
			}

			//

			CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
			CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

			xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
			CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

			Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
			Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
			hn = pgn.getAltitude();          		                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

			// Корректировка высоты БпЛА

			if (hn != Hish_70)                                             // Если текущая высота не равна исходной высоте в начале наведения БпЛА на НПЦ
			{
				hn = Hish_70;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

				CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
				CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

				xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
				ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
				znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

				CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
				CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

				xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
				ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
				zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
			}

			//

			// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

			double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
			{
				rn = rn;
			}
			else
				if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
				{
					rn = rn + Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
					{
						rn = rn + 2 * Pi;
					}
					else
						if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
						{
							rn = rn + Pi;
						}

			double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

			//

			Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
			Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
			Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

			double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

			Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                   // Запись n-й точки в фильм
            
			// Обновление параметров //

			Vnm1f = Vnf;
			finm1f = finf;
			tetanm1f = tetanf;

			xgnm1f = xgnf;
			ygnm1f = ygnf;
			zgnm1f = zgnf;

			xnm1f = xnf;
			ynm1f = ynf;
			znm1f = znf;

			this->plane.curPos.time = F_LastTime;
			this->plane.curPos.x = xnf;
			this->plane.curPos.y = ynf;
			this->plane.curPos.z = znf;
			this->plane.curPos.vx = Vxnf;
			this->plane.curPos.vy = Vynf;
			this->plane.curPos.vz = Vznf;
			this->plane.curPos.fi = finf;                                               // в радианах 
			this->plane.curPos.teta = tetanf;                                           // в радианах
			this->plane.curPos.gamma = gammanf;                                         // в радианах

			plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

			//

			F_n++;

			if (F_n == cur_F_n)                                                         // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования БпЛА в конце интервала моделирования траектории БпЛА (1 с)
			{
				return 0;                                                               // Продолжение полета БпЛА
			}

		}
	}
	
	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Вышел в точку атаки");         // Запись в фильм комментария

	y_TA = this->plane.curPos.y;
	x_TA = this->plane.curPos.x;
	z_TA = this->plane.curPos.z;
	fi_TA = this->plane.curPos.fi;

	init_64 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при бортовом наведении БпЛА на НПЦ
	init_65 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при полете БпЛА до дальности пуска АСП (или заданной дальности)
	init_67 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при горизонтировании БпЛА
	init_68 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при бортовом наведении БпЛА на НПЦ
	init_69 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при полете БпЛА до дальности пуска АСП
	init_70 = true;                                                                             // ПризнБпЛА разрешения инициализации исходных значений параметров при горизонтировании БпЛА

	F_n = 0;                                                                                    // Установление текущего отсчета положения БпЛА в 0

	return 1;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////// Модель вывода БпЛА в район НПЦ ////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CFlightDynamicsBpLA::Vyvod_v_boevoe_soprikosnovenie()
{
	
	// Задание начальных значений параметров //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	
	int deltaF = (int)round((maxT - F_LastTime) / dt);                 // Количество отсчетов за интервал моделирования траектории БпЛА (1 с)

	if (deltaF < 1)
	{
		return 0;
	}

	size_t cur_F_n = F_n + deltaF;                                     // Номер отсчета времени разбега БпЛА в конце интервала моделирования траектории БпЛА (1 с)

	// Определение факта существования траектории НПЦ
	
	curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

	if (curTarPosPlusDt.time == -1)
	{
		Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Выход в исходную точку наведения невозможен. Цель отсутствует");    // Запись в фильм комментария
		return -1;
	}

	curTarPos = getCurPosNPC(F_LastTime);

	// Обновление параметров с интервалом 1 с

	double xnm1t = curTarPos.x;
	double ynm1t = curTarPos.y;
	double znm1t = curTarPos.z;
	double Vxnm1t = curTarPos.vx;
	double Vynm1t = curTarPos.vy;
	double Vznm1t = curTarPos.vz;
	double finm1t = curTarPos.fi;                                    // в радианах
	double tetanm1t = curTarPos.teta;                                // в радианах
	double gammanm1t = curTarPos.gamma;                              // в радианах

	double xnm1f = this->plane.curPos.x;
	double ynm1f = this->plane.curPos.y;
	double znm1f = this->plane.curPos.z;
	double Vxnm1f = this->plane.curPos.vx;
	double Vynm1f = this->plane.curPos.vy;
	double Vznm1f = this->plane.curPos.vz;
	double finm1f = this->plane.curPos.fi;                           // в радианах
	double tetanm1f = this->plane.curPos.teta;                       // в радианах
	double gammanm1f = this->plane.curPos.gamma;                     // в радианах

	//

	// Приведение finm1f к интервалу от 0 до 2 пи

	if (finm1f >= 2 * Pi)
	{
		finm1f = finm1f - 2 * Pi;
	}

	if (finm1f < 0)
	{
		finm1f = finm1f + 2 * Pi;
	}

	//

	// Приведение fit к интервалу от 0 до 2 пи

	if (finm1t >= 2 * Pi)
	{
		finm1t = finm1t - 2 * Pi;
	}

	if (finm1t < 0)
	{
		finm1t = finm1t + 2 * Pi;
	}

	//
	
	CPointGlobal pt = CPointGlobal(F_LastTime, CPoint3D(xnm1t, ynm1t, znm1t));   // Создание начальной точки НПЦ в геоцентрической СК
	CPointGlobal pf = CPointGlobal(F_LastTime, CPoint3D(xnm1f, ynm1f, znm1f));   // Создание начальной точки БпЛА в геоцентрической СК

	CPointGeo pgf = pf.toPointGeo();                                             // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

	double Bnm1 = pgf.getLatitude();                                             // Определение широты БпЛА в (n-1)-й момент времени в геодезической СК
	double Lnm1 = pgf.getLongitude();                                            // Определение долготы БпЛА в (n-1)-й момент времени в геодезической СК
	double hnm1 = pgf.getAltitude();                                             // Определение высоты БпЛА в (n-1)-й момент времени в геодезической СК

	CPoint3D zentrnm1f(xnm1f, ynm1f, znm1f);                                     // Создание центра местной СК в начальной точке АК

	CPointLocal result1 = pf.toPointLocal(zentrnm1f);                            // Перевод точки pf из геоцентрической СК в местную СК 
	CPointLocal result2 = pt.toPointLocal(zentrnm1f);                            // Перевод точки pt из геоцентрической СК в местную СК 

	double xgnm1f = result1.getPosition().getX();                                // Определение координаты xg БпЛА в местной СК в начальной точке 
	double xgnm1t = result2.getPosition().getX();                                // Определение координаты xg НПЦ в местной СК в начальной точке 

	double ygnm1f = result1.getPosition().getY();                                // Определение координаты yg БпЛА в местной СК в начальной точке
	double ygnm1t = result2.getPosition().getY();                                // Определение координаты yg НПЦ в местной СК в начальной точке

	double zgnm1f = result1.getPosition().getZ();                                // Определение координаты zg БпЛА в местной СК в начальной точке
	double zgnm1t = result2.getPosition().getZ();                                // Определение координаты zg НПЦ в местной СК в начальной точке
	
	double Vnm1f = sqrt(Vxnm1f * Vxnm1f + Vynm1f * Vynm1f + Vznm1f * Vznm1f);    // Скорость БпЛА в (n-1)-й момент времени
	double Vnf = Vnm1f;                                                          // Скорость БпЛА в n-й момент времени

	double Vxgnm1f = Vnm1f * cos(tetanm1f) * sin(finm1f);                        // Расчет проекции вектора скорости БпЛА на ось OgXg в начальный момент времени
	double Vygnm1f = Vnm1f * cos(tetanm1f) * cos(finm1f);                        // Расчет проекции вектора скорости БпЛА на ось OgYg в начальный момент времени
	double Vzgnm1f = Vnm1f * sin(tetanm1f);                                      // Расчет проекции вектора скорости БпЛА на ось OgZg в начальный момент времени

	double Vxgnf = Vxgnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgXg в МСК в n-й момент времени 
	double Vygnf = Vygnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgYg в МСК в n-й момент времени 
	double Vzgnf = Vzgnm1f;                                                      // Определение проекции вектора скорости БпЛА на ось OgZg в МСК в n-й момент времени 

	double Vnm1t = sqrt(Vxnm1t * Vxnm1t + Vynm1t * Vynm1t + Vznm1t * Vznm1t);    // Скорость НПЦ в (n-1)-й момент времени
	double Vnt = Vnm1t;                                                          // Начальное значение скорости НПЦ в n-й момент времени

	double finf = finm1f;                                                        // Угол поворота траектории БпЛА в n-й момент времени	
	double tetanf = tetanm1f;                                                    // Угол наклона траектории БпЛА в n-й момент времени
	double gammanf = gammanm1f;                                                  // Угол скоростного крена БпЛА в n-й момент времени в радианах

	double xgnf = xgnm1f;                                                        // Определение координаты xg БпЛА в местной СК в n-й момент времени 	
	double ygnf = ygnm1f;                                                        // Определение координаты yg БпЛА в местной СК в n-й момент времени 
	double zgnf = zgnm1f;                                                        // Определение координаты zg БпЛА в местной СК в n-й момент времени 

	double xnf = xnm1f;                                                          // Определение координаты x БпЛА в геоцентрической СК в n-й момент времени 
	double ynf = ynm1f;                                                          // Определение координаты y БпЛА в геоцентрической СК в n-й момент времени 
	double znf = znm1f;                                                          // Определение координаты z БпЛА в геоцентрической СК в n-й момент времени 

	double Vxnf = Vxnm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OX в геоцентрической СК в n-й момент времени 
	double Vynf = Vynm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OY в геоцентрической СК в n-й момент времени 
	double Vznf = Vznm1f;                                                        // Определение проекции вектора скорости БпЛА на ось OZ в геоцентрической СК в n-й момент времени 

	double Bn = Bnm1;                                                            // Определение широты БпЛА в n-й момент времени в геодезической СК
	double Ln = Lnm1;                                                            // Определение долготы БпЛА в n-й момент времени в геодезической СК
	double hn = hnm1;                                                            // Определение высоты БпЛА в n-й момент времени в геодезической СК

	double fint = finm1t;                                                        // Угол поворота траектории БпЛА в n-й момент времени	

	double xnt = xnm1t;                                                          // Определение координаты x НПЦ в ГСК в n-й момент времени
	double ynt = ynm1t;                                                          // Определение координаты y НПЦ в ГСК в n-й момент времени
	double znt = znm1t;                                                          // Определение координаты z НПЦ в ГСК в n-й момент времени 

	double xgnt = xgnm1t;                                                        // Определение координаты xg НПЦ в МСК в n-й момент времени
	double ygnt = ygnm1t;                                                        // Определение координаты yg НПЦ в ГСК в n-й момент времени
	double zgnt = zgnm1t;                                                        // Определение координаты zg НПЦ в МСК в n-й момент времени

    double kren_maxf = this->plane.ttx_bpla.kren_max;                            // Максимально допустимый угол крена БпЛА
	
	//
			
	//

	if (init_72 == true)                                                        // Если инициализация исходных значений параметров разрешена при выводе БпЛА в боевое соприкосновение до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса БпЛА 
	{
		Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Начал выход в исходную точку наведения");                   // Запись в фильм комментария

		Hish_72 = hn;                                                           // Задание высоты БпЛА в n-й момент времени в геодезической СК
		
		ft_72 = atan((xgnm1t - xgnm1f) / (ygnm1t - ygnm1f));                    // Расчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА //

		if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
		{
			ft_72 = ft_72;
		}
		else
			if (((xgnm1t - xgnm1f) >= 0.0) && ((ygnm1t - ygnm1f) < 0.0))
			{
				ft_72 = ft_72 + Pi;
			}
			else
				if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) >= 0.0))
				{
					ft_72 = ft_72 + 2 * Pi;
				}
				else
					if (((xgnm1t - xgnm1f) < 0.0) && ((ygnm1t - ygnm1f) < 0.0))
					{
						ft_72 = ft_72 + Pi;
					}

		//

		double Vf_72 = sqrt(Vxnm1f * Vxnm1f + Vynm1f * Vynm1f + Vznm1f * Vznm1f);                // Определение скорости БпЛА в начальный момент времени

        // Задание значения шага изменения угла поворота траектории БпЛА //

        double R = Vf_72 * Vf_72 / (Settings.getEarthGravity() * kren_maxf * Pi / 180.0);

        double L1 = abs(ft_72 - finm1f) * R;
        double L2 = (2 * Pi - abs(ft_72 - finm1f)) * R;

        if (L1 >= L2)
        {
            if ((ft_72 - finm1f) >= 0.0)
            {
                dkurs_72 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_72) * dt;    // Задание значения шага изменения угла поворота траектории БпЛА при правом развороте
            }
            else
            {
                dkurs_72 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_72) * dt;
            }
        }
        else
        {
            if ((ft_72 - finm1f) >= 0.0)
            {
                dkurs_72 = (Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_72) * dt;   // Задание значения шага изменения угла поворота траектории БпЛА при левом развороте
            }
            else
            {
                dkurs_72 = -(Settings.getEarthGravity() * tan(kren_maxf * Pi / 180.0) / Vf_72) * dt;
            }
        }
		
		fn_bs = ft_72;                                                                           // Угол визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		init_72 = false;                                                                         // Запрет инициализации исходных значений параметров в начале вывода БпЛА в район НПЦ
	}

	//

	// Полет до момента, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 1 градуса //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	while ((abs(fn_bs - finf) >= abs(dkurs_72)))                                            // До тех пор, пока разность угла визирования в горизонтальной плоскости и угла поворота траектории больше 2 градусов
	{

		if (init_73 == false || init_74 == false)                                               // Если уже рассчитывается последующие этапы полета БпЛА в процессе вывода в район НПЦ 
		{
			break;                                                                              // Стоп
		}
		
		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time < 0)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Выход в исходную точку наведения невозможен. Цель отсутствует");
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);

		fint = curTarPos.fi;

		xnt = curTarPos.x;                                             // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                             // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                             // Координата z НПЦ в геоцентрической СК в n-й момент времени

		finf = finm1f + dkurs_72;                                      // Расчет угла поворота траектории БпЛА в n-й момент времени

		// Прведение угла finf к пределам от 0 до 2 пи

		if (finf >= 2 * Pi)
		{
			finf = finf - 2 * Pi;
		}

		if (finf < 0)
		{
			finf = finf + 2 * Pi;
		}

		//

		tetanm1f = 0.0;                                                // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
		tetanf = tetanm1f;                                             // Расчет угла наклона траектории БпЛА в n-й момент времени

		Vnf = Vnm1f;                                                   // Расчет скорости БпЛА в n-й момент времени

		Vxgnf = Vnf * cos(tetanf) * sin(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgXg в n-й момент времени
		Vygnf = Vnf * cos(tetanf) * cos(finf);                         // Расчет проекции вектора скорости БпЛА на ось OgYg в n-й момент времени
		Vzgnf = Vnf * sin(tetanf);                                     // Расчет проекции вектора скорости БпЛА на ось OgZg в n-й момент времени

		xgnf = xgnm1f + dt * Vxgnf;                                    // Расчет координаты xg в n-й момент времени
		ygnf = ygnm1f + dt * Vygnf;                                    // Расчет координаты yg в n-й момент времени
		zgnf = zgnm1f + dt * Vzgnf;                                    // Расчет координаты zg в n-й момент времени

		gammanf = atan((dkurs_72)* Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени

		F_LastTime = F_LastTime + dt;                                  // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);             // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                           // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                           // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                           // Определение координаты zg НПЦ в n-й момент времени в местной СК

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));      // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();                                        // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if (hn != Hish_72)                                             // Если текущая высота не равна исходной высоте в начале вывода БпЛА в боевое соприкосновение
		{
			hn = Hish_72;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		//

		fn_bs = atan((xgnt - xgnf) / (ygnt - ygnf));                                         // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bs = fn_bs;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bs = fn_bs + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bs = fn_bs + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bs = fn_bs + Pi;
					}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		// Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		double gamn0 = 0.0;

		if ((F_n >= 0) && (F_n < (2 / dt)))
		{
			double gamnmaxf = gammanf * 180.0 / Pi;
			double dgam = gamnmaxf * dt;
			double gamnf = gamn0 + F_n * dgam;
			Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
           
			this->plane.curPos.time = F_LastTime;
			this->plane.curPos.x = xnf;
			this->plane.curPos.y = ynf;
			this->plane.curPos.z = znf;
			this->plane.curPos.vx = Vxnf;
			this->plane.curPos.vy = Vynf;
			this->plane.curPos.vz = Vznf;
			this->plane.curPos.fi = finf;                                               // в радианах
			this->plane.curPos.teta = tetanf;                                           // в радианах
			this->plane.curPos.gamma = gamnf * Pi / 180.0;                              // в радианах

			plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

		}
		else
			if (F_n >= (2 / dt))
			{
				double gamnf = gammanf * 180.0 / Pi;                                 // Пересчет значения скоростного крена БпЛА в n-й момент времени из радиан в градусы для вывода на интерфейс
				Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);
              
				this->plane.curPos.time = F_LastTime;
				this->plane.curPos.x = xnf;
				this->plane.curPos.y = ynf;
				this->plane.curPos.z = znf;
				this->plane.curPos.vx = Vxnf;
				this->plane.curPos.vy = Vynf;
				this->plane.curPos.vz = Vznf;
				this->plane.curPos.fi = finf;                                         // в радианах
				this->plane.curPos.teta = tetanf;                                     // в радианах
				this->plane.curPos.gamma = gamnf * Pi / 180.0;                        // в радианах

				plane.Trajectory.push_back(plane.curPos);                             // Запись n-й точки в вектор

			}

		//

		// Обновление параметров

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;
		finm1f = finf;
		Vnm1f = Vnf;

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                                     // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени вывода БпЛА в район НПЦ в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                           // Продолжение полета БпЛА
		}
	}

	//

	// Полет до дальности действия бортовых средств //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_73 == true)                                                                        // Если инициализация исходных значений параметров разрешена при полете БпЛА до дальности действия бортовых средств
	{
		Fish_73 = F_n;                                                                          // Исходное значение отсчета времени в начале полета БпЛА до дальности действия бортовых средств

		init_73 = false;                                                                        // Запрет инициализации исходных значений параметров в начале полета БпЛА до дальности действия бортовых средств
	}

	double Dn = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf) + (zgnt - zgnf) * (zgnt - zgnf));    // Расчет расстояния до НПЦ
			
	while (Dn >= plane.D_bs)                                                                         // До тех пор, пока дальность до НПЦ больше или равна дальности действия бортовых средств
	{

		if (init_74 == false)                                                                  // Если уже рассчитывается следующие этапы полета БпЛА
		{
			break;                                                                             // Стоп
		}
								
		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time < 0)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Выход в исходную точку наведения невозможен. Цель отсутствует");
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);

		fint = curTarPos.fi;

		xnt = curTarPos.x;                                                 // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                                 // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                                 // Координата z НПЦ в геоцентрической СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                      // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                 // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                               // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                               // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                               // Определение координаты zg НПЦ в n-й момент времени в местной СК

		fn_bs = atan((xgnt - xgnf) / (ygnt - ygnf));                       // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bs = fn_bs;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bs = fn_bs + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bs = fn_bs + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bs = fn_bs + Pi;
					}

		//

		Vnf = Vnm1f;		                                          // Расчет скорости БпЛА в n-й момент времени

		double dfif = (fn_bs - finm1f) * dt;                          // Расчет шага изменения угла поворота траектории БпЛА

		if (abs(finf - fn_bs) > abs(dfif))
		{
			finf = finm1f + dfif;
		}
		else
		{
			finf = fn_bs;
		}
				
		tetanm1f = 0.0;                                               // Расчет угла наклона траектории БпЛА в (n-1)-й момент времени
		tetanf = tetanm1f;                                            // Расчет угла наклона траектории БпЛА в n-й момент времени

		Vxgnf = Vnf * sin(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		Vygnf = Vnf * cos(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		Vzgnf = 0.0;                                                  // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgnf = xgnm1f + Vxgnf * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygnf = ygnm1f + Vygnf * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgnf = zgnm1f + Vzgnf * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени
				
		// Приведение значения dfif к требуемому виду

		if (dfif > Pi / 2.0)
		{
			dfif = dfif - 2.0 * Pi;
		}

		if (dfif < -Pi / 2.0)
		{
			dfif = dfif + 2.0 * Pi;
		}

		//

		// Расчет угла скоростного крена БпЛА

		if (Fish_73 <= F_n && F_n < Fish_73 + (2 / dt))
		{
			double gammafmin = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));
			double gammafmax = this->plane.curPos.gamma;
			double dgamma = (gammafmax - gammafmin) * dt;
			gammanf = this->plane.curPos.gamma - dgamma;
		}
		else
		{
			if (F_n != cur_F_n - deltaF)
			{
				gammanf = atan(dfif * Vnf * cos(tetanf) / ((tetanf - tetanm1f) * Vnf + dt * Settings.getEarthGravity() * cos(tetanf)));       // Расчет угла скоростного крена БпЛА в n-й момент времени
			}
			else
			{
				gammanf = gammanm1f;
			}
		}

		//

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));     // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));        // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();          		                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if (hn != Hish_72)                                             // Если текущая высота не равна исходной высоте в начале вывода БпЛА в район НПЦ
		{
			hn = Hish_72;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		//
		Dn = sqrt((xgnt - xgnf) * (xgnt - xgnf) + (ygnt - ygnf) * (ygnt - ygnf) + (zgnt - zgnf) * (zgnt - zgnf));   // Расчет расстояния до НПЦ в n-й момент времени

		if (Dn < 7000.0 && (Dn - Dold) > 0.0 && Dold != 0)
		{
			return -1;
		}

		Dold = Dn;

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                            // Запись n-й точки в фильм
        
		// Обновление параметров //

		Vnm1f = Vnf;
		finm1f = finf;
		gammanm1f = gammanf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		this->plane.curPos.time = F_LastTime;
		this->plane.curPos.x = xnf;
		this->plane.curPos.y = ynf;
		this->plane.curPos.z = znf;
		this->plane.curPos.vx = Vxnf;
		this->plane.curPos.vy = Vynf;
		this->plane.curPos.vz = Vznf;
		this->plane.curPos.fi = finf;                                                // в радианах 
		this->plane.curPos.teta = tetanf;                                            // в радианах
		this->plane.curPos.gamma = gammanf;                                          // в радианах

		plane.Trajectory.push_back(plane.curPos);                                    // Запись n-й точки в вектор

		//
				
		F_n++;

		if (F_n == cur_F_n)                                                          // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени вывода БпЛА в район НПЦ в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                                // Продолжение полета БпЛА
		}

	}

	//
		
	// Горизонтирование БпЛА //
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (init_74 == true)                                                                       // Если инициализация исходных значений параметров разрешена при горизонтровании БпЛА
	{
		gammaish_74 = gammanf;                                                                 // Исходное значение угла скоростного крена БпЛА в начале горизонтирования

		init_74 = false;                                                                       // Запрет инициализации исходных значений параметров в начале горизонтирования БпЛА
	}

	while (abs(gammanf) > 0.001)                                                                     // До тех пор, пока скоростной крен БпЛА не равен 0
	{
		curTarPosPlusDt = getCurPosNPC(F_LastTime + dt);

		if (curTarPosPlusDt.time < 0)
		{
			Film.writeLog(this->plane.object.getObjNum(), F_LastTime + dt, "Выход в исходную точку наведения невозможен. Цель отсутствует");
			return -1;
		}

		curTarPos = getCurPosNPC(F_LastTime);
	
		fint = curTarPos.fi;
		xnt = curTarPos.x;                                                 // Координата x НПЦ в геоцентрической СК в n-й момент времени
		ynt = curTarPos.y;                                                 // Координата y НПЦ в геоцентрической СК в n-й момент времени
		znt = curTarPos.z;                                                 // Координата z НПЦ в геоцентрической СК в n-й момент времени

		F_LastTime = F_LastTime + dt;                                      // Задание отсчетов времени

		CPointGlobal pnt = CPointGlobal(F_LastTime, CPoint3D(xnt, ynt, znt));        // Создание точки pnt НПЦ в n-й момент времени в геоцентрической СК
		CPointLocal result2 = pnt.toPointLocal(zentrnm1f);                 // Перевод точки pnt из геоцентрической СК в местную СК с центром в начальной точке АК

		xgnt = result2.getPosition().getX();                               // Определение координаты xg НПЦ в n-й момент времени в местной СК 
		ygnt = result2.getPosition().getY();                               // Определение координаты yg НПЦ в n-й момент времени в местной СК
		zgnt = result2.getPosition().getZ();                               // Определение координаты zg НПЦ в n-й момент времени в местной СК

		fn_bs = atan((xgnt - xgnf) / (ygnt - ygnf));                       // Расчет угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени

		// Пересчет значения угла визирования НПЦ в горизонтальной плоскости из точки БпЛА в n-й момент времени //

		if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) >= 0.0))
		{
			fn_bs = fn_bs;
		}
		else
			if (((xgnt - xgnf) >= 0.0) && ((ygnt - ygnf) < 0.0))
			{
				fn_bs = fn_bs + Pi;
			}
			else
				if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) >= 0.0))
				{
					fn_bs = fn_bs + 2 * Pi;
				}
				else
					if (((xgnt - xgnf) < 0.0) && ((ygnt - ygnf) < 0.0))
					{
						fn_bs = fn_bs + Pi;
					}

		//

		Vnf = Vnm1f;		                                          // Расчет скорости БпЛА в n-й момент времени

		finf = fn_bs;                                                 // Расчет угла поворота траектории БпЛА в n-й момент времени

		tetanf = 0.0;                                                 // Расчет угла наклона траектории БпЛА в n-й момент времени

		Vxgnf = Vnf * sin(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgXg местной СК в n-й момент времени
		Vygnf = Vnf * cos(finf);                                      // Расчет проекции вектора скорости БпЛА на ось OgYg местной СК в n-й момент времени
		Vzgnf = 0.0;                                                  // Расчет проекции вектора скорости БпЛА на ось OgZg местной СК в n-й момент времени

		xgnf = xgnm1f + Vxgnf * dt;                                   // Расчет координаты xg БпЛА в местной СК в n-й момент времени
		ygnf = ygnm1f + Vygnf * dt;                                   // Расчет координаты yg БпЛА в местной СК в n-й момент времени
		zgnf = zgnm1f + Vzgnf * dt;                                   // Расчет координаты zg БпЛА в местной СК в n-й момент времени

		// Расчет шага изменения угла скоростного крена БпЛА

		double dgamma = 0.0;

		if (gammaish_74 > 0.0)
		{
			dgamma = gammaish_74 / floor(gammaish_74 * 180.0 / (Pi * (0.15 / dt)));
		}
		else
		{
			dgamma = gammaish_74 / ceil(gammaish_74 * 180.0 / (Pi * (0.15 / dt)));
		}

		if ((gammanf < 0.0) && (abs(gammanf) > abs(dgamma)))
		{
			gammanf = gammanf + dgamma;
		}
		else
			if (gammanf > dgamma)
			{
				gammanf = gammanf - dgamma;
			}

		if (abs(gammanf) <= abs(dgamma))
		{
			gammanf = 0.0;
		}

		//

		CPointLocal res1 = CPointLocal(F_LastTime, CPoint3D(xgnf, ygnf, zgnf));    // Создание точки БпЛА в n-й момент времени в местной СК
		CPointGlobal resgeo1 = res1.toPointGlobal(zentrnm1f);          // Перевод точки res1 из местной СК в геоцентрическую СК с центром в начальной точке АК

		xnf = resgeo1.getPosition().getX();                            // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
		ynf = resgeo1.getPosition().getY();                            // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
		znf = resgeo1.getPosition().getZ();                            // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

		CPointGlobal pnf = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));      // Создание точки pnf БпЛА в n-й момент времени в геоцентрической СК
		CPointGeo pgn = pnf.toPointGeo();                              // Преобразование созданной точки БпЛА из геоцентрической СК в геодезическую СК

		Bn = pgn.getLatitude();                                        // Определение широты БпЛА в n-й момент времени в геодезической СК
		Ln = pgn.getLongitude();                                       // Определение долготы БпЛА в n-й момент времени в геодезической СК
		hn = pgn.getAltitude();          		                       // Определение высоты БпЛА в n-й момент времени в геодезической СК

		// Корректировка высоты БпЛА

		if (hn != Hish_72)                                             // Если текущая высота не равна исходной высоте в начале вывода БпЛА в боевое соприкосновение
		{
			hn = Hish_72;                                              // Задание высоты БпЛА в n-й момент времени в геодезической СК

			CPointGeo pkgn = CPointGeo(F_LastTime, Bn, Ln, hn);                              // Создание точки со скорректированной высотой в n-й момент времени в геодезической СК
			CPointGlobal pkn = pkgn.toPointGlobal();                                         // Преобразование созданной точки из геодезической СК в геоцентрическую СК

			xnf = pkn.getPosition().getX();                                                  // Определение координаты x БпЛА в n-й момент времени в геоцентрической СК
			ynf = pkn.getPosition().getY();                                                  // Определение координаты y БпЛА в n-й момент времени в геоцентрической СК
			znf = pkn.getPosition().getZ();                                                  // Определение координаты z БпЛА в n-й момент времени в геоцентрической СК

			CPointGlobal pno = CPointGlobal(F_LastTime, CPoint3D(xnf, ynf, znf));            // Создание точки pno в n-й момент времени в геоцентрической СК
			CPointLocal result1 = pno.toPointLocal(zentrnm1f);                               // Перевод точки pno из геоцентрической СК в местную СК

			xgnf = result1.getPosition().getX();                                             // Определение координаты xg БпЛА в местной СК в n-й момент времени
			ygnf = result1.getPosition().getY();                                             // Определение координаты yg БпЛА в местной СК в n-й момент времени
			zgnf = result1.getPosition().getZ();                                             // Определение координаты zg БпЛА в местной СК в n-й момент времени
		}

		//

		// Определение углов пространственной ориентации БпЛА в геоцентрической СК //

		double rn = atan((xnf - xnm1f) / (ynf - ynm1f));

		if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) >= 0.0))
		{
			rn = rn;
		}
		else
			if (((xnf - xnm1f) >= 0.0) && ((ynf - ynm1f) < 0.0))
			{
				rn = rn + Pi;
			}
			else
				if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) >= 0.0))
				{
					rn = rn + 2 * Pi;
				}
				else
					if (((xnf - xnm1f) < 0.0) && ((ynf - ynm1f) < 0.0))
					{
						rn = rn + Pi;
					}

		double cn = atan((znf - znm1f) * cos(rn) / (ynf - ynm1f));

		//

		Vxnf = Vnf * cos(cn) * sin(rn);                         // Расчет проекции вектора скорости БпЛА на ось OX геоцентрической СК в n-й момент времени
		Vynf = Vnf * cos(cn) * cos(rn);                         // Расчет проекции вектора скорости БпЛА на ось OY геоцентрической СК в n-й момент времени
		Vznf = Vnf * sin(cn);                                   // Расчет проекции вектора скорости БпЛА на ось OZ геоцентрической СК в n-й момент времени

		double gamnf = gammanf * 180.0 / Pi;                    // Значение скоростного крена БпЛА в n-й момент времени в градусах для вывода на интерфейс

		Film.writePoint(this->plane.object.getObjNum(), F_LastTime, xnf, ynf, znf, Vxnf, Vynf, Vznf, gamnf);                   // Запись n-й точки в фильм
        
		// Обновление параметров //

		Vnm1f = Vnf;
		finm1f = finf;
		tetanm1f = tetanf;

		xgnm1f = xgnf;
		ygnm1f = ygnf;
		zgnm1f = zgnf;

		xnm1f = xnf;
		ynm1f = ynf;
		znm1f = znf;

		this->plane.curPos.time = F_LastTime;
		this->plane.curPos.x = xnf;
		this->plane.curPos.y = ynf;
		this->plane.curPos.z = znf;
		this->plane.curPos.vx = Vxnf;
		this->plane.curPos.vy = Vynf;
		this->plane.curPos.vz = Vznf;
		this->plane.curPos.fi = finf;                                               // в радианах 
		this->plane.curPos.teta = tetanf;                                           // в радианах
		this->plane.curPos.gamma = gammanf;                                         // в радианах

		plane.Trajectory.push_back(plane.curPos);                                   // Запись n-й точки в вектор

		//
		
		F_n++;

		if (F_n == cur_F_n)                                                         // Если текущий отсчет времени положения БпЛА равен номеру отсчета времени горизонтирования БпЛА в конце интервала моделирования траектории БпЛА (1 с)
		{
			return 0;                                                               // Продолжение полета БпЛА 
		}

	}

	Film.writeLog(plane.object.getObjNum(), F_LastTime, "Вышел в исходную точку наведения");    // Запись в фильм комментария

	init_72 = true;                                                                             // Признак разрешения инициализации исходных значений параметров при выводе БпЛА в район НПЦ
	init_73 = true;                                                                             // Признак разрешения инициализации исходных значений параметров при полете БпЛА до дальности действия бортовых средств
	init_74 = true;                                                                             // Признак разрешения инициализации исходных значений параметров при горизонтировании БпЛА

	F_n = 0;                                                                                    // Установление текущего отсчета положения БпЛА в 0

	return 1;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


MyTrajectoryBpLA CFlightDynamicsBpLA::getCurPosNPC(double c_time)
{

	MyTrajectoryBpLA curPosNPC;                                            // Параметры движения в текущий момент времени
	
	curPosNPC.time = -1;
	   
	
	if (ObjectList.getObject(NumTarg).isExist())
	{
		CTaskPoint STNPC = ObjectList.getObject(NumTarg).getSysMotion().computePoint(c_time);
		curPosNPC.x = STNPC.getPointGlobal().getPosition().getX();         // Координата x НПЦ в момент атаки
		curPosNPC.y = STNPC.getPointGlobal().getPosition().getY();         // Координата y НПЦ в момент атаки
		curPosNPC.z = STNPC.getPointGlobal().getPosition().getZ();         // Координата z НПЦ в момент атаки
		
		CPointLocal STNPCLocal = STNPC.getPointGlobal().toPointLocal(STNPC.getPointGlobal().getPosition());
		curPosNPC.fi = STNPCLocal.computeRadianSelfAzimuth();
		curPosNPC.fi = normalizeTo2Pi(curPosNPC.fi);
				
		curPosNPC.gamma = 0.0;
		curPosNPC.teta = 0.0;
		curPosNPC.time = c_time;                                           // Время существования НПЦ в момент атаки
	}

	return curPosNPC;
}


// Поиск по списку поражённых в данной колонне НПЦ
bool CFlightDynamicsBpLA::FindDead(int numNPC)
{
	if (OldStopNumbers.size() < 1)
		return true;

	for (int i = 0; OldStopNumbers.size(); i++)
	{
		int cNN = OldStopNumbers[i];
		if (OldStopNumbers[i] == numNPC)
		{
			return false;
		}
	}
	return true;


}
