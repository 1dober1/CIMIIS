// Файл 01_CEquationQuadratic.cpp
// Обыкновенное квадратное уравнение
//

//=====================================================================================================================
// Заголовочные файлы
#include "01_CEquationQuadratic.h"




//=====================================================================================================================
// Конструктор класса
CEquationQuadratic::CEquationQuadratic(double a, double b, double c)
{
    myA = a;
    myB = b;
    myC = c;
}




//=====================================================================================================================
// Признак вырожденного уравнения
bool CEquationQuadratic::isConfluent() const
{
    // Уравнение вырождено, если коэффициенты при старшем и линейном членах
    // оба равны нулю (уравнение не зависит от значения переменной)
    if (checkEQ(myA, 0.0) == true   &&   checkEQ(myB, 0.0) == true)
        return true;
    return false;
}




//=====================================================================================================================
// Вычисление корней уравнения
vector<double> CEquationQuadratic::solve() const
{
    vector<double> rootList;    // Будущий список корней уравнения


    // Если уравнение вырожденное, то список корней пуст
    if (isConfluent() == true)
        return rootList;

    // Если уравнение линейное, то корень единственный
    if (checkEQ(myA, 0.0) == true)
    {
        rootList.push_back(-myC / myB);
        return rootList;
    }

    // Вычисление дискриминанта квадратного уравнения
    double D = myB*myB - 4.0*myA*myC;

    // Если дискриминант отрицательный, то нет корней
    if (checkLT(D, 0.0) == true)
        return rootList;

    // Если дискриминант равен нулю, то корень единственный
    if (checkEQ(D, 0.0) == true)
    {
        rootList.push_back(-myB / (2.0*myA));
        return rootList;
    }

    // Если дискриминант положительный, то корня два
    rootList.push_back((-myB - sqrt(D)) / (2.0*myA));
    rootList.push_back((-myB + sqrt(D)) / (2.0*myA));
    return rootList;
}

