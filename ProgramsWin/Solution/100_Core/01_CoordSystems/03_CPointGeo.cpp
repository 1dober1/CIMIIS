// Файл 03_CPointGeo.cpp
// Положение моделируемого объекта в геодезической системе координат
//

//=====================================================================================================================
// Заголовочные файлы
#include "03_CPointGeo.h"
#include "02_CPointGlobal.h"




//=====================================================================================================================
// Конструктор класса
CPointGeo::CPointGeo()
{
    myTime = 0.0;
    myLatitude = 0.0;
    myLongitude = 0.0;
    myAltitude = 0.0;
    myRoll = 0.0;
}




//---------------------------------------------------------------------------------------------------------------------
// Конструктор класса
CPointGeo::CPointGeo(double t, double latitude, double longitude, double altitude, double roll)
{
    myTime = t;
    myLatitude = latitude;
    myLongitude = longitude;
    myAltitude = altitude;
    myRoll = roll;
}




//=====================================================================================================================
// Пересчёт положения объекта в геоцентрическую систему координат
CPointGlobal CPointGeo::toPointGlobal() const
{
    // Будущий результат преобразования
    CPointGlobal result;
    result.setTime(myTime);
    result.setVelocity(myVelocity);
    result.setRoll(myRoll);

    // Преобразование текущего положения в декартову СК
    CPoint3D pos;
    _transformToCartesian(myLatitude, myLongitude, myAltitude, pos);

    // Формирование точки маршрута
    result.setPosition(pos);
    ErrorCode = ERR_OK;
    return result;
}




//=====================================================================================================================
// Доступ к параметрам положения объекта
double CPointGeo::getTime() const
{
    return myTime;
}




//---------------------------------------------------------------------------------------------------------------------
// Доступ к параметрам положения объекта
double CPointGeo::getLatitude() const
{
    return myLatitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Доступ к параметрам положения объекта
double CPointGeo::getLongitude() const
{
    return myLongitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Доступ к параметрам положения объекта
double CPointGeo::getAltitude() const
{
    return myAltitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Доступ к параметрам положения объекта
double CPointGeo::getRoll() const
{
    return myRoll;
}




//=====================================================================================================================
// Изменение параметров положения объекта
void CPointGeo::setTime(double time)
{
    myTime = time;
}




//---------------------------------------------------------------------------------------------------------------------
// Изменение параметров положения объекта
void CPointGeo::setVelocity(const CVector3D &vel)
{
    myVelocity = vel;
}




//---------------------------------------------------------------------------------------------------------------------
// Изменение параметров положения объекта
void CPointGeo::setPosition(double latitude, double longitude)
{
    myLatitude = latitude;
    myLongitude = longitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Изменение параметров положения объекта
void CPointGeo::setPosition(double latitude, double longitude, double altitude)
{
    myLatitude = latitude;
    myLongitude = longitude;
    myAltitude = altitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Изменение параметров положения объекта
void CPointGeo::setAltitude(double altitude)
{
    myAltitude = altitude;
}




//---------------------------------------------------------------------------------------------------------------------
// Изменение параметров положения объекта
void CPointGeo::setRoll(double roll)
{
    myRoll = roll;
}




//=====================================================================================================================
// Вспомогательная функция для преобразования в геоцентрическую декартову СК
void CPointGeo::_transformToCartesian(double lat, double lon, double alt, CPoint3D &point)
{
    // Если точка находится на экваторе
    if (checkEQ(lat, 0.0) == true)
    {
        point.setX((Settings.getEarthMajorRadius() + alt) * cos(deg2rad(lon)));
        point.setY((Settings.getEarthMajorRadius() + alt) * sin(deg2rad(lon)));
        point.setZ(0.0);
        return;
    }


    // Если точка находится на Северном полюсе
    if (checkEQ(lat, 90.0) == true)
    {
        point.setX(0.0);
        point.setY(0.0);
        point.setZ(Settings.getEarthMinorRadius() + alt);
        return;
    }


    // Если точка находится на Южном полюсе
    if (checkEQ(lat, -90.0) == true)
    {
        point.setX(0.0);
        point.setY(0.0);
        point.setZ(-(Settings.getEarthMinorRadius() + alt));
        return;
    }


    // Рассмотрим сечение ОЗЭ вертикальной плоскостью, содержащей ось вращения
    // планеты и данную точку. Пусть в этой плоскости O - начало координат,
    // горизонтальная ось называется Ox (содержит сечение плоскости экватора),
    // вертикальная ось - Oy (содержит ось вращения планеты).
    // Тогда сечение ОЗЭ есть эллипс с центром в точке O, описываемый
    // каноническим уравнением
    //    x*x       y*y
    //   -----  +  -----  =  1, где a > b - полуоси эллипса.
    //    a*a       b*b
    //
    // Пусть A = (xA, yA) - данная точка. Пусть C = (xC, yC) - точка
    // пересечения эллипса и нормали к нему, которая содержит точку A.
    // Пусть M - точка пересечения этой нормали с осью Ox, K - проекция точки A
    // на ось Ox. Тогда угол AMK по определению является геодезической широтой
    // точки A.
    //
    // Уравнение нормали к эллипсу в точке C имеет вид:
    //    y - yC       a*a*yC
    //   --------  =  -------- .
    //    x - xC       b*b*xC
    //
    // Перепишем это уравнение в форме с угловым коэффициентом:
    //        a*a*yC                   a*a*yC
    //   y = -------- * x   +   (yC - --------)
    //        b*b*xC                     b*b
    //
    // Нормаль к эллипсу в точке C должна быть наклонена к положительному
    // направлению оси Ox под углом AMK. Следовательно, должно выполняться
    // соотношение:
    //    a*a*yC 
    //   -------- = tg(AMK).
    //    b*b*xC
    //
    // Отсюда можно выразить yC:
    //          b*b*tg(AMK)
    //    yC = ------------- * xC.              (1)
    //              a*a
    //
    // С другой стороны, точка C принадлежит эллипсу и, следовательно, должна
    // удовлетворять его уравнению:
    //    xC*xC       yC*yC
    //   -------  +  -------  =  1              (2)
    //     a*a         b*b
    //
    // Решая систему из уравнений (1) и (2), можно найти координаты xC и yC:
    //       1      b*b*tg(AMK)*tg(AMK)
    //    (----- + --------------------) * xC^2  -  1  =  0
    //      a*a            a^4
    //
    double a = Settings.getEarthMajorRadius();
    double b = Settings.getEarthMinorRadius();
    double tgAMK = tan(deg2rad(lat));

    // Вычисление координат точки C
    double xC = sqrt(1.0 / (1.0/(a*a) + b*b*tgAMK*tgAMK/(a*a*a*a)));
    double yC = b*b*tgAMK/(a*a)*xC;

    // Проведём на рисунке прямые x=xC и y=yC. Рассмотрим треугольник,
    // образованный отрезками этих прямых и отрезком AC (данный треугольник
    // прямоугольный, AC - его гипотенуза).
    // 
    // Соответственно, координаты точки A будут равны
    //    xA = xC + h*cos(AMK)   и   yA = yC + h*sin(AMK)

    // Координата yA соответствует координате z в геоцентрической СК.
    // Координаты x и y в ГСК, соответственно, вычисляются по формулам:
    //    x = xA * cos(долгота_точки),
    //    y = xA * sin(долгота_точки).
    point.setX((xC + alt*cos(deg2rad(lat))) * cos(deg2rad(lon)));
    point.setY((xC + alt*cos(deg2rad(lat))) * sin(deg2rad(lon)));
    point.setZ(yC + alt*sin(deg2rad(lat)));
}


