// Файл 02_CPointGlobal.cpp
// Положение моделируемого объекта в геоцентрической декартовой системе координат
//

//=====================================================================================================================
// Заголовочные файлы
#include "02_CPointGlobal.h"
#include "03_CPointGeo.h"




//=====================================================================================================================
// Конструктор класса
CPointGlobal::CPointGlobal()
{
}




//---------------------------------------------------------------------------------------------------------------------
// Конструктор класса
CPointGlobal::CPointGlobal(double t, const CPoint3D &pos, double roll)
     : CPointLocal(t, pos, roll)
{
}




//---------------------------------------------------------------------------------------------------------------------
// Конструктор класса
CPointGlobal::CPointGlobal(double t, const CPoint3D &pos, const CVector3D &vel, double roll)
     : CPointLocal(t, pos, vel, roll)
{
}




//=====================================================================================================================
// Пересчёт положения объекта в геодезическую систему координат
CPointGeo CPointGlobal::toPointGeo() const
{
    // Будущий результат преобразования
    CPointGeo result;
    result.setTime(myTime);
    result.setVelocity(myVelocity);
    result.setRoll(myRoll);

    // Преобразование текущего положения к сферическую СК
    double latitude, longitude;
    double altitude;
    _transformToSpheric(myPosition, latitude, longitude, altitude);
    if (ErrorCode != ERR_OK)
        return result;

    // Формирование точки маршрута
    result.setPosition(latitude, longitude, altitude);
    return result;
}




//=====================================================================================================================
// Пересчёт положения объекта в местную декартову систему координат
CPointLocal CPointGlobal::toPointLocal(const CPoint3D &ortho) const
{
    // Будущий результат преобразования
    CPointLocal result;
    result.setTime(myTime);
    result.setRoll(myRoll);

    // Преобразование текущего положения к местную СК
    CPoint3D localPos = _transformToLocal(myPosition, ortho);
    if (ErrorCode != ERR_OK)
        return result;

    // Вычисление положения через 1 секунду
    CPoint3D newPos = myPosition;
    newPos.moveOn(myVelocity);

    // Преобразование нового положения в местную СК
    CPoint3D newLocalPos = _transformToLocal(newPos, ortho);
    // Проверка ошибок при преобразовании не требуется, она выполнена при первом преобразовании

    // Вычисление параметров движения
    CVector3D localVel(localPos, newLocalPos);

    // Формирование точки маршрута
    result.setPosition(localPos);
    result.setVelocity(localVel);
    return result;
}




//=====================================================================================================================
// Вспомогательная функция для преобразования в геодезическую СК
void CPointGlobal::_transformToSpheric(const CPoint3D &point, double &lat, double &lon, double &alt)
{
    // Вычисление расстояния от точки до центра Земли
    CPoint3D center(0.0, 0.0, 0.0);
    double dist = center.computeDistanceTo(point);
    if (checkEQ(dist, 0.0) == true)
    {
        lat = 0.0;
        lon = 0.0;
        alt = 0.0;
        ErrorCode = ERR_BAD_POINT;
        return;
    }

    // Если точка находится на экваторе
    //if (checkEQ(point.getZ(), 0.0) == true)
    // 
    // Вблизи экватора возникают ошибки при вычислениях, связанные с точностью формул
    // Введён костыль: +/-20 метром по оси Z от экватора считается экватором
    if (fabs(point.getZ()) <= 20.0)
    {
        // На экваторе широта нулевая
        lat = 0.0;

        // Вычисление долготы
        lon = rad2deg(acos(point.getX() / dist));

        // Долготы западнее Гринвичского меридиана считаются отрицательными
        if (checkLT(point.getY(), 0.0) == true)
            lon = -lon;

        // Вычисление высоты над поверхностью планеты
        alt = dist - Settings.getEarthMajorRadius();
        ErrorCode = ERR_OK;
        return;
    }


    // Если точка находится полюсе (Северном или Южном)
    if (checkEQ(point.getX(), 0.0) == true   &&
        checkEQ(point.getY(), 0.0) == true)
    {
        // На Северном полюсе широта +90 градусов
        if (checkGE(point.getZ(), 0.0) == true)
            lat = 90.0;

        // На Южном полюсе широта -90 градусов
        else
            lat = -90.0;

        // Долгота на полюсе не определена (полагаем нулевую)
        lon = 0.0;

        // Вычисление высоты над поверхностью планеты
        alt = dist - Settings.getEarthMinorRadius();
        ErrorCode = ERR_OK;
        return;
    }


    //-------------------------------------------------------------------------
    // Вычисление долготы. Спроецируем нашу точку на плоскость экватора.
    // В этой плоскости можно посчитать расстояние от точки O до проекции
    // нашей точки и, соответственно, долготу.
    lon = 0.0;
    CPoint3D projection(point.getX(), point.getY(), 0.0);
    dist = center.computeDistanceTo(projection);

    // Вычисление долготы (на полюсах остаётся нулевой)
    if (checkEQ(dist, 0.0) == false)
        lon = rad2deg(acos(point.getX() / dist));

    // Долготы западнее Гринвичского меридиана считаются отрицательными
    if (checkLT(point.getY(), 0.0) == true)
        lon = -lon;


    //-------------------------------------------------------------------------
    // Вычисление широты и высоты над поверхностью планеты. Рассмотрим сечение
    // ОЗЭ вертикальной плоскостью, содержащей ось вращения планеты и данную
    // точку. Пусть в этой плоскости O - начало координат, горизонтальная ось
    // называется Ox (содержит сечение плоскости экватора), вертикальная ось -
    // Oy (содержит ось вращения планеты). Тогда сечение ОЗЭ есть эллипс с
    // центром в точке O, описываемый каноническим уравнением
    //    x*x       y*y
    //   -----  +  -----  =  1, где a > b - полуоси эллипса.
    //    a*a       b*b
    //
    // Пусть A = (xA, yA) - данная точка, K - её проекция на ось Ox, T - её
    // проекция на ось Oy. OK = xA = dist, OT = yA = z, где z - координата в
    // гринвичской геоцентрической декартовой СК.
    //
    // Пусть C = (xC, yC) - точка пересечения эллипса и нормали к нему, которая
    // содержит точку A. Уравнение нормали к эллипсу в точке C в общем виде:
    //    y - yC       a*a*yC
    //   --------  =  -------- .
    //    x - xC       b*b*xC
    //
    // Нормаль должна проходить через точку A. Следовательно, координаты
    // точки A должны удовлетворять уравнению нормали:
    //    yA - yC       a*a*yC
    //   ---------  =  --------                 (1)
    //    xA - xC       b*b*xC
    //
    // Точка C одновременно принадлежит эллипсу. Следовательно, её координаты
    // должны удовлетворять уравнению эллипса:
    //    xC*xC       yC*yC
    //   -------  +  -------  =  1              (2)
    //     a*a         b*b
    //
    // Решая систему из уравнений (1) и (2), можно найти координаты xC и yC.
    // Сначала из уравнения (2) выразим yC через xC:
    //    yC =   b/a * sqrt(a*a - xC*xC),
    //    yC = - b/a * sqrt(a*a - xC*xC).
    //
    // Подставим получившееся выражение в уравнение (1). После несложных
    // преобразований уравнение (1) сводится к уравнению четвёртой степени
    // относительно xC:
    //   xC^4  *  [2*a*a*b*b - a^4 - b^4]   +   xC^3  *  [2*xA*a^4 - 2*a*a*b*b*xA]   +
    //   xC^2  *  [a^6 - 2*b*b*a^4 + a*a*b^4 - xA*xA*a^4 - a*a*b*b*yA*yA]    +
    //   xC    *  [2*b*b*xA*a^4 - 2*xA*a^6]   +   xA*xA*a^6   =   0
    // При этом возможны посторонние корни. Истинные корни должны удовлетворять
    // следующим условиям:
    //    1) xC != 0,   xA - xC != 0;
    //    2) -a <= xC <= a;
    //
    // При этом координату yC следует считать так:
    //    1) yC =   b/a * sqrt(a*a - xC*xC), если
    //          xC * (a*a - b*b) - a*a*xA <= 0   и   xC * yA >= 0
    //                                  или
    //          xC * (a*a - b*b) - a*a*xA >= 0   и   xC * yA <= 0
    //
    //    2) yC = - b/a * sqrt(a*a - xC*xC), если
    //          xC * (a*a - b*b) - a*a*xA <= 0   и   xC * yA <= 0
    //                                  или
    //          xC * (a*a - b*b) - a*a*xA >= 0   и   xC * yA >= 0
    //
    // Среди найденных корней системы уравнений (1) и (2) можно сразу отбросить
    // корни, где xC < 0. Кроме того, среди оставшихся корней целесообразно
    // оставить ту пару (xC, yC), которая обеспечивает минимум длины
    // отрезка AC. Таким образом, высота над поверхностью планеты найдена.
    //
    // Представим уравнение нормали к эллипсу в точке C в форме с угловым
    // коэффициентом:
    //        a*a*yC                   a*a*yC
    //   y = -------- * x   +   (yC - --------)
    //        b*b*xC                     b*b
    //
    // Угол между нормалью к эллипсу в точке C и положительным направлением
    // оси Ox должен быть равен широте точки A. Следовательно, должно
    // выполняться соотношение:
    //            a*a*yC 
    //   tg(B) = --------.
    //            b*b*xC
    //

    // Полуоси ОЗЭ
    double a = Settings.getEarthMajorRadius();
    double b = Settings.getEarthMinorRadius();

    // Координаты точки A
    double xA = dist;
    double yA = point.getZ();

    // Если интересующая нас точка лежит на поверхности эллипса
    if (checkEQ(xA*xA/(a*a) + yA*yA/(b*b), 1.0) == true)
    {
        alt = 0.0;
        lat = rad2deg(atan2(a*a*yA, b*b*xA));
        ErrorCode = ERR_OK;
        return;
    }

    double ratioA = 2.0*a*a*b*b - a*a*a*a - b*b*b*b;
    double ratioB = 2.0*a*a*a*a*xA - 2.0*a*a*b*b*xA;
    double ratioC = a*a*a*a*a*a - 2.0*a*a*a*a*b*b + a*a*b*b*b*b - a*a*a*a*xA*xA - a*a*b*b*yA*yA;
    double ratioD = 2.0*a*a*a*a*b*b*xA - 2.0*a*a*a*a*a*a*xA;
    double ratioE = a*a*a*a*a*a*xA*xA;

    // Поиск корней уравнения четвёртой степени
    CEquationQuartic equation(ratioA, ratioB, ratioC, ratioD, ratioE);
    vector<double> roots = equation.solve();

    // Отсев посторонних корней
    vector<double> rootsTemp;
    for (size_t i = 0; i < roots.size(); ++i)
    {
        // Отсев отрицательных корней и чистого нуля
        if (checkLT(roots[i], 0.0) == true)
            continue;

        // Отсев значений, лежащих за пределами эллипса
        if (checkGT(roots[i], a) == true)
            continue;

        // Сохранение подходящих
        rootsTemp.push_back(roots[i]);
    }


    // Если корней уравнения не найдено, то данный алгоритм неверен
    roots = rootsTemp;
    if (roots.empty() == true)
    {
        alt = 0.0;
        lat = 0.0;
        ErrorCode = ERR_BAD_POINT;
        return;
    }

    // Выбор подходящей точки пересечения эллипса с нормалью к нему
    // Ну, на фиг алгоритм проверки корней, описанный выше.
    // Будем тупо считать все высоты и брать наименьшую
    double xC, yC;
    alt = DBL_MAX;
    CPoint3D pointA(xA, yA, 0.0);
    for (size_t i = 0; i < roots.size(); ++i)
    {
        // Вычисление координат верхней точки пересечения и высоты
        double x = roots[i];
        double y = b / a * sqrt(a*a - x*x);

        // Вычисление высоты AC
        CPoint3D pointC(x, y, 0.0);
        double altitude = pointA.computeDistanceTo(pointC);

        // Проверяем, не находится ли точка под поверхностью земли
        if (checkLT(center.computeDistanceTo(pointA), center.computeDistanceTo(pointC)) == true)
            altitude = -altitude;

        if (fabs(altitude) < fabs(alt))
        {
            alt = altitude;
            xC = x;
            yC = y;
        }

        pointC = CPoint3D(x, -y, 0.0);
        altitude = pointA.computeDistanceTo(pointC);

        if (checkLT(center.computeDistanceTo(pointA), center.computeDistanceTo(pointC)) == true)
            altitude = -altitude;

        if (fabs(altitude) < fabs(alt))
        {
            alt = altitude;
            xC = x;
            yC = y;
        }
    }

    // Вычисление широты
    lat = rad2deg(atan2(a*a*yC, b*b*xC));

    // Южные широты должны быть отрицательными
    if (checkLT(point.getZ(), 0.0) == true)
        lat = -lat;
    ErrorCode = ERR_OK;
}




//=====================================================================================================================
// Вспомогательная функция для преобразования в местную декартову СК
CPoint3D CPointGlobal::_transformToLocal(const CPoint3D &point, const CPoint3D &ortho)
{
    // Пусть O - начало гринвичской геоцентрической декартовой системы
    // координат, C = (xC, yC, zC) - начало (центр) местной декартовой системы
    // координат - находится на поверхности общего земного эллипсоида (ОЗЭ).
    // Необходимо вычислить координаты ортов Ox', Oy', Oz' местной СК в
    // геоцентрической СК. Для простоты не будем заниматься нормированием
    // ортов на единицу (для этого есть уже готовый метод в CVector3D).
    //
    // Рассмотрим сечение ОЗЭ плоскостью, которая параллельна плоскости
    // экватора и содержит точку C. Пусть координатные оси Ox и Oy в этой
    // плоскости направлены как соответствующие оси геочентрической СК.
    // Сечение ОЗЭ этой плоскостью будет окружностью. Обозначим центр
    // окружности через A. Тогда AC = r = sqrt(xC*xC + yC*yC) - радиус.
    //
    // Орт Ox' местной СК лежит в рассматриваемой плоскости сечения на
    // касательной к окружности в точке C.
    // 
    // Уравнение окружности:
    //    x*x + y*y = r*r
    //
    // Уравнение касательной к окружности в точке C:
    //    xC*x + yC*y - r*r = 0
    //
    // Вектор нормали к касательной:
    //    n = (xC, yC)
    //
    // Направляющий вектор касательной (перпендикулярен вектору нормали):
    //    d = (-yC, xC)
    //
    // Поскольку орт Ox местной СК всегда лежит в плоскости, параллельной
    // плоскости экватора, его координаты в геоцентрической СК таковы:
    //    Ox' = (-yC, xC, 0)
    //
    // Рассмотрим сечение ОЗЭ плоскостью, которая содержит ось вращения планеты
    // и точку C. Пусть ось Oy в этой плоскости направлена как ось Oz
    // геоцентрической СК, а ось Ox образует с нею правую систему координат.
    // Сечением ОЗЭ этой плоскостью будет эллипс, центр эллипса совпарадет
    // с началом геоцентрической СК.
    //
    // Орт Oy' местной СК лежит в рассматриваемой плоскости на касательной к
    // эллипсу в точке C.
    //
    // Уравнение эллипса:
    //    b*b*x*x + a*a*y*y - a*a*b*b = 0
    //
    // Уравнение касательной к эллипсу в точке C:
    //    b*b*r*x + a*a*zC*y - a*a*b*b = 0
    //
    // Вектор нормали к касательной:
    //    n = (b*b*r, a*a*zC)
    //
    // Направляющий вектор касательной:
    //    d = (-a*a*zC, b*b*r)
    //
    // Вторая координата этого вектора является координатой орта Oy'
    // по оси Oz в геоцентрической СК. Теперь необходимо разложить первую
    // координату вектора d по осям Ox и Oy геоцентрической СК.
    //
    // Отложим на касательной к эллипсу отрезок CB в направлении
    // орта Oy'. Опустим из точки B перпендикуляр на ось Ox.
    // Проведём через точку C прямую, параллельную оси Ox. Она пересечёт
    // перпендикуляр, опущенный из точки B в точке D. Соответственно,
    // CD - проекция орта Oy' на ось Ox: CD = (-a*a*zC, 0).
    //
    // Рассмотрим ещё раз первое сечение. В нём только что построенный отрезок 
    // CD лежит на радиусе окружности и направлен к её центру. Опустим из
    // точки C перпендикуляр на ось Ox. Он пересечёт ось Ox в точке F.
    // Проведём через точку D прямую, параллельную оси Ox. Она пересечёт
    // перепендикуляр CF в точке G.
    //
    // Из треугольника CAF получаем, что sin(CAF) = yC/r, cos(CAF) = xC/r.
    // Из треугольника CDG получаем разложение вектора CD по координатным осям:
    //    CG = (0, -yC*a*a*zC/r),   DG = (-xC*a*a*zC/r, 0)
    //
    // В результате получаются координаты орта Oy':
    //    Oy' = (-xC*a*a*zC/r, -yC*a*a*zC/r, b*b*r)
    //
    // Орт Oz' получается как векторное произведение ортов Ox' и Oy'.
    //


    // Доступ к параметрам планеты
    double a = Settings.getEarthMajorRadius();
    double b = Settings.getEarthMinorRadius();

    // Вычисление орт местной системы координат
    double xC = ortho.getX();
    double yC = ortho.getY();
    double zC = ortho.getZ();
    double r = sqrt(xC*xC + yC*yC);
    if (checkEQ(r, 0.0) == true)
    {
        ErrorCode = ERR_BAD_ORTHO;
        return CPoint3D();
    }
    CVector3D newOx(-yC, xC, 0.0);
    CVector3D newOy(-a*a*xC*zC/r, -a*a*yC*zC/r, b*b*r);
    CVector3D newOz = newOx.computeVectorProductWith(newOy);
    newOx.setLength(1.0);
    newOy.setLength(1.0);
    newOz.setLength(1.0);

    // Перенос начала координат на поверхность планеты
    CPoint3D pos = point;
    pos.moveOrthoTo(ortho);

    // Переход к новым координатным осям
    // (от осей геоцентрической СК к осям местной СК)
    pos.changeBasis(newOx, newOy, newOz);
    ErrorCode = ERR_OK;
    return pos;
}






